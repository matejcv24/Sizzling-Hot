import {
  AlphaFilter,
  BlurFilter,
  BlurFilterPass
} from "./chunk-5JSJZNZN.js";
import "./chunk-MAVIPOPI.js";
import {
  ImageSource
} from "./chunk-5CNWHW5E.js";
import "./chunk-OYHIJWVX.js";
import "./chunk-Z5NQFYU5.js";
import "./chunk-EPJKLE7W.js";
import {
  Filter,
  ViewSystem
} from "./chunk-HDOHAJFI.js";
import {
  Color,
  DEG_TO_RAD,
  GlProgram,
  GpuProgram,
  ObservablePoint,
  Point,
  Texture,
  TexturePool,
  TextureSource,
  deprecation
} from "./chunk-6BQSSUA2.js";

// node_modules/pixi-filters/lib/defaults/default.mjs
var vertex = "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

// node_modules/pixi-filters/lib/defaults/default2.mjs
var wgslVertex = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}";

// node_modules/pixi-filters/lib/adjustment/adjustment.mjs
var fragment = "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uGamma;\nuniform float uContrast;\nuniform float uSaturation;\nuniform float uBrightness;\nuniform vec4 uColor;\n\nvoid main()\n{\n    vec4 c = texture(uTexture, vTextureCoord);\n\n    if (c.a > 0.0) {\n        c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1. / uGamma));\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, uSaturation), uContrast);\n        rgb.r *= uColor.r;\n        rgb.g *= uColor.g;\n        rgb.b *= uColor.b;\n        c.rgb = rgb * uBrightness;\n\n        c.rgb *= c.a;\n    }\n\n    finalColor = c * uColor.a;\n}\n";

// node_modules/pixi-filters/lib/adjustment/adjustment2.mjs
var source = "struct AdjustmentUniforms {\n  uGamma: f32,\n  uContrast: f32,\n  uSaturation: f32,\n  uBrightness: f32,\n  uColor: vec4<f32>,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> adjustmentUniforms : AdjustmentUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n  var sample = textureSample(uTexture, uSampler, uv);\n  let color = adjustmentUniforms.uColor;\n\n  if (sample.a > 0.0) \n  {\n    sample = vec4<f32>(sample.rgb / sample.a, sample.a);\n    var rgb: vec3<f32> = pow(sample.rgb, vec3<f32>(1. / adjustmentUniforms.uGamma));\n    rgb = mix(vec3<f32>(.5), mix(vec3<f32>(dot(vec3<f32>(.2125, .7154, .0721), rgb)), rgb, adjustmentUniforms.uSaturation), adjustmentUniforms.uContrast);\n    rgb.r *= color.r;\n    rgb.g *= color.g;\n    rgb.b *= color.b;\n    sample = vec4<f32>(rgb.rgb * adjustmentUniforms.uBrightness, sample.a);\n    sample = vec4<f32>(sample.rgb * sample.a, sample.a);\n  }\n\n  return sample * color.a;\n}";

// node_modules/pixi-filters/lib/adjustment/AdjustmentFilter.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _AdjustmentFilter = class _AdjustmentFilter2 extends Filter {
  /**
   * @param options - The options of the adjustment filter.
   */
  constructor(options) {
    options = { ..._AdjustmentFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment,
      name: "adjustment-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        adjustmentUniforms: {
          uGamma: { value: options.gamma, type: "f32" },
          uContrast: { value: options.contrast, type: "f32" },
          uSaturation: { value: options.saturation, type: "f32" },
          uBrightness: { value: options.brightness, type: "f32" },
          uColor: {
            value: [
              options.red,
              options.green,
              options.blue,
              options.alpha
            ],
            type: "vec4<f32>"
          }
        }
      }
    });
    __publicField(this, "uniforms");
    this.uniforms = this.resources.adjustmentUniforms.uniforms;
  }
  /**
   * Amount of luminance
   * @default 1
   */
  get gamma() {
    return this.uniforms.uGamma;
  }
  set gamma(value) {
    this.uniforms.uGamma = value;
  }
  /**
   * Amount of contrast
   * @default 1
   */
  get contrast() {
    return this.uniforms.uContrast;
  }
  set contrast(value) {
    this.uniforms.uContrast = value;
  }
  /**
   * Amount of color saturation
   * @default 1
   */
  get saturation() {
    return this.uniforms.uSaturation;
  }
  set saturation(value) {
    this.uniforms.uSaturation = value;
  }
  /**
   * The overall brightness
   * @default 1
   */
  get brightness() {
    return this.uniforms.uBrightness;
  }
  set brightness(value) {
    this.uniforms.uBrightness = value;
  }
  /**
   * The multiplied red channel
   * @default 1
   */
  get red() {
    return this.uniforms.uColor[0];
  }
  set red(value) {
    this.uniforms.uColor[0] = value;
  }
  /**
   * The multiplied blue channel
   * @default 1
   */
  get green() {
    return this.uniforms.uColor[1];
  }
  set green(value) {
    this.uniforms.uColor[1] = value;
  }
  /**
   * The multiplied green channel
   * @default 1
   */
  get blue() {
    return this.uniforms.uColor[2];
  }
  set blue(value) {
    this.uniforms.uColor[2] = value;
  }
  /**
   * The overall alpha channel
   * @default 1
   */
  get alpha() {
    return this.uniforms.uColor[3];
  }
  set alpha(value) {
    this.uniforms.uColor[3] = value;
  }
};
__publicField(_AdjustmentFilter, "DEFAULT_OPTIONS", {
  gamma: 1,
  contrast: 1,
  saturation: 1,
  brightness: 1,
  red: 1,
  green: 1,
  blue: 1,
  alpha: 1
});
var AdjustmentFilter = _AdjustmentFilter;

// node_modules/pixi-filters/lib/kawase-blur/kawase-blur.mjs
var fragment2 = "\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    finalColor = color;\n}";

// node_modules/pixi-filters/lib/kawase-blur/kawase-blur2.mjs
var source2 = "struct KawaseBlurUniforms {\n  uOffset:vec2<f32>,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uOffset = kawaseBlurUniforms.uOffset;\n  var color: vec4<f32> = vec4<f32>(0.0);\n\n  // Sample top left pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y));\n  // Sample top right pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y));\n  // Sample bottom right pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y));\n  // Sample bottom left pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y));\n  // Average\n  color *= 0.25;\n\n  return color;\n}";

// node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp2.mjs
var fragmentClamp = "\nprecision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uOffset;\n\nuniform vec4 uInputClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample top right pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    finalColor = color;\n}\n";

// node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp.mjs
var sourceClamp = "struct KawaseBlurUniforms {\n  uOffset:vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uOffset = kawaseBlurUniforms.uOffset;\n  var color: vec4<f32> = vec4(0.0);\n\n  // Sample top left pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample top right pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample bottom right pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample bottom left pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Average\n  color *= 0.25;\n    \n  return color;\n}";

// node_modules/pixi-filters/lib/kawase-blur/KawaseBlurFilter.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _KawaseBlurFilter = class _KawaseBlurFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (typeof options === "number" || Array.isArray(options)) {
      deprecation("6.0.0", "KawaseBlurFilter constructor params are now options object. See params: { strength, quality, clamp, pixelSize }");
      options = { strength: options };
      if (args[1] !== void 0)
        options.quality = args[1];
      if (args[2] !== void 0)
        options.clamp = args[2];
    }
    options = { ..._KawaseBlurFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: (options == null ? void 0 : options.clamp) ? sourceClamp : source2,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: (options == null ? void 0 : options.clamp) ? fragmentClamp : fragment2,
      name: "kawase-blur-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        kawaseBlurUniforms: {
          uOffset: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    });
    __publicField2(this, "uniforms");
    __publicField2(this, "_pixelSize", { x: 0, y: 0 });
    __publicField2(this, "_clamp");
    __publicField2(this, "_kernels", []);
    __publicField2(this, "_blur");
    __publicField2(this, "_quality");
    this.uniforms = this.resources.kawaseBlurUniforms.uniforms;
    this.pixelSize = options.pixelSize ?? { x: 1, y: 1 };
    if (Array.isArray(options.strength)) {
      this.kernels = options.strength;
    } else if (typeof options.strength === "number") {
      this._blur = options.strength;
      this.quality = options.quality ?? 3;
    }
    this._clamp = !!options.clamp;
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    const uvX = this.pixelSizeX / input.source.width;
    const uvY = this.pixelSizeY / input.source.height;
    let offset;
    if (this._quality === 1 || this._blur === 0) {
      offset = this._kernels[0] + 0.5;
      this.uniforms.uOffset[0] = offset * uvX;
      this.uniforms.uOffset[1] = offset * uvY;
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      const renderTarget = TexturePool.getSameSizeTexture(input);
      let source210 = input;
      let target = renderTarget;
      let tmp;
      const last = this._quality - 1;
      for (let i = 0; i < last; i++) {
        offset = this._kernels[i] + 0.5;
        this.uniforms.uOffset[0] = offset * uvX;
        this.uniforms.uOffset[1] = offset * uvY;
        filterManager.applyFilter(this, source210, target, true);
        tmp = source210;
        source210 = target;
        target = tmp;
      }
      offset = this._kernels[last] + 0.5;
      this.uniforms.uOffset[0] = offset * uvX;
      this.uniforms.uOffset[1] = offset * uvY;
      filterManager.applyFilter(this, source210, output, clearMode);
      TexturePool.returnTexture(renderTarget);
    }
  }
  /**
    * The amount of blur, value greater than `0`.
    * @default 4
    */
  get strength() {
    return this._blur;
  }
  set strength(value) {
    this._blur = value;
    this._generateKernels();
  }
  /**
    * The quality of the filter, integer greater than `1`.
    * @default 3
    */
  get quality() {
    return this._quality;
  }
  set quality(value) {
    this._quality = Math.max(1, Math.round(value));
    this._generateKernels();
  }
  /**
    * The kernel size of the blur filter, for advanced usage
    * @default [0]
    */
  get kernels() {
    return this._kernels;
  }
  set kernels(value) {
    if (Array.isArray(value) && value.length > 0) {
      this._kernels = value;
      this._quality = value.length;
      this._blur = Math.max(...value);
    } else {
      this._kernels = [0];
      this._quality = 1;
    }
  }
  /**
    * The size of the pixels. Large size is blurrier. For advanced usage.
    * @default {x:1,y:1}
    */
  get pixelSize() {
    return this._pixelSize;
  }
  set pixelSize(value) {
    if (typeof value === "number") {
      this.pixelSizeX = this.pixelSizeY = value;
      return;
    }
    if (Array.isArray(value)) {
      this.pixelSizeX = value[0];
      this.pixelSizeY = value[1];
      return;
    }
    this._pixelSize = value;
  }
  /**
    * The size of the pixels on the `x` axis. Large size is blurrier. For advanced usage.
    * @default 1
    */
  get pixelSizeX() {
    return this.pixelSize.x;
  }
  set pixelSizeX(value) {
    this.pixelSize.x = value;
  }
  /**
    * The size of the pixels on the `y` axis. Large size is blurrier. For advanced usage.
    * @default 1
    */
  get pixelSizeY() {
    return this.pixelSize.y;
  }
  set pixelSizeY(value) {
    this.pixelSize.y = value;
  }
  /**
    * Get the if the filter is clamped
    * @default false
    */
  get clamp() {
    return this._clamp;
  }
  /** Update padding based on kernel data */
  _updatePadding() {
    this.padding = Math.ceil(this._kernels.reduce((acc, v) => acc + v + 0.5, 0));
  }
  /** Auto generate kernels by blur & quality */
  _generateKernels() {
    const blur = this._blur;
    const quality = this._quality;
    const kernels = [blur];
    if (blur > 0) {
      let k = blur;
      const step = blur / quality;
      for (let i = 1; i < quality; i++) {
        k -= step;
        kernels.push(k);
      }
    }
    this._kernels = kernels;
    this._updatePadding();
  }
};
__publicField2(_KawaseBlurFilter, "DEFAULT_OPTIONS", {
  strength: 4,
  quality: 3,
  clamp: false,
  pixelSize: { x: 1, y: 1 }
});
var KawaseBlurFilter = _KawaseBlurFilter;

// node_modules/pixi-filters/lib/advanced-bloom/advanced-bloom.mjs
var fragment3 = "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\nuniform float uBloomScale;\nuniform float uBrightness;\n\nvoid main() {\n    vec4 color = texture(uTexture, vTextureCoord);\n    color.rgb *= uBrightness;\n    vec4 bloomColor = vec4(texture(uMapTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= uBloomScale;\n    finalColor = color + bloomColor;\n}\n";

// node_modules/pixi-filters/lib/advanced-bloom/advanced-bloom2.mjs
var source3 = "struct AdvancedBloomUniforms {\n  uBloomScale: f32,\n  uBrightness: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> advancedBloomUniforms : AdvancedBloomUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color = textureSample(uTexture, uSampler, uv);\n  color = vec4<f32>(color.rgb * advancedBloomUniforms.uBrightness, color.a);\n\n  var bloomColor = vec4<f32>(textureSample(uMapTexture, uSampler, uv).rgb, 0.0);\n  bloomColor = vec4<f32>(bloomColor.rgb * advancedBloomUniforms.uBloomScale, bloomColor.a);\n  \n  return color + bloomColor;\n}\n";

// node_modules/pixi-filters/lib/advanced-bloom/extract-brightness.mjs
var fragment4 = "\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uThreshold;\n\nvoid main() {\n    vec4 color = texture(uTexture, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > uThreshold) {\n        finalColor = color;\n    } else {\n        finalColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n";

// node_modules/pixi-filters/lib/advanced-bloom/extract-brightness2.mjs
var source4 = "struct ExtractBrightnessUniforms {\n  uThreshold: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> extractBrightnessUniforms : ExtractBrightnessUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  // A simple & fast algorithm for getting brightness.\n  // It's inaccurate, but good enough for this feature.\n  let max: f32 = max(max(color.r, color.g), color.b);\n  let min: f32 = min(min(color.r, color.g), color.b);\n  let brightness: f32 = (max + min) * 0.5;\n\n  return select(vec4<f32>(0.), color, brightness > extractBrightnessUniforms.uThreshold);\n}\n";

// node_modules/pixi-filters/lib/advanced-bloom/ExtractBrightnessFilter.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => {
  __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _ExtractBrightnessFilter = class _ExtractBrightnessFilter2 extends Filter {
  constructor(options) {
    options = { ..._ExtractBrightnessFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source4,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment4,
      name: "extract-brightness-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        extractBrightnessUniforms: {
          uThreshold: { value: options.threshold, type: "f32" }
        }
      }
    });
    __publicField3(this, "uniforms");
    this.uniforms = this.resources.extractBrightnessUniforms.uniforms;
  }
  /**
   * Defines how bright a color needs to be extracted.
   * @default 0.5
   */
  get threshold() {
    return this.uniforms.uThreshold;
  }
  set threshold(value) {
    this.uniforms.uThreshold = value;
  }
};
__publicField3(_ExtractBrightnessFilter, "DEFAULT_OPTIONS", {
  threshold: 0.5
});
var ExtractBrightnessFilter = _ExtractBrightnessFilter;

// node_modules/pixi-filters/lib/advanced-bloom/AdvancedBloomFilter.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => {
  __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _AdvancedBloomFilter = class _AdvancedBloomFilter2 extends Filter {
  /**
   * @param options - Options for the AdvancedBloomFilter constructor.
   */
  constructor(options) {
    options = { ..._AdvancedBloomFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source3,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment3,
      name: "advanced-bloom-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        advancedBloomUniforms: {
          uBloomScale: { value: options.bloomScale, type: "f32" },
          uBrightness: { value: options.brightness, type: "f32" }
        },
        uMapTexture: Texture.WHITE
      }
    });
    __publicField4(this, "uniforms");
    __publicField4(this, "bloomScale", 1);
    __publicField4(this, "brightness", 1);
    __publicField4(this, "_extractFilter");
    __publicField4(this, "_blurFilter");
    this.uniforms = this.resources.advancedBloomUniforms.uniforms;
    this._extractFilter = new ExtractBrightnessFilter({
      threshold: options.threshold
    });
    this._blurFilter = new KawaseBlurFilter({
      strength: options.kernels ?? options.blur,
      quality: options.kernels ? void 0 : options.quality
    });
    Object.assign(this, options);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    const brightTarget = TexturePool.getSameSizeTexture(input);
    this._extractFilter.apply(filterManager, input, brightTarget, true);
    const bloomTarget = TexturePool.getSameSizeTexture(input);
    this._blurFilter.apply(filterManager, brightTarget, bloomTarget, true);
    this.uniforms.uBloomScale = this.bloomScale;
    this.uniforms.uBrightness = this.brightness;
    this.resources.uMapTexture = bloomTarget.source;
    filterManager.applyFilter(this, input, output, clearMode);
    TexturePool.returnTexture(bloomTarget);
    TexturePool.returnTexture(brightTarget);
  }
  /**
   * Defines how bright a color needs to be extracted.
   * @default 0.5
   */
  get threshold() {
    return this._extractFilter.threshold;
  }
  set threshold(value) {
    this._extractFilter.threshold = value;
  }
  /** The kernels of the Blur Filter */
  get kernels() {
    return this._blurFilter.kernels;
  }
  set kernels(value) {
    this._blurFilter.kernels = value;
  }
  /**
   * The strength of the Blur properties simultaneously
   * @default 2
   */
  get blur() {
    return this._blurFilter.strength;
  }
  set blur(value) {
    this._blurFilter.strength = value;
  }
  /**
   * The quality of the Blur Filter
   * @default 4
   */
  get quality() {
    return this._blurFilter.quality;
  }
  set quality(value) {
    this._blurFilter.quality = value;
  }
  /**
   * The pixel size of the Kawase Blur filter
   * @default {x:1,y:1}
   */
  get pixelSize() {
    return this._blurFilter.pixelSize;
  }
  set pixelSize(value) {
    if (typeof value === "number") {
      value = { x: value, y: value };
    }
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this._blurFilter.pixelSize = value;
  }
  /**
   * The horizontal pixelSize of the Kawase Blur filter
   * @default 1
   */
  get pixelSizeX() {
    return this._blurFilter.pixelSizeX;
  }
  set pixelSizeX(value) {
    this._blurFilter.pixelSizeX = value;
  }
  /**
   * The vertical pixel size of the Kawase Blur filter
   * @default 1
   */
  get pixelSizeY() {
    return this._blurFilter.pixelSizeY;
  }
  set pixelSizeY(value) {
    this._blurFilter.pixelSizeY = value;
  }
};
__publicField4(_AdvancedBloomFilter, "DEFAULT_OPTIONS", {
  threshold: 0.5,
  bloomScale: 1,
  brightness: 1,
  blur: 8,
  quality: 4,
  pixelSize: { x: 1, y: 1 }
});
var AdvancedBloomFilter = _AdvancedBloomFilter;

// node_modules/pixi-filters/lib/ascii/ascii.mjs
var fragment5 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uSize;\nuniform vec3 uColor;\nuniform float uReplaceColor;\n\nuniform vec4 uInputSize;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= uInputSize.xy;\n    coord += uInputSize.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= uInputSize.zw;\n    coord /= uInputSize.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n    return floor(coord / size) * size;\n}\n\nvec2 getMod(vec2 coord, vec2 size)\n{\n    return mod(coord, size) / size;\n}\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, 4.0) + 2.5);\n\n    if (clamp(p.x, 0.0, 4.0) == p.x)\n    {\n        if (clamp(p.y, 0.0, 4.0) == p.y)\n        {\n            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n        }\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    // get the grid position\n    vec2 pixCoord = pixelate(coord, vec2(uSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    // sample the color at grid position\n    vec4 color = texture(uTexture, pixCoord);\n\n    // brightness of the color as it's perceived by the human eye\n    float gray = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\n\n    // determine the character to use\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    // get the mod..\n    vec2 modd = getMod(coord, vec2(uSize));\n\n    finalColor = (uReplaceColor > 0.5 ? vec4(uColor, 1.) : color) * character( n, vec2(-1.0) + modd * 2.0);\n}\n";

// node_modules/pixi-filters/lib/ascii/ascii2.mjs
var source5 = "struct AsciiUniforms {\n    uSize: f32,\n    uColor: vec3<f32>,\n    uReplaceColor: f32,\n};\n\nstruct GlobalFilterUniforms {\n    uInputSize:vec4<f32>,\n    uInputPixel:vec4<f32>,\n    uInputClamp:vec4<f32>,\n    uOutputFrame:vec4<f32>,\n    uGlobalFrame:vec4<f32>,\n    uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> asciiUniforms : AsciiUniforms;\n\n@fragment\nfn mainFragment(\n    @location(0) uv: vec2<f32>,\n    @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n    let pixelSize: f32 = asciiUniforms.uSize;\n    let coord: vec2<f32> = mapCoord(uv);\n\n    // get the rounded color..\n    var pixCoord: vec2<f32> = pixelate(coord, vec2<f32>(pixelSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    var color = textureSample(uTexture, uSampler, pixCoord);\n\n    // determine the character to use\n    let gray: f32 = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\n    \n    var n: f32 = 65536.0; // .\n    if (gray > 0.2) {\n        n = 65600.0;    // :\n    }\n    if (gray > 0.3) {\n        n = 332772.0;   // *\n    }\n    if (gray > 0.4) {\n        n = 15255086.0; // o\n    }\n    if (gray > 0.5) {\n        n = 23385164.0; // &\n    }\n    if (gray > 0.6) {\n        n = 15252014.0; // 8\n    }\n    if (gray > 0.7) {\n        n = 13199452.0; // @\n    }\n    if (gray > 0.8) {\n        n = 11512810.0; // #\n    }\n\n    // get the mod..\n    let modd: vec2<f32> = getMod(coord, vec2<f32>(pixelSize));\n    return select(color, vec4<f32>(asciiUniforms.uColor, 1.), asciiUniforms.uReplaceColor > 0.5) * character(n, vec2<f32>(-1.0) + modd * 2.0);\n}\n\nfn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\n{\n    return floor( coord / size ) * size;\n}\n\nfn getMod(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\n{\n    return moduloVec2( coord , size) / size;\n}\n\nfn character(n: f32, p: vec2<f32>) -> f32\n{\n    var q: vec2<f32> = floor(p*vec2<f32>(4.0, 4.0) + 2.5);\n\n    if (clamp(q.x, 0.0, 4.0) == q.x)\n    {\n        if (clamp(q.y, 0.0, 4.0) == q.y)\n        {\n        if (i32(modulo(n/exp2(q.x + 5.0*q.y), 2.0)) == 1)\n        {\n            return 1.0;\n        }\n        }\n    }\n\n    return 0.0;\n}\n\nfn modulo(x: f32, y: f32) -> f32\n{\n  return x - y * floor(x/y);\n}\n\nfn moduloVec2(x: vec2<f32>, y: vec2<f32>) -> vec2<f32>\n{\n  return x - y * floor(x/y);\n}\n\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n    var mappedCoord: vec2<f32> = coord;\n    mappedCoord *= gfu.uInputSize.xy;\n    mappedCoord += gfu.uOutputFrame.xy;\n    return mappedCoord;\n}\n\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n    var mappedCoord: vec2<f32> = coord;\n    mappedCoord -= gfu.uOutputFrame.xy;\n    mappedCoord /= gfu.uInputSize.xy;\n    return mappedCoord;\n}";

// node_modules/pixi-filters/lib/ascii/AsciiFilter.mjs
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => {
  __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _AsciiFilter = class _AsciiFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (typeof options === "number") {
      deprecation("6.0.0", "AsciiFilter constructor params are now options object. See params: { size, color, replaceColor }");
      options = { size: options };
    }
    const replaceColor = (options == null ? void 0 : options.color) && options.replaceColor !== false;
    options = { ..._AsciiFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source5,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment5,
      name: "ascii-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        asciiUniforms: {
          uSize: { value: options.size, type: "f32" },
          uColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uReplaceColor: { value: Number(replaceColor), type: "f32" }
        }
      }
    });
    __publicField5(this, "uniforms");
    __publicField5(this, "_color");
    this.uniforms = this.resources.asciiUniforms.uniforms;
    this._color = new Color();
    this.color = options.color ?? 16777215;
  }
  /**
   * The pixel size used by the filter.
   * @default 8
   */
  get size() {
    return this.uniforms.uSize;
  }
  set size(value) {
    this.uniforms.uSize = value;
  }
  /**
   * The resulting color of the ascii characters, as a 3 component RGB or numerical hex
   * @example [1.0, 1.0, 1.0] = 0xffffff
   * @default 0xffffff
   */
  get color() {
    return this._color.value;
  }
  set color(value) {
    this._color.setValue(value);
    const [r, g, b] = this._color.toArray();
    this.uniforms.uColor[0] = r;
    this.uniforms.uColor[1] = g;
    this.uniforms.uColor[2] = b;
  }
  /**
   * Determine whether or not to replace the source colors with the provided.
   */
  get replaceColor() {
    return this.uniforms.uReplaceColor > 0.5;
  }
  set replaceColor(value) {
    this.uniforms.uReplaceColor = value ? 1 : 0;
  }
};
__publicField5(_AsciiFilter, "DEFAULT_OPTIONS", {
  size: 8,
  color: 16777215,
  replaceColor: false
});
var AsciiFilter = _AsciiFilter;

// node_modules/pixi-filters/lib/backdrop-blur/backdrop-blur-blend2.mjs
var fragment6 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uBackground;\n\nvoid main(void){\n    vec4 front = texture(uTexture, vTextureCoord);\n    vec4 back = texture(uBackground, vTextureCoord);\n\n    if (front.a == 0.0) {\n        discard;\n    }\n    \n    vec3 color = mix(back.rgb, front.rgb / front.a, front.a);\n\n    finalColor = vec4(color, 1.0);\n}";

// node_modules/pixi-filters/lib/backdrop-blur/backdrop-blur-blend.mjs
var wgslFragment = "@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var uBackground: texture_2d<f32>; \n\n@fragment\nfn mainFragment(\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n    var front: vec4<f32> = textureSample(uTexture, uSampler, uv);\n    var back: vec4<f32> = textureSample(uBackground, uSampler, uv);\n    \n    if (front.a == 0.0) {\n        discard;\n    }\n\n    var color: vec3<f32> = mix(back.rgb, front.rgb / front.a, front.a);\n\n    return vec4<f32>(color, 1.0);\n}";

// node_modules/pixi-filters/lib/backdrop-blur/BackdropBlurFilter.mjs
var __defProp6 = Object.defineProperty;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField6 = (obj, key, value) => {
  __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var BackdropBlurFilter = class extends BlurFilter {
  /**
   * @param options - The options of the blur filter.
   */
  constructor(options) {
    super(options);
    __publicField6(this, "_blendPass");
    this.blendRequired = true;
    this.padding = 0;
    this._blendPass = new Filter({
      gpuProgram: GpuProgram.from({
        vertex: {
          source: wgslVertex,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: wgslFragment,
          entryPoint: "mainFragment"
        }
      }),
      glProgram: GlProgram.from({
        vertex,
        fragment: fragment6,
        name: "drop-shadow-filter"
      }),
      resources: {
        uBackground: Texture.EMPTY
      }
    });
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    const backTexture = filterManager._activeFilterData.backTexture;
    const blurredBackground = TexturePool.getSameSizeTexture(input);
    super.apply(filterManager, backTexture, blurredBackground, true);
    this._blendPass.resources.uBackground = blurredBackground.source;
    this._blendPass.apply(filterManager, input, output, clearMode);
    TexturePool.returnTexture(blurredBackground);
  }
  updatePadding() {
    this.padding = 0;
  }
};

// node_modules/pixi-filters/lib/bevel/bevel.mjs
var fragment7 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uTransform;\nuniform vec3 uLightColor;\nuniform float uLightAlpha;\nuniform vec3 uShadowColor;\nuniform float uShadowAlpha;\n\nuniform vec4 uInputSize;\n\nvoid main(void) {\n    vec2 transform = vec2(1.0 / uInputSize) * vec2(uTransform.x, uTransform.y);\n    vec4 color = texture(uTexture, vTextureCoord);\n    float light = texture(uTexture, vTextureCoord - transform).a;\n    float shadow = texture(uTexture, vTextureCoord + transform).a;\n\n    color.rgb = mix(color.rgb, uLightColor, clamp((color.a - light) * uLightAlpha, 0.0, 1.0));\n    color.rgb = mix(color.rgb, uShadowColor, clamp((color.a - shadow) * uShadowAlpha, 0.0, 1.0));\n    finalColor = vec4(color.rgb * color.a, color.a);\n}\n";

// node_modules/pixi-filters/lib/bevel/bevel2.mjs
var source6 = "struct BevelUniforms {\n  uLightColor: vec3<f32>,\n  uLightAlpha: f32,\n  uShadowColor: vec3<f32>,\n  uShadowAlpha: f32,\n  uTransform: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> bevelUniforms : BevelUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let transform = vec2<f32>(1.0 / gfu.uInputSize.xy) * vec2<f32>(bevelUniforms.uTransform.x, bevelUniforms.uTransform.y);\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let lightSample: f32 = textureSample(uTexture, uSampler, uv - transform).a;\n  let shadowSample: f32 = textureSample(uTexture, uSampler, uv + transform).a;\n\n  let light = vec4<f32>(bevelUniforms.uLightColor, bevelUniforms.uLightAlpha);\n  let shadow = vec4<f32>(bevelUniforms.uShadowColor, bevelUniforms.uShadowAlpha);\n\n  color = vec4<f32>(mix(color.rgb, light.rgb, clamp((color.a - lightSample) * light.a, 0.0, 1.0)), color.a);\n  color = vec4<f32>(mix(color.rgb, shadow.rgb, clamp((color.a - shadowSample) * shadow.a, 0.0, 1.0)), color.a);\n  \n  return vec4<f32>(color.rgb * color.a, color.a);\n}";

// node_modules/pixi-filters/lib/bevel/BevelFilter.mjs
var __defProp7 = Object.defineProperty;
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField7 = (obj, key, value) => {
  __defNormalProp7(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _BevelFilter = class _BevelFilter2 extends Filter {
  /**
   * @param options - Options for the BevelFilter constructor.
   */
  constructor(options) {
    options = { ..._BevelFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source6,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment7,
      name: "bevel-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        bevelUniforms: {
          uLightColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uLightAlpha: { value: options.lightAlpha, type: "f32" },
          uShadowColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uShadowAlpha: { value: options.shadowAlpha, type: "f32" },
          uTransform: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      },
      // Workaround: https://github.com/pixijs/filters/issues/230
      // applies correctly only if there is at least a single-pixel padding with alpha=0 around an image
      // To solve this problem, a padding of 1 put on the filter should suffice
      padding: 1
    });
    __publicField7(this, "uniforms");
    __publicField7(this, "_thickness");
    __publicField7(this, "_rotation");
    __publicField7(this, "_lightColor");
    __publicField7(this, "_shadowColor");
    this.uniforms = this.resources.bevelUniforms.uniforms;
    this._lightColor = new Color();
    this._shadowColor = new Color();
    this.lightColor = options.lightColor ?? 16777215;
    this.shadowColor = options.shadowColor ?? 0;
    Object.assign(this, options);
  }
  /**
   * The angle of the light in degrees
   * @default 45
   */
  get rotation() {
    return this._rotation / DEG_TO_RAD;
  }
  set rotation(value) {
    this._rotation = value * DEG_TO_RAD;
    this._updateTransform();
  }
  /**
   * The thickness of the bevel
   * @default 2
   */
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
    this._updateTransform();
  }
  /**
   * The color value of the left & top bevel.
   * @example [1.0, 1.0, 1.0] = 0xffffff
   * @default 0xffffff
   */
  get lightColor() {
    return this._lightColor.value;
  }
  set lightColor(value) {
    this._lightColor.setValue(value);
    const [r, g, b] = this._lightColor.toArray();
    this.uniforms.uLightColor[0] = r;
    this.uniforms.uLightColor[1] = g;
    this.uniforms.uLightColor[2] = b;
  }
  /**
   * The alpha value of the left & top bevel.
   * @default 0.7
   */
  get lightAlpha() {
    return this.uniforms.uLightAlpha;
  }
  set lightAlpha(value) {
    this.uniforms.uLightAlpha = value;
  }
  /**
   * The color value of the right & bottom bevel.
   * @default 0xffffff
   */
  get shadowColor() {
    return this._shadowColor.value;
  }
  set shadowColor(value) {
    this._shadowColor.setValue(value);
    const [r, g, b] = this._shadowColor.toArray();
    this.uniforms.uShadowColor[0] = r;
    this.uniforms.uShadowColor[1] = g;
    this.uniforms.uShadowColor[2] = b;
  }
  /**
   * The alpha value of the right & bottom bevel.
   * @default 0.7
   */
  get shadowAlpha() {
    return this.uniforms.uShadowAlpha;
  }
  set shadowAlpha(value) {
    this.uniforms.uShadowAlpha = value;
  }
  /**
   * Update the transform matrix of offset angle.
   * @private
   */
  _updateTransform() {
    this.uniforms.uTransform[0] = this.thickness * Math.cos(this._rotation);
    this.uniforms.uTransform[1] = this.thickness * Math.sin(this._rotation);
  }
};
__publicField7(_BevelFilter, "DEFAULT_OPTIONS", {
  rotation: 45,
  thickness: 2,
  lightColor: 16777215,
  lightAlpha: 0.7,
  shadowColor: 0,
  shadowAlpha: 0.7
});
var BevelFilter = _BevelFilter;

// node_modules/pixi-filters/lib/bloom/BloomFilter.mjs
var __defProp8 = Object.defineProperty;
var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField8 = (obj, key, value) => {
  __defNormalProp8(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _BloomFilter = class _BloomFilter2 extends AlphaFilter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (typeof options === "number" || Array.isArray(options) || "x" in options && "y" in options) {
      deprecation("6.0.0", "BloomFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }");
      let strength = options;
      if (Array.isArray(strength))
        strength = { x: strength[0], y: strength[1] };
      options = { strength };
      if (args[1] !== void 0)
        options.quality = args[1];
      if (args[2] !== void 0)
        options.resolution = args[2];
      if (args[3] !== void 0)
        options.kernelSize = args[3];
    }
    options = { ..._BloomFilter2.DEFAULT_OPTIONS, ...options };
    super();
    __publicField8(this, "_blurXFilter");
    __publicField8(this, "_blurYFilter");
    __publicField8(this, "_strength");
    this._strength = { x: 2, y: 2 };
    if (options.strength) {
      if (typeof options.strength === "number") {
        this._strength.x = options.strength;
        this._strength.y = options.strength;
      } else {
        this._strength.x = options.strength.x;
        this._strength.y = options.strength.y;
      }
    }
    this._blurXFilter = new BlurFilterPass({
      ...options,
      horizontal: true,
      strength: this.strengthX
    });
    this._blurYFilter = new BlurFilterPass({
      ...options,
      horizontal: false,
      strength: this.strengthY
    });
    this._blurYFilter.blendMode = "screen";
    Object.assign(this, options);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clear) {
    const renderTarget = TexturePool.getSameSizeTexture(input);
    filterManager.applyFilter(this, input, output, clear);
    this._blurXFilter.apply(filterManager, input, renderTarget, true);
    this._blurYFilter.apply(filterManager, renderTarget, output, false);
    TexturePool.returnTexture(renderTarget);
  }
  /**
   * Sets the strength of both the blurX and blurY properties simultaneously
   * @default 2
   */
  get strength() {
    return this._strength;
  }
  set strength(value) {
    this._strength = typeof value === "number" ? { x: value, y: value } : value;
    this._updateStrength();
  }
  /**
   * Sets the strength of the blur on the `x` axis
   * @default 2
   */
  get strengthX() {
    return this.strength.x;
  }
  set strengthX(value) {
    this.strength.x = value;
    this._updateStrength();
  }
  /**
   * Sets the strength of the blur on the `y` axis
   * @default 2
   */
  get strengthY() {
    return this.strength.y;
  }
  set strengthY(value) {
    this.strength.y = value;
    this._updateStrength();
  }
  _updateStrength() {
    this._blurXFilter.blur = this.strengthX;
    this._blurYFilter.blur = this.strengthY;
  }
  /**
   * @deprecated since 6.0.0
   *
   * The strength of both the blurX and blurY properties simultaneously
   * @default 2
   * @see BloomFilter#strength
   */
  get blur() {
    deprecation("6.0.0", "BloomFilter.blur is deprecated, please use BloomFilter.strength instead");
    return this.strengthX;
  }
  set blur(value) {
    deprecation("6.0.0", "BloomFilter.blur is deprecated, please use BloomFilter.strength instead");
    this.strength = value;
  }
  /**
   * @deprecated since 6.0.0
   *
   * The strength of the blurX property
   * @default 2
   * @see BloomFilter#strengthX
   */
  get blurX() {
    deprecation("6.0.0", "BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead");
    return this.strengthX;
  }
  set blurX(value) {
    deprecation("6.0.0", "BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead");
    this.strengthX = value;
  }
  /**
   * @deprecated since 6.0.0
   *
   * The strength of the blurY property
   * @default 2
   * @see BloomFilter#strengthY
   */
  get blurY() {
    deprecation("6.0.0", "BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead");
    return this.strengthY;
  }
  set blurY(value) {
    deprecation("6.0.0", "BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead");
    this.strengthY = value;
  }
};
__publicField8(_BloomFilter, "DEFAULT_OPTIONS", {
  strength: { x: 2, y: 2 },
  quality: 4,
  resolution: 1,
  kernelSize: 5
});
var BloomFilter = _BloomFilter;

// node_modules/pixi-filters/lib/bulge-pinch/bulge-pinch.mjs
var fragment8 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uDimensions;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform float uStrength;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nvoid main()\n{\n    vec2 coord = vTextureCoord * uInputSize.xy;\n    coord -= uCenter * uDimensions.xy;\n    float distance = length(coord);\n\n    if (distance < uRadius) {\n        float percent = distance / uRadius;\n        if (uStrength > 0.0) {\n            coord *= mix(1.0, smoothstep(0.0, uRadius / distance, percent), uStrength * 0.75);\n        } else {\n            coord *= mix(1.0, pow(percent, 1.0 + uStrength * 0.75) * uRadius / distance, 1.0 - percent);\n        }\n    }\n\n    coord += uCenter * uDimensions.xy;\n    coord /= uInputSize.xy;\n    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\n    vec4 color = texture(uTexture, clampedCoord);\n\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    finalColor = color;\n}\n";

// node_modules/pixi-filters/lib/bulge-pinch/bulge-pinch2.mjs
var source7 = "struct BulgePinchUniforms {\n  uDimensions: vec2<f32>,\n  uCenter: vec2<f32>,\n  uRadius: f32,\n  uStrength: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> bulgePinchUniforms : BulgePinchUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let dimensions: vec2<f32> = bulgePinchUniforms.uDimensions;\n  let center: vec2<f32> = bulgePinchUniforms.uCenter;\n  let radius: f32 = bulgePinchUniforms.uRadius;\n  let strength: f32 = bulgePinchUniforms.uStrength;\n  var coord: vec2<f32> = (uv * gfu.uInputSize.xy) - center * dimensions.xy;\n\n  let distance: f32 = length(coord);\n\n  if (distance < radius) {\n      let percent: f32 = distance / radius;\n      if (strength > 0.0) {\n          coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n      } else {\n          coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n      }\n  }\n    coord += (center * dimensions.xy);\n    coord /= gfu.uInputSize.xy;\n\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);\n    var color: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);\n    if (coord.x != clampedCoord.x && coord.y != clampedCoord.y) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    return color;\n}\n\nfn compareVec2(x: vec2<f32>, y: vec2<f32>) -> bool\n{\n  if (x.x == y.x && x.y == y.y)\n  {\n    return true;\n  }\n\n  return false;\n}";

// node_modules/pixi-filters/lib/bulge-pinch/BulgePinchFilter.mjs
var __defProp9 = Object.defineProperty;
var __defNormalProp9 = (obj, key, value) => key in obj ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField9 = (obj, key, value) => {
  __defNormalProp9(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _BulgePinchFilter = class _BulgePinchFilter2 extends Filter {
  /**
   * @param options - Options for the BulgePinchFilter constructor.
   */
  constructor(options) {
    options = { ..._BulgePinchFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source7,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment8,
      name: "bulge-pinch-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        bulgePinchUniforms: {
          uDimensions: { value: [0, 0], type: "vec2<f32>" },
          uCenter: { value: options.center, type: "vec2<f32>" },
          uRadius: { value: options.radius, type: "f32" },
          uStrength: { value: options.strength, type: "f32" }
        }
      }
    });
    __publicField9(this, "uniforms");
    this.uniforms = this.resources.bulgePinchUniforms.uniforms;
    Object.assign(this, options);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    this.uniforms.uDimensions[0] = input.frame.width;
    this.uniforms.uDimensions[1] = input.frame.height;
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * Sets the center of the effect in normalized screen coords.
   * { x: 0, y: 0 } means top-left and { x: 1, y: 1 } mean bottom-right
   * @default {x:0.5,y:0.5}
   */
  get center() {
    return this.uniforms.uCenter;
  }
  set center(value) {
    if (typeof value === "number") {
      value = { x: value, y: value };
    }
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this.uniforms.uCenter = value;
  }
  /**
   * Sets the center of the effect in normalized screen coords on the `x` axis
   * @default 0
   */
  get centerX() {
    return this.uniforms.uCenter.x;
  }
  set centerX(value) {
    this.uniforms.uCenter.x = value;
  }
  /**
   * Sets the center of the effect in normalized screen coords on the `y` axis
   * @default 0
   */
  get centerY() {
    return this.uniforms.uCenter.y;
  }
  set centerY(value) {
    this.uniforms.uCenter.y = value;
  }
  /**
   * The radius of the circle of effect
   * @default 100
   */
  get radius() {
    return this.uniforms.uRadius;
  }
  set radius(value) {
    this.uniforms.uRadius = value;
  }
  /**
   * A value between -1 and 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)
   * @default 1
   */
  get strength() {
    return this.uniforms.uStrength;
  }
  set strength(value) {
    this.uniforms.uStrength = value;
  }
};
__publicField9(_BulgePinchFilter, "DEFAULT_OPTIONS", {
  center: { x: 0.5, y: 0.5 },
  radius: 100,
  strength: 1
});
var BulgePinchFilter = _BulgePinchFilter;

// node_modules/pixi-filters/lib/color-gradient/color-gradient2.mjs
var fragment9 = "precision highp float;\nin vec2 vTextureCoord;\nin vec2 vFilterCoord;\nout vec4 finalColor;\n\nconst int TYPE_LINEAR = 0;\nconst int TYPE_RADIAL = 1;\nconst int TYPE_CONIC = 2;\nconst int MAX_STOPS = 32;\n\nuniform sampler2D uTexture;\nuniform vec4 uOptions;\nuniform vec2 uCounts;\nuniform vec3 uColors[MAX_STOPS];\nuniform vec4 uStops[MAX_STOPS];\n\nconst float PI = 3.1415926538;\nconst float PI_2 = PI*2.;\n\nstruct ColorStop {\n    float offset;\n    vec3 color;\n    float alpha;\n};\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle),\n    sin(angle), cos(angle));\n}\n\nfloat projectLinearPosition(vec2 pos, float angle){\n    vec2 center = vec2(0.5);\n    vec2 result = pos - center;\n    result = rotate2d(angle) * result;\n    result = result + center;\n    return clamp(result.x, 0., 1.);\n}\n\nfloat projectRadialPosition(vec2 pos) {\n    float r = distance(pos, vec2(0.5));\n    return clamp(2.*r, 0., 1.);\n}\n\nfloat projectAnglePosition(vec2 pos, float angle) {\n    vec2 center = pos - vec2(0.5);\n    float polarAngle=atan(-center.y, center.x);\n    return mod(polarAngle + angle, PI_2) / PI_2;\n}\n\nfloat projectPosition(vec2 pos, int type, float angle) {\n    if (type == TYPE_LINEAR) {\n        return projectLinearPosition(pos, angle);\n    } else if (type == TYPE_RADIAL) {\n        return projectRadialPosition(pos);\n    } else if (type == TYPE_CONIC) {\n        return projectAnglePosition(pos, angle);\n    }\n\n    return pos.y;\n}\n\nvoid main(void) {\n    int uType = int(uOptions[0]);\n    float uAngle = uOptions[1];\n    float uAlpha = uOptions[2];\n    float uReplace = uOptions[3];\n\n    int uNumStops = int(uCounts[0]);\n    float uMaxColors = uCounts[1];\n\n    // current/original color\n    vec4 currentColor = texture(uTexture, vTextureCoord);\n\n    // skip calculations if gradient alpha is 0\n    if (0.0 == uAlpha) {\n        finalColor = currentColor;\n        return;\n    }\n\n    // project position\n    float y = projectPosition(vFilterCoord, int(uType), radians(uAngle));\n\n    // check gradient bounds\n    float offsetMin = uStops[0][0];\n    float offsetMax = 0.0;\n\n    int numStops = int(uNumStops);\n\n    for (int i = 0; i < MAX_STOPS; i++) {\n        if (i == numStops-1){ // last index\n            offsetMax = uStops[i][0];\n        }\n    }\n\n    if (y  < offsetMin || y > offsetMax) {\n        finalColor = currentColor;\n        return;\n    }\n\n    // limit colors\n    if (uMaxColors > 0.) {\n        float stepSize = 1./uMaxColors;\n        float stepNumber = float(floor(y/stepSize));\n        y = stepSize * (stepNumber + 0.5);// offset by 0.5 to use color from middle of segment\n    }\n\n    // find color stops\n    ColorStop from;\n    ColorStop to;\n\n    for (int i = 0; i < MAX_STOPS; i++) {\n        if (y >= uStops[i][0]) {\n            from = ColorStop(uStops[i][0], uColors[i], uStops[i][1]);\n            to = ColorStop(uStops[i+1][0], uColors[i+1], uStops[i+1][1]);\n        }\n\n        if (i == numStops-1){ // last index\n            break;\n        }\n    }\n\n    // mix colors from stops\n    vec4 colorFrom = vec4(from.color * from.alpha, from.alpha);\n    vec4 colorTo = vec4(to.color * to.alpha, to.alpha);\n\n    float segmentHeight = to.offset - from.offset;\n    float relativePos = y - from.offset;// position from 0 to [segmentHeight]\n    float relativePercent = relativePos / segmentHeight;// position in percent between [from.offset] and [to.offset].\n\n    float gradientAlpha = uAlpha * currentColor.a;\n    vec4 gradientColor = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\n\n    if (uReplace < 0.5) {\n        // mix resulting color with current color\n        finalColor = gradientColor + currentColor*(1.-gradientColor.a);\n    } else {\n        // replace with gradient color\n        finalColor = gradientColor;\n    }\n}\n";

// node_modules/pixi-filters/lib/color-gradient/color-gradient.mjs
var vertex2 = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 vFilterCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    vFilterCoord = vTextureCoord * uInputSize.xy / uOutputFrame.zw;\n}\n";

// node_modules/pixi-filters/lib/color-gradient/color-gradient3.mjs
var source8 = "struct BaseUniforms {\n  uOptions: vec4<f32>,\n  uCounts: vec2<f32>,\n};\n\nstruct StopsUniforms {\n  uColors: array<vec3<f32>, MAX_STOPS>,\n  uStops: array<vec4<f32>, MAX_STOPS>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> baseUniforms : BaseUniforms;\n@group(1) @binding(1) var<uniform> stopsUniforms : StopsUniforms;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>,\n  @location(1) coord : vec2<f32>\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn filterCoord( vTextureCoord:vec2<f32> ) -> vec2<f32>\n{\n    return vTextureCoord * gfu.uInputSize.xy / gfu.uOutputFrame.zw;\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  let vTextureCoord: vec2<f32> = filterTextureCoord(aPosition);\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   vTextureCoord,\n   filterCoord(vTextureCoord),\n  );\n}\n\nstruct ColorStop {\n  offset: f32,\n  color: vec3<f32>,\n  alpha: f32,\n};\n\nfn rotate2d(angle: f32) -> mat2x2<f32>{\n  return mat2x2(cos(angle), -sin(angle),\n  sin(angle), cos(angle));\n}\n\nfn projectLinearPosition(pos: vec2<f32>, angle: f32) -> f32 {\n  var center: vec2<f32> = vec2<f32>(0.5);\n  var result: vec2<f32> = pos - center;\n  result = rotate2d(angle) * result;\n  result = result + center;\n  return clamp(result.x, 0.0, 1.0);\n}\n\nfn projectRadialPosition(pos: vec2<f32>) -> f32 {\n  var r: f32 = distance(pos, vec2<f32>(0.5));\n  return clamp(2.0 * r, 0.0, 1.0);\n}\n\nfn projectAnglePosition(pos: vec2<f32>, angle: f32) -> f32 {\n  var center: vec2<f32> = pos - vec2<f32>(0.5, 0.5);\n  var polarAngle: f32 = atan2(-center.y, center.x);\n  return ((polarAngle + angle) % PI_2) / PI_2;\n}\n\nfn projectPosition(pos: vec2<f32>, gradientType: i32, angle: f32) -> f32 {\n  if (gradientType == TYPE_LINEAR) {\n      return projectLinearPosition(pos, angle);\n  } else if (gradientType == TYPE_RADIAL) {\n      return projectRadialPosition(pos);\n  } else if (gradientType == TYPE_CONIC) {\n      return projectAnglePosition(pos, angle);\n  }\n\n  return pos.y;\n}\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>,\n  @location(1) coord : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uType: i32 = i32(baseUniforms.uOptions[0]);\n  let uAngle: f32 = baseUniforms.uOptions[1];\n  let uAlpha: f32 = baseUniforms.uOptions[2];\n  let uReplace: f32 = baseUniforms.uOptions[3];\n\n  let uNumStops: i32 = i32(baseUniforms.uCounts[0]);\n  let uMaxColors: f32 = baseUniforms.uCounts[1];\n\n  // current/original color\n  var currentColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  // skip calculations if gradient alpha is 0\n  if (uAlpha == 0.0) { return currentColor; }\n\n  // project position\n  var y: f32 = projectPosition(coord, uType, radians(uAngle));\n\n  // check gradient bounds\n  var offsetMin: f32 = stopsUniforms.uStops[0][0];\n  var offsetMax: f32 = 0.0;\n\n  let numStops: i32 = uNumStops;\n\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\n      if (i == numStops - 1) { // last index\n          offsetMax = stopsUniforms.uStops[i][0];\n      }\n  }\n\n  if (y  < offsetMin || y > offsetMax) { return currentColor; }\n\n  // limit colors\n  if (uMaxColors > 0.0) {\n      var stepSize: f32 = 1.0 / uMaxColors;\n      var stepNumber: f32 = floor(y / stepSize);\n      y = stepSize * (stepNumber + 0.5); // offset by 0.5 to use color from middle of segment\n  }\n\n  // find color stops\n  var stopFrom: ColorStop;\n  var stopTo: ColorStop;\n\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\n      if (y >= stopsUniforms.uStops[i][0]) {\n          stopFrom = ColorStop(stopsUniforms.uStops[i][0], stopsUniforms.uColors[i], stopsUniforms.uStops[i][1]);\n          stopTo = ColorStop(stopsUniforms.uStops[i + 1][0], stopsUniforms.uColors[i + 1], stopsUniforms.uStops[i + 1][1]);\n      }\n\n      if (i == numStops - 1) { // last index\n          break;\n      }\n  }\n\n  // mix colors from stops\n  var colorFrom: vec4<f32> = vec4<f32>(stopFrom.color * stopFrom.alpha, stopFrom.alpha);\n  var colorTo: vec4<f32> = vec4<f32>(stopTo.color * stopTo.alpha, stopTo.alpha);\n\n  var segmentHeight: f32 = stopTo.offset - stopFrom.offset;\n  var relativePos: f32 = y - stopFrom.offset; // position from 0 to [segmentHeight]\n  var relativePercent: f32 = relativePos / segmentHeight; // position in percent between [from.offset] and [to.offset].\n\n  var gradientAlpha: f32 = uAlpha * currentColor.a;\n  var gradientColor: vec4<f32> = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\n\n  if (uReplace < 0.5) {\n      // mix resulting color with current color\n      return gradientColor + currentColor * (1.0 - gradientColor.a);\n  } else {\n      // replace with gradient color\n      return gradientColor;\n  }\n}\n\nconst PI: f32 = 3.14159265358979323846264;\nconst PI_2: f32 = PI * 2.0;\n\nconst TYPE_LINEAR: i32 = 0;\nconst TYPE_RADIAL: i32 = 1;\nconst TYPE_CONIC: i32 = 2;\nconst MAX_STOPS: i32 = 32;";

// node_modules/pixi-filters/lib/external/gradient-parser/build/node.mjs
var GradientParser = GradientParser || {};
GradientParser.stringify = /* @__PURE__ */ function() {
  var visitor = {
    "visit_linear-gradient": function(node) {
      return visitor.visit_gradient(node);
    },
    "visit_repeating-linear-gradient": function(node) {
      return visitor.visit_gradient(node);
    },
    "visit_radial-gradient": function(node) {
      return visitor.visit_gradient(node);
    },
    "visit_repeating-radial-gradient": function(node) {
      return visitor.visit_gradient(node);
    },
    "visit_gradient": function(node) {
      var orientation = visitor.visit(node.orientation);
      if (orientation) {
        orientation += ", ";
      }
      return node.type + "(" + orientation + visitor.visit(node.colorStops) + ")";
    },
    "visit_shape": function(node) {
      var result = node.value, at = visitor.visit(node.at), style = visitor.visit(node.style);
      if (style) {
        result += " " + style;
      }
      if (at) {
        result += " at " + at;
      }
      return result;
    },
    "visit_default-radial": function(node) {
      var result = "", at = visitor.visit(node.at);
      if (at) {
        result += at;
      }
      return result;
    },
    "visit_extent-keyword": function(node) {
      var result = node.value, at = visitor.visit(node.at);
      if (at) {
        result += " at " + at;
      }
      return result;
    },
    "visit_position-keyword": function(node) {
      return node.value;
    },
    "visit_position": function(node) {
      return visitor.visit(node.value.x) + " " + visitor.visit(node.value.y);
    },
    "visit_%": function(node) {
      return node.value + "%";
    },
    "visit_em": function(node) {
      return node.value + "em";
    },
    "visit_px": function(node) {
      return node.value + "px";
    },
    "visit_literal": function(node) {
      return visitor.visit_color(node.value, node);
    },
    "visit_hex": function(node) {
      return visitor.visit_color("#" + node.value, node);
    },
    "visit_rgb": function(node) {
      return visitor.visit_color("rgb(" + node.value.join(", ") + ")", node);
    },
    "visit_rgba": function(node) {
      return visitor.visit_color("rgba(" + node.value.join(", ") + ")", node);
    },
    "visit_color": function(resultColor, node) {
      var result = resultColor, length = visitor.visit(node.length);
      if (length) {
        result += " " + length;
      }
      return result;
    },
    "visit_angular": function(node) {
      return node.value + "deg";
    },
    "visit_directional": function(node) {
      return "to " + node.value;
    },
    "visit_array": function(elements) {
      var result = "", size = elements.length;
      elements.forEach(function(element, i) {
        result += visitor.visit(element);
        if (i < size - 1) {
          result += ", ";
        }
      });
      return result;
    },
    "visit": function(element) {
      if (!element) {
        return "";
      }
      var result = "";
      if (element instanceof Array) {
        return visitor.visit_array(element, result);
      } else if (element.type) {
        var nodeVisitor = visitor["visit_" + element.type];
        if (nodeVisitor) {
          return nodeVisitor(element);
        } else {
          throw Error("Missing visitor visit_" + element.type);
        }
      } else {
        throw Error("Invalid node.");
      }
    }
  };
  return function(root) {
    return visitor.visit(root);
  };
}();
var GradientParser = GradientParser || {};
GradientParser.parse = /* @__PURE__ */ function() {
  var tokens = {
    linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
    repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
    radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
    repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  var input = "";
  function error(msg) {
    var err = new Error(input + ": " + msg);
    err.source = input;
    throw err;
  }
  function getAST() {
    var ast = matchListDefinitions();
    if (input.length > 0) {
      error("Invalid input not EOF");
    }
    return ast;
  }
  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }
  function matchDefinition() {
    return matchGradient(
      "linear-gradient",
      tokens.linearGradient,
      matchLinearOrientation
    ) || matchGradient(
      "repeating-linear-gradient",
      tokens.repeatingLinearGradient,
      matchLinearOrientation
    ) || matchGradient(
      "radial-gradient",
      tokens.radialGradient,
      matchListRadialOrientations
    ) || matchGradient(
      "repeating-radial-gradient",
      tokens.repeatingRadialGradient,
      matchListRadialOrientations
    );
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function(captures) {
      var orientation = orientationMatcher();
      if (orientation) {
        if (!scan(tokens.comma)) {
          error("Missing comma before color stops");
        }
      }
      return {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchCall(pattern, callback) {
    var captures = scan(pattern);
    if (captures) {
      if (!scan(tokens.startCall)) {
        error("Missing (");
      }
      var result = callback(captures);
      if (!scan(tokens.endCall)) {
        error("Missing )");
      }
      return result;
    }
  }
  function matchLinearOrientation() {
    return matchSideOrCorner() || matchAngle();
  }
  function matchSideOrCorner() {
    return match("directional", tokens.sideOrCorner, 1);
  }
  function matchAngle() {
    return match("angular", tokens.angleValue, 1);
  }
  function matchListRadialOrientations() {
    var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);
      lookaheadCache = input;
      if (scan(tokens.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }
    return radialOrientations;
  }
  function matchRadialOrientation() {
    var radialType = matchCircle() || matchEllipse();
    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      var extent = matchExtentKeyword();
      if (extent) {
        radialType = extent;
        var positionAt = matchAtPosition();
        if (positionAt) {
          radialType.at = positionAt;
        }
      } else {
        var defaultPosition = matchPositioning();
        if (defaultPosition) {
          radialType = {
            type: "default-radial",
            at: defaultPosition
          };
        }
      }
    }
    return radialType;
  }
  function matchCircle() {
    var circle = match("shape", /^(circle)/i, 0);
    if (circle) {
      circle.style = matchLength() || matchExtentKeyword();
    }
    return circle;
  }
  function matchEllipse() {
    var ellipse = match("shape", /^(ellipse)/i, 0);
    if (ellipse) {
      ellipse.style = matchDistance() || matchExtentKeyword();
    }
    return ellipse;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      var positioning = matchPositioning();
      if (!positioning) {
        error("Missing positioning value");
      }
      return positioning;
    }
  }
  function matchPositioning() {
    var location = matchCoordinates();
    if (location.x || location.y) {
      return {
        type: "position",
        value: location
      };
    }
  }
  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }
  function matchListing(matcher) {
    var captures = matcher(), result = [];
    if (captures) {
      result.push(captures);
      while (scan(tokens.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error("One extra comma");
        }
      }
    }
    return result;
  }
  function matchColorStop() {
    var color = matchColor();
    if (!color) {
      error("Expected color definition");
    }
    color.length = matchDistance();
    return color;
  }
  function matchColor() {
    return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
  }
  function matchLiteralColor() {
    return match("literal", tokens.literalColor, 0);
  }
  function matchHexColor() {
    return match("hex", tokens.hexColor, 1);
  }
  function matchRGBColor() {
    return matchCall(tokens.rgbColor, function() {
      return {
        type: "rgb",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchRGBAColor() {
    return matchCall(tokens.rgbaColor, function() {
      return {
        type: "rgba",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchNumber() {
    return scan(tokens.number)[1];
  }
  function matchDistance() {
    return match("%", tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
  }
  function matchPositionKeyword() {
    return match("position-keyword", tokens.positionKeywords, 1);
  }
  function matchLength() {
    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    var captures = scan(pattern);
    if (captures) {
      return {
        type,
        value: captures[captureIndex]
      };
    }
  }
  function scan(regexp) {
    var captures, blankCaptures;
    blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
      consume(blankCaptures[0].length);
    }
    captures = regexp.exec(input);
    if (captures) {
      consume(captures[0].length);
    }
    return captures;
  }
  function consume(size) {
    input = input.substr(size);
  }
  return function(code) {
    input = code.toString();
    return getAST();
  };
}();
var parse = GradientParser.parse;
GradientParser.stringify;

// node_modules/pixi-filters/lib/color-gradient/CssGradientParser.mjs
function parseCssGradient(cssGradient) {
  const cssGradientNodes = parse(trimCssGradient(cssGradient));
  if (cssGradientNodes.length === 0) {
    throw new Error("Invalid CSS gradient.");
  } else if (cssGradientNodes.length !== 1) {
    throw new Error("Unsupported CSS gradient (multiple gradients is not supported).");
  }
  const cssGradientNode = cssGradientNodes[0];
  const type = typeFromCssType(cssGradientNode.type);
  const stops = stopsFromCssStops(cssGradientNode.colorStops);
  const angle = angleFromCssOrientation(cssGradientNode.orientation);
  return {
    type,
    stops,
    angle
  };
}
function typeFromCssType(type) {
  const supportedTypes = {
    "linear-gradient": 0,
    "radial-gradient": 1
  };
  if (!(type in supportedTypes)) {
    throw new Error(`Unsupported gradient type "${type}"`);
  }
  return supportedTypes[type];
}
function stopsFromCssStops(stops) {
  const offsets = offsetsFromCssColorStops(stops);
  const result = [];
  const color = new Color();
  for (let i = 0; i < stops.length; i++) {
    const colorString = colorAsStringFromCssStop(stops[i]);
    const rgbaColor = color.setValue(colorString).toArray();
    result.push({
      offset: offsets[i],
      color: rgbaColor.slice(0, 3),
      alpha: rgbaColor[3]
    });
  }
  return result;
}
function colorAsStringFromCssStop(stop) {
  switch (stop.type) {
    case "hex":
      return `#${stop.value}`;
    case "literal":
      return stop.value;
    default:
      return `${stop.type}(${stop.value.join(",")})`;
  }
}
function offsetsFromCssColorStops(stops) {
  const offsets = [];
  const dynamicOffset = -1;
  for (let i = 0; i < stops.length; i++) {
    const cssStop = stops[i];
    let stopOffset = dynamicOffset;
    if (cssStop.type === "literal") {
      if (cssStop.length && "type" in cssStop.length && cssStop.length.type === "%" && "value" in cssStop.length) {
        stopOffset = parseFloat(cssStop.length.value) / 100;
      }
    }
    offsets.push(stopOffset);
  }
  const findNextFixedStop = (fromIndex) => {
    for (let k = fromIndex; k < offsets.length; k++) {
      if (offsets[k] !== dynamicOffset) {
        return {
          indexDelta: k - fromIndex,
          offset: offsets[k]
        };
      }
    }
    return {
      indexDelta: offsets.length - 1 - fromIndex,
      offset: 1
    };
  };
  let prevFixedOffset = 0;
  for (let i = 0; i < offsets.length; i++) {
    const offset = offsets[i];
    if (offset !== dynamicOffset) {
      prevFixedOffset = offset;
    } else if (i === 0) {
      offsets[i] = 0;
    } else if (i + 1 === offsets.length) {
      offsets[i] = 1;
    } else {
      const nextFixed = findNextFixedStop(i);
      const offsetDelta = nextFixed.offset - prevFixedOffset;
      const stepSize = offsetDelta / (1 + nextFixed.indexDelta);
      for (let s = 0; s <= nextFixed.indexDelta; s++) {
        offsets[i + s] = prevFixedOffset + (s + 1) * stepSize;
      }
      i += nextFixed.indexDelta;
      prevFixedOffset = offsets[i];
    }
  }
  return offsets.map(fixFloatRounding);
}
function fixFloatRounding(value) {
  const maxLength = 6;
  if (value.toString().length > maxLength) {
    return parseFloat(value.toString().substring(0, maxLength));
  }
  return value;
}
function angleFromCssOrientation(orientation) {
  if (typeof orientation === "undefined") {
    return 0;
  }
  if ("type" in orientation && "value" in orientation) {
    switch (orientation.type) {
      case "angular":
        return parseFloat(orientation.value);
      case "directional":
        return angleFromDirectionalValue(orientation.value);
    }
  }
  return 0;
}
function angleFromDirectionalValue(value) {
  const supportedValues = {
    left: 270,
    top: 0,
    bottom: 180,
    right: 90,
    "left top": 315,
    "top left": 315,
    "left bottom": 225,
    "bottom left": 225,
    "right top": 45,
    "top right": 45,
    "right bottom": 135,
    "bottom right": 135
  };
  if (!(value in supportedValues)) {
    throw new Error(`Unsupported directional value "${value}"`);
  }
  return supportedValues[value];
}
function trimCssGradient(value) {
  let value_ = value.replace(/\s{2,}/gu, " ");
  value_ = value_.replace(/;/g, "");
  value_ = value_.replace(/ ,/g, ",");
  value_ = value_.replace(/\( /g, "(");
  value_ = value_.replace(/ \)/g, ")");
  return value_.trim();
}

// node_modules/pixi-filters/lib/color-gradient/ColorGradientFilter.mjs
var __defProp10 = Object.defineProperty;
var __defNormalProp10 = (obj, key, value) => key in obj ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField10 = (obj, key, value) => {
  __defNormalProp10(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ANGLE_OFFSET = 90;
function sortColorStops(stops) {
  return [...stops].sort((a, b) => a.offset - b.offset);
}
var _ColorGradientFilter = class _ColorGradientFilter2 extends Filter {
  /**
   * @param options - Options for the ColorGradientFilter constructor.
   */
  constructor(options) {
    if (options && "css" in options) {
      options = {
        ...parseCssGradient(options.css || ""),
        alpha: options.alpha ?? _ColorGradientFilter2.defaults.alpha,
        maxColors: options.maxColors ?? _ColorGradientFilter2.defaults.maxColors
      };
    } else {
      options = { ..._ColorGradientFilter2.defaults, ...options };
    }
    if (!options.stops || options.stops.length < 2) {
      throw new Error("ColorGradientFilter requires at least 2 color stops.");
    }
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: source8,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source8,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex: vertex2,
      fragment: fragment9,
      name: "color-gradient-filter"
    });
    const maxStops = 32;
    super({
      gpuProgram,
      glProgram,
      resources: {
        baseUniforms: {
          uOptions: {
            value: [
              // Gradient Type
              options.type,
              // Gradient Angle
              options.angle ?? ANGLE_OFFSET,
              // Master Alpha
              options.alpha,
              // Replace Base Color
              options.replace ? 1 : 0
            ],
            type: "vec4<f32>"
          },
          uCounts: {
            value: [
              // Number of Stops
              options.stops.length,
              // Max Gradient Colors
              options.maxColors
            ],
            type: "vec2<f32>"
          }
        },
        stopsUniforms: {
          uColors: { value: new Float32Array(maxStops * 3), type: "vec3<f32>", size: maxStops },
          // We only need vec2, but we need to pad to eliminate the WGSL warning, TODO: @Mat ?
          uStops: { value: new Float32Array(maxStops * 4), type: "vec4<f32>", size: maxStops }
        }
      }
    });
    __publicField10(this, "baseUniforms");
    __publicField10(this, "stopsUniforms");
    __publicField10(this, "_stops", []);
    this.baseUniforms = this.resources.baseUniforms.uniforms;
    this.stopsUniforms = this.resources.stopsUniforms.uniforms;
    Object.assign(this, options);
  }
  get stops() {
    return this._stops;
  }
  set stops(stops) {
    const sortedStops = sortColorStops(stops);
    const color = new Color();
    let r;
    let g;
    let b;
    for (let i = 0; i < sortedStops.length; i++) {
      color.setValue(sortedStops[i].color);
      const indexStart = i * 3;
      [r, g, b] = color.toArray();
      this.stopsUniforms.uColors[indexStart] = r;
      this.stopsUniforms.uColors[indexStart + 1] = g;
      this.stopsUniforms.uColors[indexStart + 2] = b;
      this.stopsUniforms.uStops[i * 4] = sortedStops[i].offset;
      this.stopsUniforms.uStops[i * 4 + 1] = sortedStops[i].alpha;
    }
    this.baseUniforms.uCounts[0] = sortedStops.length;
    this._stops = sortedStops;
  }
  /**
  * The type of gradient
  * @default ColorGradientFilter.LINEAR
  */
  get type() {
    return this.baseUniforms.uOptions[0];
  }
  set type(value) {
    this.baseUniforms.uOptions[0] = value;
  }
  /**
  * The angle of the gradient in degrees
  * @default 90
  */
  get angle() {
    return this.baseUniforms.uOptions[1] + ANGLE_OFFSET;
  }
  set angle(value) {
    this.baseUniforms.uOptions[1] = value - ANGLE_OFFSET;
  }
  /**
  * The alpha value of the gradient (0-1)
  * @default 1
  */
  get alpha() {
    return this.baseUniforms.uOptions[2];
  }
  set alpha(value) {
    this.baseUniforms.uOptions[2] = value;
  }
  /**
  * The maximum number of colors to render (0 = no limit)
  * @default 0
  */
  get maxColors() {
    return this.baseUniforms.uCounts[1];
  }
  set maxColors(value) {
    this.baseUniforms.uCounts[1] = value;
  }
  /**
   * If true, the gradient will replace the existing color, otherwise it
   * will be multiplied with it
   * @default false
   */
  get replace() {
    return this.baseUniforms.uOptions[3] > 0.5;
  }
  set replace(value) {
    this.baseUniforms.uOptions[3] = value ? 1 : 0;
  }
};
__publicField10(_ColorGradientFilter, "LINEAR", 0);
__publicField10(_ColorGradientFilter, "RADIAL", 1);
__publicField10(_ColorGradientFilter, "CONIC", 2);
__publicField10(_ColorGradientFilter, "defaults", {
  type: _ColorGradientFilter.LINEAR,
  stops: [
    { offset: 0, color: 16711680, alpha: 1 },
    { offset: 1, color: 255, alpha: 1 }
  ],
  alpha: 1,
  angle: 90,
  maxColors: 0,
  replace: false
});
var ColorGradientFilter = _ColorGradientFilter;

// node_modules/pixi-filters/lib/color-map/color-map2.mjs
var fragment10 = "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\nuniform float uMix;\nuniform float uSize;\nuniform float uSliceSize;\nuniform float uSlicePixelSize;\nuniform float uSliceInnerSize;\n\nvoid main() {\n    vec4 color = texture(uTexture, vTextureCoord.xy);\n    vec4 adjusted;\n\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n        float innerWidth = uSize - 1.0;\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\n        float xOffset = uSlicePixelSize * 0.5 + color.r * uSliceInnerSize;\n        float s0 = xOffset + (zSlice0 * uSliceSize);\n        float s1 = xOffset + (zSlice1 * uSliceSize);\n        float yOffset = uSliceSize * 0.5 + color.g * (1.0 - uSliceSize);\n        vec4 slice0Color = texture(uMapTexture, vec2(s0,yOffset));\n        vec4 slice1Color = texture(uMapTexture, vec2(s1,yOffset));\n        float zOffset = fract(color.b * innerWidth);\n        adjusted = mix(slice0Color, slice1Color, zOffset);\n\n        color.rgb *= color.a;\n    }\n\n    finalColor = vec4(mix(color, adjusted, uMix).rgb, color.a);\n\n}";

// node_modules/pixi-filters/lib/color-map/color-map.mjs
var source9 = "struct ColorMapUniforms {\n  uMix: f32,\n  uSize: f32,\n  uSliceSize: f32,\n  uSlicePixelSize: f32,\n  uSliceInnerSize: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> colorMapUniforms : ColorMapUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n@group(1) @binding(2) var uMapSampler: sampler;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color:vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  var adjusted: vec4<f32>;\n\n  var altColor: vec4<f32> = vec4<f32>(color.rgb / color.a, color.a);\n  let innerWidth: f32 = colorMapUniforms.uSize - 1.0;\n  let zSlice0: f32 = min(floor(color.b * innerWidth), innerWidth);\n  let zSlice1: f32 = min(zSlice0 + 1.0, innerWidth);\n  let xOffset: f32 = colorMapUniforms.uSlicePixelSize * 0.5 + color.r * colorMapUniforms.uSliceInnerSize;\n  let s0: f32 = xOffset + (zSlice0 * colorMapUniforms.uSliceSize);\n  let s1: f32 = xOffset + (zSlice1 * colorMapUniforms.uSliceSize);\n  let yOffset: f32 = colorMapUniforms.uSliceSize * 0.5 + color.g * (1.0 - colorMapUniforms.uSliceSize);\n  let slice0Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s0,yOffset));\n  let slice1Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s1,yOffset));\n  let zOffset: f32 = fract(color.b * innerWidth);\n  adjusted = mix(slice0Color, slice1Color, zOffset);\n  altColor = vec4<f32>(color.rgb * color.a, color.a);\n\n  let realColor: vec4<f32> = select(color, altColor, color.a > 0.0);\n\n  return vec4<f32>(mix(realColor, adjusted, colorMapUniforms.uMix).rgb, realColor.a);\n}";

// node_modules/pixi-filters/lib/color-map/ColorMapFilter.mjs
var __defProp11 = Object.defineProperty;
var __defNormalProp11 = (obj, key, value) => key in obj ? __defProp11(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField11 = (obj, key, value) => {
  __defNormalProp11(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _ColorMapFilter = class _ColorMapFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (options instanceof Texture || options instanceof TextureSource) {
      deprecation("6.0.0", "ColorMapFilter constructor params are now options object. See params: { colorMap, nearest, mix }");
      options = { colorMap: options };
      if (args[1] !== void 0)
        options.nearest = args[1];
      if (args[2] !== void 0)
        options.mix = args[2];
    }
    options = { ..._ColorMapFilter2.DEFAULT_OPTIONS, ...options };
    if (!options.colorMap)
      throw Error("No color map texture source was provided to ColorMapFilter");
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source9,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment10,
      name: "color-map-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        colorMapUniforms: {
          uMix: { value: options.mix, type: "f32" },
          uSize: { value: 0, type: "f32" },
          uSliceSize: { value: 0, type: "f32" },
          uSlicePixelSize: { value: 0, type: "f32" },
          uSliceInnerSize: { value: 0, type: "f32" }
        },
        uMapTexture: options.colorMap.source,
        uMapSampler: options.colorMap.source.style
      }
    });
    __publicField11(this, "uniforms");
    __publicField11(this, "_size", 0);
    __publicField11(this, "_sliceSize", 0);
    __publicField11(this, "_slicePixelSize", 0);
    __publicField11(this, "_sliceInnerSize", 0);
    __publicField11(this, "_nearest", false);
    __publicField11(this, "_scaleMode", "linear");
    __publicField11(this, "_colorMap");
    this.uniforms = this.resources.colorMapUniforms.uniforms;
    Object.assign(this, options);
  }
  /** The mix from 0 to 1, where 0 is the original image and 1 is the color mapped image. */
  get mix() {
    return this.uniforms.uMix;
  }
  set mix(value) {
    this.uniforms.uMix = value;
  }
  /**
   * The size of one color slice.
   * @readonly
   */
  get colorSize() {
    return this._size;
  }
  /** The colorMap texture. */
  get colorMap() {
    return this._colorMap;
  }
  set colorMap(value) {
    if (!value || value === this.colorMap)
      return;
    const source210 = value instanceof Texture ? value.source : value;
    source210.style.scaleMode = this._scaleMode;
    source210.autoGenerateMipmaps = false;
    this._size = source210.height;
    this._sliceSize = 1 / this._size;
    this._slicePixelSize = this._sliceSize / this._size;
    this._sliceInnerSize = this._slicePixelSize * (this._size - 1);
    this.uniforms.uSize = this._size;
    this.uniforms.uSliceSize = this._sliceSize;
    this.uniforms.uSlicePixelSize = this._slicePixelSize;
    this.uniforms.uSliceInnerSize = this._sliceInnerSize;
    this.resources.uMapTexture = source210;
    this._colorMap = value;
  }
  /** Whether use NEAREST for colorMap texture. */
  get nearest() {
    return this._nearest;
  }
  set nearest(nearest) {
    this._nearest = nearest;
    this._scaleMode = nearest ? "nearest" : "linear";
    const texture = this._colorMap;
    if (texture && texture.source) {
      texture.source.scaleMode = this._scaleMode;
      texture.source.autoGenerateMipmaps = false;
      texture.source.style.update();
      texture.source.update();
    }
  }
  /**
   * If the colorMap is based on canvas,
   * and the content of canvas has changed, then call `updateColorMap` for update texture.
   */
  updateColorMap() {
    const texture = this._colorMap;
    if (texture == null ? void 0 : texture.source) {
      texture.source.update();
      this.colorMap = texture;
    }
  }
  /**
   * Destroys this filter
   * @default false
   */
  destroy() {
    var _a;
    (_a = this._colorMap) == null ? void 0 : _a.destroy();
    super.destroy();
  }
};
__publicField11(_ColorMapFilter, "DEFAULT_OPTIONS", {
  colorMap: Texture.WHITE,
  nearest: false,
  mix: 1
});
var ColorMapFilter = _ColorMapFilter;

// node_modules/pixi-filters/lib/color-overlay/color-overlay2.mjs
var fragment11 = "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec3 uColor;\nuniform float uAlpha;\n\nvoid main(void) {\n    vec4 c = texture(uTexture, vTextureCoord);\n    finalColor = vec4(mix(c.rgb, uColor * c.a, uAlpha), c.a);\n}";

// node_modules/pixi-filters/lib/color-overlay/color-overlay.mjs
var source10 = "struct ColorOverlayUniforms {\n    uColor: vec3<f32>,\n    uAlpha: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> colorOverlayUniforms : ColorOverlayUniforms;\n\n@fragment\nfn mainFragment(\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n    let c = textureSample(uTexture, uSampler, uv);\n    return vec4<f32>(mix(c.rgb, colorOverlayUniforms.uColor.rgb * c.a, colorOverlayUniforms.uAlpha), c.a);\n}\n";

// node_modules/pixi-filters/lib/color-overlay/ColorOverlayFilter.mjs
var __defProp12 = Object.defineProperty;
var __defNormalProp12 = (obj, key, value) => key in obj ? __defProp12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField12 = (obj, key, value) => {
  __defNormalProp12(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _ColorOverlayFilter = class _ColorOverlayFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (typeof options === "number" || Array.isArray(options) || options instanceof Float32Array) {
      deprecation("6.0.0", "ColorOverlayFilter constructor params are now options object. See params: { color, alpha }");
      options = { color: options };
      if (args[1] !== void 0)
        options.alpha = args[1];
    }
    options = { ..._ColorOverlayFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source10,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment11,
      name: "color-overlay-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        colorOverlayUniforms: {
          uColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uAlpha: { value: options.alpha, type: "f32" }
        }
      }
    });
    __publicField12(this, "uniforms");
    __publicField12(this, "_color");
    this.uniforms = this.resources.colorOverlayUniforms.uniforms;
    this._color = new Color();
    this.color = options.color ?? 0;
  }
  /**
   * The over color source
   * @member {number|Array<number>|Float32Array}
   * @default 0x000000
   */
  get color() {
    return this._color.value;
  }
  set color(value) {
    this._color.setValue(value);
    const [r, g, b] = this._color.toArray();
    this.uniforms.uColor[0] = r;
    this.uniforms.uColor[1] = g;
    this.uniforms.uColor[2] = b;
  }
  /**
   * The alpha value of the color
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
};
__publicField12(_ColorOverlayFilter, "DEFAULT_OPTIONS", {
  /** The color of the overlay */
  color: 0,
  /** The alpha of the overlay */
  alpha: 1
});
var ColorOverlayFilter = _ColorOverlayFilter;

// node_modules/pixi-filters/lib/color-replace/color-replace.mjs
var fragment12 = "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec3 uOriginalColor;\nuniform vec3 uTargetColor;\nuniform float uTolerance;\n\nvoid main(void) {\n    vec4 c = texture(uTexture, vTextureCoord);\n    vec3 colorDiff = uOriginalColor - (c.rgb / max(c.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    float doReplace = step(colorDistance, uTolerance);\n    finalColor = vec4(mix(c.rgb, (uTargetColor + colorDiff) * c.a, doReplace), c.a);\n}\n";

// node_modules/pixi-filters/lib/color-replace/color-replace2.mjs
var source11 = "struct ColorReplaceUniforms {\n  uOriginalColor: vec3<f32>,\n  uTargetColor: vec3<f32>,\n  uTolerance: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> colorReplaceUniforms : ColorReplaceUniforms;\n\n@fragment\nfn mainFragment(\n   @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let sample: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  let colorDiff: vec3<f32> = colorReplaceUniforms.uOriginalColor - (sample.rgb / max(sample.a, 0.0000000001));\n  let colorDistance: f32 = length(colorDiff);\n  let doReplace: f32 = step(colorDistance, colorReplaceUniforms.uTolerance);\n\n  return vec4<f32>(mix(sample.rgb, (colorReplaceUniforms.uTargetColor + colorDiff) * sample.a, doReplace), sample.a);\n}";

// node_modules/pixi-filters/lib/color-replace/ColorReplaceFilter.mjs
var __defProp13 = Object.defineProperty;
var __defNormalProp13 = (obj, key, value) => key in obj ? __defProp13(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField13 = (obj, key, value) => {
  __defNormalProp13(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _ColorReplaceFilter = class _ColorReplaceFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (typeof options === "number" || Array.isArray(options) || options instanceof Float32Array) {
      deprecation("6.0.0", "ColorReplaceFilter constructor params are now options object. See params: { originalColor, targetColor, tolerance }");
      options = { originalColor: options };
      if (args[1] !== void 0)
        options.targetColor = args[1];
      if (args[2] !== void 0)
        options.tolerance = args[2];
    }
    options = { ..._ColorReplaceFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source11,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment12,
      name: "color-replace-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        colorReplaceUniforms: {
          uOriginalColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uTargetColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uTolerance: { value: options.tolerance, type: "f32" }
        }
      }
    });
    __publicField13(this, "uniforms");
    __publicField13(this, "_originalColor");
    __publicField13(this, "_targetColor");
    this.uniforms = this.resources.colorReplaceUniforms.uniforms;
    this._originalColor = new Color();
    this._targetColor = new Color();
    this.originalColor = options.originalColor ?? 16711680;
    this.targetColor = options.targetColor ?? 0;
    Object.assign(this, options);
  }
  /**
   * The color that will be changed.
   * @example [1.0, 1.0, 1.0] = 0xffffff
   * @default 0xff0000
   */
  get originalColor() {
    return this._originalColor.value;
  }
  set originalColor(value) {
    this._originalColor.setValue(value);
    const [r, g, b] = this._originalColor.toArray();
    this.uniforms.uOriginalColor[0] = r;
    this.uniforms.uOriginalColor[1] = g;
    this.uniforms.uOriginalColor[2] = b;
  }
  /**
    * The resulting color.
    * @example [1.0, 1.0, 1.0] = 0xffffff
    * @default 0x000000
    */
  get targetColor() {
    return this._targetColor.value;
  }
  set targetColor(value) {
    this._targetColor.setValue(value);
    const [r, g, b] = this._targetColor.toArray();
    this.uniforms.uTargetColor[0] = r;
    this.uniforms.uTargetColor[1] = g;
    this.uniforms.uTargetColor[2] = b;
  }
  /**
    * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)
    * @default 0.4
    */
  get tolerance() {
    return this.uniforms.uTolerance;
  }
  set tolerance(value) {
    this.uniforms.uTolerance = value;
  }
  /**
   * @deprecated since 6.0.0
   *
   * The resulting color, as a 3 component RGB e.g. [1.0, 0.5, 1.0]
   * @member {number|Array<number>|Float32Array}
   * @default 0x000000
   * @see ColorReplaceFilter#targetColor
   */
  set newColor(value) {
    deprecation("6.0.0", "ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead");
    this.targetColor = value;
  }
  get newColor() {
    deprecation("6.0.0", "ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead");
    return this.targetColor;
  }
  /**
   * @deprecated since 6.0.0
   *
   * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)
   * @default 0.4
   * @see ColorReplaceFilter#tolerance
   */
  set epsilon(value) {
    deprecation("6.0.0", "ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead");
    this.tolerance = value;
  }
  get epsilon() {
    deprecation("6.0.0", "ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead");
    return this.tolerance;
  }
};
__publicField13(_ColorReplaceFilter, "DEFAULT_OPTIONS", {
  originalColor: 16711680,
  targetColor: 0,
  tolerance: 0.4
});
var ColorReplaceFilter = _ColorReplaceFilter;

// node_modules/pixi-filters/lib/convolution/convolution.mjs
var fragment13 = "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uTexelSize;\nuniform mat3 uMatrix;\n\nvoid main(void)\n{\n    vec4 c11 = texture(uTexture, vTextureCoord - uTexelSize); // top left\n    vec4 c12 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y - uTexelSize.y)); // top center\n    vec4 c13 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y - uTexelSize.y)); // top right\n\n    vec4 c21 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y)); // mid left\n    vec4 c22 = texture(uTexture, vTextureCoord); // mid center\n    vec4 c23 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y)); // mid right\n\n    vec4 c31 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y + uTexelSize.y)); // bottom left\n    vec4 c32 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y + uTexelSize.y)); // bottom center\n    vec4 c33 = texture(uTexture, vTextureCoord + uTexelSize); // bottom right\n\n    finalColor =\n        c11 * uMatrix[0][0] + c12 * uMatrix[0][1] + c13 * uMatrix[0][2] +\n        c21 * uMatrix[1][0] + c22 * uMatrix[1][1] + c23 * uMatrix[1][2] +\n        c31 * uMatrix[2][0] + c32 * uMatrix[2][1] + c33 * uMatrix[2][2];\n\n    finalColor.a = c22.a;\n}";

// node_modules/pixi-filters/lib/convolution/convolution2.mjs
var source12 = "struct ConvolutionUniforms {\n    uMatrix: mat3x3<f32>,\n    uTexelSize: vec2<f32>,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> convolutionUniforms : ConvolutionUniforms;\n\n@fragment\nfn mainFragment(\n    @location(0) uv: vec2<f32>,\n    @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n    let texelSize = convolutionUniforms.uTexelSize;\n    let matrix = convolutionUniforms.uMatrix;\n\n    let c11: vec4<f32> = textureSample(uTexture, uSampler, uv - texelSize); // top left\n    let c12: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y - texelSize.y)); // top center\n    let c13: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y - texelSize.y)); // top right\n\n    let c21: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y)); // mid left\n    let c22: vec4<f32> = textureSample(uTexture, uSampler, uv); // mid center\n    let c23: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y)); // mid right\n\n    let c31: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y + texelSize.y)); // bottom left\n    let c32: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y + texelSize.y)); // bottom center\n    let c33: vec4<f32> = textureSample(uTexture, uSampler, uv + texelSize); // bottom right\n\n    var finalColor: vec4<f32> = vec4<f32>(\n        c11 * matrix[0][0] + c12 * matrix[0][1] + c13 * matrix[0][2] +\n        c21 * matrix[1][0] + c22 * matrix[1][1] + c23 * matrix[1][2] +\n        c31 * matrix[2][0] + c32 * matrix[2][1] + c33 * matrix[2][2]\n    );\n\n    finalColor.a = c22.a;\n\n    return finalColor;\n}";

// node_modules/pixi-filters/lib/convolution/ConvolutionFilter.mjs
var __defProp14 = Object.defineProperty;
var __defNormalProp14 = (obj, key, value) => key in obj ? __defProp14(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField14 = (obj, key, value) => {
  __defNormalProp14(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _ConvolutionFilter = class _ConvolutionFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (Array.isArray(options)) {
      deprecation("6.0.0", "ConvolutionFilter constructor params are now options object. See params: { matrix, width, height }");
      options = { matrix: options };
      if (args[1] !== void 0)
        options.width = args[1];
      if (args[2] !== void 0)
        options.height = args[2];
    }
    options = { ..._ConvolutionFilter2.DEFAULT_OPTIONS, ...options };
    const width = options.width ?? 200;
    const height = options.height ?? 200;
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source12,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment13,
      name: "convolution-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        convolutionUniforms: {
          uMatrix: { value: options.matrix, type: "mat3x3<f32>" },
          uTexelSize: { value: { x: 1 / width, y: 1 / height }, type: "vec2<f32>" }
        }
      }
    });
    __publicField14(this, "uniforms");
    this.uniforms = this.resources.convolutionUniforms.uniforms;
    this.width = width;
    this.height = height;
  }
  /**
   * An array of values used for matrix transformation, specified as a 9 point Array
   * @example
   * const matrix = new Float32Array(9); // 9 elements of value 0
   * const matrix = [0,0.5,0,0.5,1,0.5,0,0.5,0];
   * @default [0,0,0,0,0,0,0,0,0]
   */
  get matrix() {
    return this.uniforms.uMatrix;
  }
  set matrix(matrix) {
    matrix.forEach((v, i) => {
      this.uniforms.uMatrix[i] = v;
    });
  }
  /**
   * Width of the object you are transforming
   * @default 200
   */
  get width() {
    return 1 / this.uniforms.uTexelSize.x;
  }
  set width(value) {
    this.uniforms.uTexelSize.x = 1 / value;
  }
  /**
   * Height of the object you are transforming
   * @default 200
   */
  get height() {
    return 1 / this.uniforms.uTexelSize.y;
  }
  set height(value) {
    this.uniforms.uTexelSize.y = 1 / value;
  }
};
__publicField14(_ConvolutionFilter, "DEFAULT_OPTIONS", {
  matrix: new Float32Array(9),
  width: 200,
  height: 200
});
var ConvolutionFilter = _ConvolutionFilter;

// node_modules/pixi-filters/lib/cross-hatch/crosshatch.mjs
var fragment14 = "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void)\n{\n    float lum = length(texture(uTexture, vTextureCoord.xy).rgb);\n\n    finalColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n";

// node_modules/pixi-filters/lib/cross-hatch/crosshatch2.mjs
var source13 = "@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n\n@fragment\nfn mainFragment(\n    @location(0) uv: vec2<f32>,\n    @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n    let lum: f32 = length(textureSample(uTexture, uSampler, uv).rgb);\n\n    if (lum < 1.00)\n    {\n        if (modulo(position.x + position.y, 10.0) == 0.0)\n        {\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (modulo(position.x - position.y, 10.0) == 0.0)\n        {\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (modulo(position.x + position.y - 5.0, 10.0) == 0.0)\n        {\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (modulo(position.x - position.y - 5.0, 10.0) == 0.0)\n        {\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    return vec4<f32>(1.0);\n}\n\nfn modulo(x: f32, y: f32) -> f32\n{\n  return x - y * floor(x/y);\n}";

// node_modules/pixi-filters/lib/cross-hatch/CrossHatchFilter.mjs
var CrossHatchFilter = class extends Filter {
  constructor() {
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source13,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment14,
      name: "cross-hatch-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {}
    });
  }
};

// node_modules/pixi-filters/lib/crt/crt2.mjs
var fragment15 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec4 uLine;\nuniform vec2 uNoise;\nuniform vec3 uVignette;\nuniform float uSeed;\nuniform float uTime;\nuniform vec2 uDimensions;\n\nuniform vec4 uInputSize;\n\nconst float SQRT_2 = 1.414213;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat vignette(vec3 co, vec2 coord)\n{\n    float outter = SQRT_2 - uVignette[0] * SQRT_2;\n    vec2 dir = vec2(0.5) - coord;\n    dir.y *= uDimensions.y / uDimensions.x;\n    float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);\n    return darker + (1.0 - darker) * (1.0 - uVignette[1]);\n}\n\nfloat noise(vec2 coord)\n{\n    vec2 pixelCoord = coord * uInputSize.xy;\n    pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\n    pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\n    return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\n}\n\nvec3 interlaceLines(vec3 co, vec2 coord)\n{\n    vec3 color = co;\n\n    float curvature = uLine[0];\n    float lineWidth = uLine[1];\n    float lineContrast = uLine[2];\n    float verticalLine = uLine[3];\n\n    vec2 dir = vec2(coord * uInputSize.xy / uDimensions - 0.5);\n\n    float _c = curvature > 0. ? curvature : 1.;\n    float k = curvature > 0. ? (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n    vec2 uv = dir * k;\n    float v = verticalLine > 0.5 ? uv.x * uDimensions.x : uv.y * uDimensions.y;\n    v *= min(1.0, 2.0 / lineWidth ) / _c;\n    float j = 1. + cos(v * 1.2 - uTime) * 0.5 * lineContrast;\n    color *= j;\n\n    float segment = verticalLine > 0.5 ? mod((dir.x + .5) * uDimensions.x, 4.) : mod((dir.y + .5) * uDimensions.y, 4.);\n    color *= 0.99 + ceil(segment) * 0.015;\n\n    return color;\n}\n\nvoid main(void)\n{\n    finalColor = texture(uTexture, vTextureCoord);\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;\n\n    if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\n    {\n        float n = noise(vTextureCoord);\n        finalColor += vec4(n, n, n, finalColor.a);\n    }\n\n    if (uVignette[0] > 0.)\n    {\n        float v = vignette(finalColor.rgb, coord);\n        finalColor *= vec4(v, v, v, finalColor.a);\n    }\n\n    if (uLine[1] > 0.0)\n    {\n        finalColor = vec4(interlaceLines(finalColor.rgb, vTextureCoord), finalColor.a);  \n    }\n}\n";

// node_modules/pixi-filters/lib/crt/crt.mjs
var source14 = "struct CRTUniforms {\n    uLine: vec4<f32>,\n    uNoise: vec2<f32>,\n    uVignette: vec3<f32>,\n    uSeed: f32,\n    uTime: f32,\n    uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> crtUniforms : CRTUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n    \n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / crtUniforms.uDimensions;\n\n  let uNoise = crtUniforms.uNoise;\n\n  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\n  {\n    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);\n  }\n\n  if (crtUniforms.uVignette[0] > 0.)\n  {\n    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);\n  }\n\n  if (crtUniforms.uLine[1] > 0.0)\n  {\n    color = vec4<f32>(vec3<f32>(interlaceLines(color.rgb, uv)), color.a);  \n  }\n\n  return color;\n}\n\nconst SQRT_2: f32 = 1.414213;\n\nfn modulo(x: f32, y: f32) -> f32\n{\n  return x - y * floor(x/y);\n}\n\nfn rand(co: vec2<f32>) -> f32\n{\n  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\n}\n\nfn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32\n{\n  let uVignette = crtUniforms.uVignette;\n  let uDimensions = crtUniforms.uDimensions;\n  \n  let outter: f32 = SQRT_2 - uVignette[0] * SQRT_2;\n  var dir: vec2<f32> = vec2<f32>(0.5) - coord;\n  dir.y *= uDimensions.y / uDimensions.x;\n  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);\n  return darker + (1.0 - darker) * (1.0 - uVignette[1]);\n}\n\nfn noise(coord: vec2<f32>) -> f32\n{\n  let uNoise = crtUniforms.uNoise;\n  let uSeed = crtUniforms.uSeed;\n\n  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;\n  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\n  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\n  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\n}\n\nfn interlaceLines(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>\n{\n  var color = co;\n\n  let uDimensions = crtUniforms.uDimensions;\n\n  let curvature: f32 = crtUniforms.uLine[0];\n  let lineWidth: f32 = crtUniforms.uLine[1];\n  let lineContrast: f32 = crtUniforms.uLine[2];\n  let verticalLine: f32 = crtUniforms.uLine[3];\n\n  let dir: vec2<f32> = vec2<f32>(coord * gfu.uInputSize.xy / uDimensions - 0.5);\n\n  let _c: f32 = select(1., curvature, curvature > 0.);\n  let k: f32 = select(1., (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c), curvature > 0.);\n  let uv: vec2<f32> = dir * k;\n  let v: f32 = select(uv.y * uDimensions.y, uv.x * uDimensions.x, verticalLine > 0.5) * min(1.0, 2.0 / lineWidth ) / _c;\n  let j: f32 = 1. + cos(v * 1.2 - crtUniforms.uTime) * 0.5 * lineContrast;\n  color *= j;\n\n  let segment: f32 = select(modulo((dir.y + .5) * uDimensions.y, 4.), modulo((dir.x + .5) * uDimensions.x, 4.), verticalLine > 0.5);\n  color *= 0.99 + ceil(segment) * 0.015;\n\n  return color;\n}";

// node_modules/pixi-filters/lib/crt/CRTFilter.mjs
var __defProp15 = Object.defineProperty;
var __defNormalProp15 = (obj, key, value) => key in obj ? __defProp15(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField15 = (obj, key, value) => {
  __defNormalProp15(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _CRTFilter = class _CRTFilter2 extends Filter {
  /**
   * @param options - Options for the CRTFilter constructor.
   */
  constructor(options) {
    options = { ..._CRTFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source14,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment15,
      name: "crt-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        crtUniforms: {
          uLine: { value: new Float32Array(4), type: "vec4<f32>" },
          uNoise: { value: new Float32Array(2), type: "vec2<f32>" },
          uVignette: { value: new Float32Array(3), type: "vec3<f32>" },
          uSeed: { value: options.seed, type: "f32" },
          uTime: { value: options.time, type: "f32" },
          uDimensions: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    });
    __publicField15(this, "uniforms");
    __publicField15(this, "seed");
    __publicField15(this, "time");
    this.uniforms = this.resources.crtUniforms.uniforms;
    Object.assign(this, options);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    this.uniforms.uDimensions[0] = input.frame.width;
    this.uniforms.uDimensions[1] = input.frame.height;
    this.uniforms.uSeed = this.seed;
    this.uniforms.uTime = this.time;
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * Bend of interlaced lines, higher value means more bend
   * @default 1
   */
  get curvature() {
    return this.uniforms.uLine[0];
  }
  set curvature(value) {
    this.uniforms.uLine[0] = value;
  }
  /**
   * Width of interlaced lines
   * @default 1
   */
  get lineWidth() {
    return this.uniforms.uLine[1];
  }
  set lineWidth(value) {
    this.uniforms.uLine[1] = value;
  }
  /**
   * Contrast of interlaced lines
   * @default 0.25
   */
  get lineContrast() {
    return this.uniforms.uLine[2];
  }
  set lineContrast(value) {
    this.uniforms.uLine[2] = value;
  }
  /**
   * The orientation of the line:
   *
   * `true` create vertical lines, `false` creates horizontal lines
   * @default false
   */
  get verticalLine() {
    return this.uniforms.uLine[3] > 0.5;
  }
  set verticalLine(value) {
    this.uniforms.uLine[3] = value ? 1 : 0;
  }
  /**
   * Opacity/intensity of the noise effect between `0` and `1`
   * @default 0.3
   */
  get noise() {
    return this.uniforms.uNoise[0];
  }
  set noise(value) {
    this.uniforms.uNoise[0] = value;
  }
  /**
   * The size of the noise particles
   * @default 0
   */
  get noiseSize() {
    return this.uniforms.uNoise[1];
  }
  set noiseSize(value) {
    this.uniforms.uNoise[1] = value;
  }
  /**
   * The radius of the vignette effect, smaller values produces a smaller vignette
   * @default 0.3
   */
  get vignetting() {
    return this.uniforms.uVignette[0];
  }
  set vignetting(value) {
    this.uniforms.uVignette[0] = value;
  }
  /**
   * Amount of opacity of vignette
   * @default 1
   */
  get vignettingAlpha() {
    return this.uniforms.uVignette[1];
  }
  set vignettingAlpha(value) {
    this.uniforms.uVignette[1] = value;
  }
  /**
   * Blur intensity of the vignette
   * @default 0.3
   */
  get vignettingBlur() {
    return this.uniforms.uVignette[2];
  }
  set vignettingBlur(value) {
    this.uniforms.uVignette[2] = value;
  }
};
__publicField15(_CRTFilter, "DEFAULT_OPTIONS", {
  curvature: 1,
  lineWidth: 1,
  lineContrast: 0.25,
  verticalLine: false,
  noise: 0,
  noiseSize: 1,
  vignetting: 0.3,
  vignettingAlpha: 1,
  vignettingBlur: 0.3,
  time: 0,
  seed: 0
});
var CRTFilter = _CRTFilter;

// node_modules/pixi-filters/lib/dot/dot.mjs
var fragment16 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uAngle;\nuniform float uScale;\nuniform bool uGrayScale;\n\nuniform vec4 uInputSize;\n\nfloat pattern()\n{\n    float s = sin(uAngle), c = cos(uAngle);\n    vec2 tex = vTextureCoord * uInputSize.xy;\n    vec2 point = vec2(\n        c * tex.x - s * tex.y,\n        s * tex.x + c * tex.y\n    ) * uScale;\n    return (sin(point.x) * sin(point.y)) * 4.0;\n    }\n\n    void main()\n    {\n    vec4 color = texture(uTexture, vTextureCoord);\n    vec3 colorRGB = vec3(color);\n\n    if (uGrayScale)\n    {\n        colorRGB = vec3(color.r + color.g + color.b) / 3.0;\n    }\n\n    finalColor = vec4(colorRGB * 10.0 - 5.0 + pattern(), color.a);\n}\n";

// node_modules/pixi-filters/lib/dot/dot2.mjs
var source15 = "struct DotUniforms {\n  uScale:f32,\n  uAngle:f32,\n  uGrayScale:f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> dotUniforms : DotUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let gray: vec3<f32> = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)));\n  // dotUniforms.uGrayScale == 1 doesn't ever pass so it is converted to a float and compared to 0.5 instead \n  let finalColor: vec3<f32> = select(color.rgb, gray, f32(dotUniforms.uGrayScale) >= 0.5);\n\n  return vec4<f32>(finalColor * 10.0 - 5.0 + pattern(uv), color.a);\n}\n\nfn pattern(uv: vec2<f32>) -> f32\n{\n  let s: f32 = sin(dotUniforms.uAngle);\n  let c: f32 = cos(dotUniforms.uAngle);\n  \n  let tex: vec2<f32> = uv * gfu.uInputSize.xy;\n  \n  let p: vec2<f32> = vec2<f32>(\n      c * tex.x - s * tex.y,\n      s * tex.x + c * tex.y\n  ) * dotUniforms.uScale;\n\n  return (sin(p.x) * sin(p.y)) * 4.0;\n}";

// node_modules/pixi-filters/lib/dot/DotFilter.mjs
var __defProp16 = Object.defineProperty;
var __defNormalProp16 = (obj, key, value) => key in obj ? __defProp16(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField16 = (obj, key, value) => {
  __defNormalProp16(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _DotFilter = class _DotFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (typeof options === "number") {
      deprecation("6.0.0", "DotFilter constructor params are now options object. See params: { scale, angle, grayscale }");
      options = { scale: options };
      if (args[1] !== void 0)
        options.angle = args[1];
      if (args[2] !== void 0)
        options.grayscale = args[2];
    }
    options = { ..._DotFilter2.DEFAULT_OPTIONS, ...options };
    const dotUniforms = {
      uScale: { value: options.scale, type: "f32" },
      uAngle: { value: options.angle, type: "f32" },
      uGrayScale: { value: options.grayscale ? 1 : 0, type: "f32" }
    };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source15,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment16,
      name: "dot-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        dotUniforms
      }
    });
  }
  /**
   * The scale of the effect.
   * @default 1
   */
  get scale() {
    return this.resources.dotUniforms.uniforms.uScale;
  }
  set scale(value) {
    this.resources.dotUniforms.uniforms.uScale = value;
  }
  /**
  * The radius of the effect.
  * @default 5
  */
  get angle() {
    return this.resources.dotUniforms.uniforms.uAngle;
  }
  set angle(value) {
    this.resources.dotUniforms.uniforms.uAngle = value;
  }
  /**
  * Whether to rendering it in gray scale.
  * @default true
  */
  get grayscale() {
    return this.resources.dotUniforms.uniforms.uGrayScale === 1;
  }
  set grayscale(value) {
    this.resources.dotUniforms.uniforms.uGrayScale = value ? 1 : 0;
  }
};
__publicField16(_DotFilter, "DEFAULT_OPTIONS", {
  scale: 1,
  angle: 5,
  grayscale: true
});
var DotFilter = _DotFilter;

// node_modules/pixi-filters/lib/drop-shadow/drop-shadow.mjs
var fragment17 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uAlpha;\nuniform vec3 uColor;\nuniform vec2 uOffset;\n\nuniform vec4 uInputSize;\n\nvoid main(void){\n    vec4 sample = texture(uTexture, vTextureCoord - uOffset * uInputSize.zw);\n\n    // Premultiply alpha\n    sample.rgb = uColor.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= uAlpha;\n\n    finalColor = sample;\n}";

// node_modules/pixi-filters/lib/drop-shadow/drop-shadow2.mjs
var source16 = "struct DropShadowUniforms {\n  uAlpha: f32,\n  uColor: vec3<f32>,\n  uOffset: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> dropShadowUniforms : DropShadowUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv - dropShadowUniforms.uOffset * gfu.uInputSize.zw);\n\n  // Premultiply alpha\n  color = vec4<f32>(vec3<f32>(dropShadowUniforms.uColor.rgb * color.a), color.a);\n  // alpha user alpha\n  color *= dropShadowUniforms.uAlpha;\n\n  return color;\n}";

// node_modules/pixi-filters/lib/drop-shadow/DropShadowFilter.mjs
var __defProp17 = Object.defineProperty;
var __defNormalProp17 = (obj, key, value) => key in obj ? __defProp17(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField17 = (obj, key, value) => {
  __defNormalProp17(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _DropShadowFilter = class _DropShadowFilter2 extends Filter {
  /**
   * @param options - Options for the DropShadowFilter constructor.
   */
  constructor(options) {
    options = { ..._DropShadowFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source16,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment17,
      name: "drop-shadow-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        dropShadowUniforms: {
          uAlpha: { value: options.alpha, type: "f32" },
          uColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uOffset: { value: options.offset, type: "vec2<f32>" }
        }
      },
      resolution: options.resolution
    });
    __publicField17(this, "uniforms");
    __publicField17(this, "shadowOnly", false);
    __publicField17(this, "_color");
    __publicField17(this, "_blurFilter");
    __publicField17(this, "_basePass");
    this.uniforms = this.resources.dropShadowUniforms.uniforms;
    this._color = new Color();
    this.color = options.color ?? 0;
    this._blurFilter = new KawaseBlurFilter({
      strength: options.kernels ?? options.blur,
      quality: options.kernels ? void 0 : options.quality
    });
    this._basePass = new Filter({
      gpuProgram: GpuProgram.from({
        vertex: {
          source: wgslVertex,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: `
                    @group(0) @binding(1) var uTexture: texture_2d<f32>; 
                    @group(0) @binding(2) var uSampler: sampler;
                    @fragment
                    fn mainFragment(
                        @builtin(position) position: vec4<f32>,
                        @location(0) uv : vec2<f32>
                    ) -> @location(0) vec4<f32> {
                        return textureSample(uTexture, uSampler, uv);
                    }
                    `,
          entryPoint: "mainFragment"
        }
      }),
      glProgram: GlProgram.from({
        vertex,
        fragment: `
                in vec2 vTextureCoord;
                out vec4 finalColor;
                uniform sampler2D uTexture;

                void main(void){
                    finalColor = texture(uTexture, vTextureCoord);
                }
                `,
        name: "drop-shadow-filter"
      }),
      resources: {}
    });
    Object.assign(this, options);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    const renderTarget = TexturePool.getSameSizeTexture(input);
    filterManager.applyFilter(this, input, renderTarget, true);
    this._blurFilter.apply(filterManager, renderTarget, output, clearMode);
    if (!this.shadowOnly) {
      filterManager.applyFilter(this._basePass, input, output, false);
    }
    TexturePool.returnTexture(renderTarget);
  }
  /**
   * Set the offset position of the drop-shadow relative to the original image.
   * @default [4,4]
   */
  get offset() {
    return this.uniforms.uOffset;
  }
  set offset(value) {
    this.uniforms.uOffset = value;
    this._updatePadding();
  }
  /**
   * Set the offset position of the drop-shadow relative to the original image on the `x` axis
   * @default 4
   */
  get offsetX() {
    return this.offset.x;
  }
  set offsetX(value) {
    this.offset.x = value;
    this._updatePadding();
  }
  /**
   * Set the offset position of the drop-shadow relative to the original image on the `y` axis
   * @default 4
   */
  get offsetY() {
    return this.offset.y;
  }
  set offsetY(value) {
    this.offset.y = value;
    this._updatePadding();
  }
  /**
   * The color value of shadow.
   * @example [0.0, 0.0, 0.0] = 0x000000
   * @default 0x000000
   */
  get color() {
    return this._color.value;
  }
  set color(value) {
    this._color.setValue(value);
    const [r, g, b] = this._color.toArray();
    this.uniforms.uColor[0] = r;
    this.uniforms.uColor[1] = g;
    this.uniforms.uColor[2] = b;
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
  /**
   * The strength of the shadow's blur.
   * @default 2
   */
  get blur() {
    return this._blurFilter.strength;
  }
  set blur(value) {
    this._blurFilter.strength = value;
    this._updatePadding();
  }
  /**
   * Sets the quality of the Blur Filter
   * @default 4
   */
  get quality() {
    return this._blurFilter.quality;
  }
  set quality(value) {
    this._blurFilter.quality = value;
    this._updatePadding();
  }
  /** Sets the kernels of the Blur Filter */
  get kernels() {
    return this._blurFilter.kernels;
  }
  set kernels(value) {
    this._blurFilter.kernels = value;
  }
  /**
   * Sets the pixelSize of the Kawase Blur filter
   * @default [1,1]
   */
  get pixelSize() {
    return this._blurFilter.pixelSize;
  }
  set pixelSize(value) {
    if (typeof value === "number") {
      value = { x: value, y: value };
    }
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this._blurFilter.pixelSize = value;
  }
  /**
   * Sets the pixelSize of the Kawase Blur filter on the `x` axis
   * @default 1
   */
  get pixelSizeX() {
    return this._blurFilter.pixelSizeX;
  }
  set pixelSizeX(value) {
    this._blurFilter.pixelSizeX = value;
  }
  /**
   * Sets the pixelSize of the Kawase Blur filter on the `y` axis
   * @default 1
   */
  get pixelSizeY() {
    return this._blurFilter.pixelSizeY;
  }
  set pixelSizeY(value) {
    this._blurFilter.pixelSizeY = value;
  }
  /**
   * Recalculate the proper padding amount.
   * @private
   */
  _updatePadding() {
    const offsetPadding = Math.max(
      Math.abs(this.offsetX),
      Math.abs(this.offsetY)
    );
    this.padding = offsetPadding + this.blur * 2 + this.quality * 4;
  }
};
__publicField17(_DropShadowFilter, "DEFAULT_OPTIONS", {
  offset: { x: 4, y: 4 },
  color: 0,
  alpha: 0.5,
  shadowOnly: false,
  kernels: void 0,
  blur: 2,
  quality: 3,
  pixelSize: { x: 1, y: 1 },
  resolution: 1
});
var DropShadowFilter = _DropShadowFilter;

// node_modules/pixi-filters/lib/emboss/emboss2.mjs
var fragment18 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uStrength;\n\nuniform vec4 uInputSize;\n\nvoid main(void)\n{\n	vec2 onePixel = vec2(1.0 / uInputSize);\n\n	vec4 color;\n\n	color.rgb = vec3(0.5);\n\n	color -= texture(uTexture, vTextureCoord - onePixel) * uStrength;\n	color += texture(uTexture, vTextureCoord + onePixel) * uStrength;\n\n	color.rgb = vec3((color.r + color.g + color.b) / 3.0);\n\n	float alpha = texture(uTexture, vTextureCoord).a;\n\n	finalColor = vec4(color.rgb * alpha, alpha);\n}\n";

// node_modules/pixi-filters/lib/emboss/emboss.mjs
var source17 = "struct EmbossUniforms {\n  uStrength:f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> embossUniforms : EmbossUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let onePixel: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\n	var color: vec3<f32> = vec3<f32>(0.5);\n\n	color -= (textureSample(uTexture, uSampler, uv - onePixel) * embossUniforms.uStrength).rgb;\n	color += (textureSample(uTexture, uSampler, uv + onePixel) * embossUniforms.uStrength).rgb;\n\n	color = vec3<f32>((color.r + color.g + color.b) / 3.0);\n\n	let blendColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n	return vec4<f32>(color.rgb * blendColor.a, blendColor.a);\n}";

// node_modules/pixi-filters/lib/emboss/EmbossFilter.mjs
var __defProp18 = Object.defineProperty;
var __defNormalProp18 = (obj, key, value) => key in obj ? __defProp18(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField18 = (obj, key, value) => {
  __defNormalProp18(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var EmbossFilter = class extends Filter {
  /**
   * @param {number} [strength=5] - Strength of the emboss.
   */
  constructor(strength = 5) {
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source17,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment18,
      name: "emboss-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        embossUniforms: {
          uStrength: { value: strength, type: "f32" }
        }
      }
    });
    __publicField18(this, "uniforms");
    this.uniforms = this.resources.embossUniforms.uniforms;
  }
  /**
   * Strength of the emboss
   * @default 5
   */
  get strength() {
    return this.uniforms.uStrength;
  }
  set strength(value) {
    this.uniforms.uStrength = value;
  }
};

// node_modules/pixi-filters/lib/glitch/glitch2.mjs
var fragment19 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uDisplacementMap;\nuniform float uSeed;\nuniform vec2 uDimensions;\nuniform float uAspect;\nuniform float uFillMode;\nuniform float uOffset;\nuniform float uDirection;\nuniform vec2 uRed;\nuniform vec2 uGreen;\nuniform vec2 uBlue;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * uInputSize.xy) / uDimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float sinDir = sin(uDirection);\n    float cosDir = cos(uDirection);\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * uAspect;\n    float ny = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture(uDisplacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (uOffset / uInputSize.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * uAspect);\n\n    int fillMode = int(uFillMode);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\n    } else {\n        if( coord.x > uInputClamp.z ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x -= uInputClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = uInputClamp.z * 2.0 - coord.x;\n            }\n        } else if( coord.x < uInputClamp.x ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x += uInputClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -uInputClamp.z;\n            }\n        }\n\n        if( coord.y > uInputClamp.w ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y -= uInputClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = uInputClamp.w * 2.0 - coord.y;\n            }\n        } else if( coord.y < uInputClamp.y ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y += uInputClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -uInputClamp.w;\n            }\n        }\n    }\n\n    finalColor.r = texture(uTexture, coord + uRed * (1.0 - uSeed * 0.4) / uInputSize.xy).r;\n    finalColor.g = texture(uTexture, coord + uGreen * (1.0 - uSeed * 0.3) / uInputSize.xy).g;\n    finalColor.b = texture(uTexture, coord + uBlue * (1.0 - uSeed * 0.2) / uInputSize.xy).b;\n    finalColor.a = texture(uTexture, coord).a;\n}\n";

// node_modules/pixi-filters/lib/glitch/glitch.mjs
var source18 = "struct GlitchUniforms {\n  uSeed: f32,\n  uDimensions: vec2<f32>,\n  uAspect: f32,\n  uFillMode: f32,\n  uOffset: f32,\n  uDirection: f32,\n  uRed: vec2<f32>,\n  uGreen: vec2<f32>,\n  uBlue: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> glitchUniforms : GlitchUniforms;\n@group(1) @binding(1) var uDisplacementMap: texture_2d<f32>; \n@group(1) @binding(2) var uDisplacementSampler: sampler; \n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uSeed: f32 = glitchUniforms.uSeed;\n  let uDimensions: vec2<f32> = glitchUniforms.uDimensions;\n  let uAspect: f32 = glitchUniforms.uAspect;\n  let uOffset: f32 = glitchUniforms.uOffset;\n  let uDirection: f32 = glitchUniforms.uDirection;\n  let uRed: vec2<f32> = glitchUniforms.uRed;\n  let uGreen: vec2<f32> = glitchUniforms.uGreen;\n  let uBlue: vec2<f32> = glitchUniforms.uBlue;\n\n  let uInputSize: vec4<f32> = gfu.uInputSize;\n  let uInputClamp: vec4<f32> = gfu.uInputClamp;\n\n  var discarded: bool = false;\n  var coord: vec2<f32> = (uv * uInputSize.xy) / uDimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n      discarded = true;\n    }\n\n    let sinDir: f32 = sin(uDirection);\n    let cosDir: f32 = cos(uDirection);\n\n    let cx: f32 = coord.x - 0.5;\n    let cy: f32 = (coord.y - 0.5) * uAspect;\n    var ny: f32 = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;\n\n    ny = select(select(ny, -ny, ny < 0.0), 2.0 - ny, ny > 1.0);\n\n    let dc: vec4<f32> = textureSample(uDisplacementMap, uDisplacementSampler, vec2<f32>(0.5, ny));\n\n    let displacement: f32 = (dc.r - dc.g) * (uOffset / uInputSize.x);\n\n    coord = uv + vec2<f32>(cosDir * displacement, sinDir * displacement * uAspect);\n\n    let fillMode: i32 = i32(glitchUniforms.uFillMode);\n\n    if (fillMode == CLAMP) {\n      coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\n    } else {\n      if (coord.x > uInputClamp.z) {\n        if (fillMode == TRANSPARENT) {\n          discarded = true;\n        } else if (fillMode == LOOP) {\n          coord.x = coord.x - uInputClamp.z;\n        } else if (fillMode == MIRROR) {\n          coord.x = uInputClamp.z * 2.0 - coord.x;\n        }\n      } else if (coord.x < uInputClamp.x) {\n        if (fillMode == TRANSPARENT) {\n          discarded = true;\n        } else if (fillMode == LOOP) {\n          coord.x = coord.x + uInputClamp.z;\n        } else if (fillMode == MIRROR) {\n          coord.x = coord.x * -uInputClamp.z;\n        }\n      }\n\n      if (coord.y > uInputClamp.w) {\n        if (fillMode == TRANSPARENT) {\n          discarded = true;\n        } else if (fillMode == LOOP) {\n          coord.y = coord.y - uInputClamp.w;\n        } else if (fillMode == MIRROR) {\n          coord.y = uInputClamp.w * 2.0 - coord.y;\n        }\n      } else if (coord.y < uInputClamp.y) {\n        if (fillMode == TRANSPARENT) {\n          discarded = true;\n        } else if (fillMode == LOOP) {\n          coord.y = coord.y + uInputClamp.w;\n        } else if (fillMode == MIRROR) {\n          coord.y = coord.y * -uInputClamp.w;\n        }\n      }\n    }\n\n    let seedR: f32 = 1.0 - uSeed * 0.4;\n    let seedG: f32 = 1.0 - uSeed * 0.3;\n    let seedB: f32 = 1.0 - uSeed * 0.2;\n\n    let offsetR: vec2<f32> = vec2(uRed.x * seedR / uInputSize.x, uRed.y * seedR / uInputSize.y);\n    let offsetG: vec2<f32> = vec2(uGreen.x * seedG / uInputSize.x, uGreen.y * seedG / uInputSize.y);\n    let offsetB: vec2<f32> = vec2(uBlue.x * seedB / uInputSize.x, uBlue.y * seedB / uInputSize.y);\n\n    let r = textureSample(uTexture, uSampler, coord + offsetR).r;\n    let g = textureSample(uTexture, uSampler, coord + offsetG).g;\n    let b = textureSample(uTexture, uSampler, coord + offsetB).b;\n    let a = textureSample(uTexture, uSampler, coord).a;\n\n    return select(vec4<f32>(r, g, b, a), vec4<f32>(0.0,0.0,0.0,0.0), discarded);\n}\n\nconst TRANSPARENT: i32 = 0;\nconst ORIGINAL: i32 = 1;\nconst LOOP: i32 = 2;\nconst CLAMP: i32 = 3;\nconst MIRROR: i32 = 4;";

// node_modules/pixi-filters/lib/glitch/GlitchFilter.mjs
var __defProp19 = Object.defineProperty;
var __defNormalProp19 = (obj, key, value) => key in obj ? __defProp19(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField19 = (obj, key, value) => {
  __defNormalProp19(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _GlitchFilter = class _GlitchFilter2 extends Filter {
  /**
   * @param options - Options for the GlitchFilter constructor.
   */
  constructor(options) {
    options = { ..._GlitchFilter2.defaults, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source18,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment19,
      name: "glitch-filter"
    });
    const canvas = document.createElement("canvas");
    canvas.width = 4;
    canvas.height = options.sampleSize ?? 512;
    const texture = new Texture({
      source: new ImageSource({ resource: canvas })
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        glitchUniforms: {
          uSeed: { value: (options == null ? void 0 : options.seed) ?? 0, type: "f32" },
          uDimensions: { value: new Float32Array(2), type: "vec2<f32>" },
          uAspect: { value: 1, type: "f32" },
          uFillMode: { value: (options == null ? void 0 : options.fillMode) ?? 0, type: "f32" },
          uOffset: { value: (options == null ? void 0 : options.offset) ?? 100, type: "f32" },
          uDirection: { value: (options == null ? void 0 : options.direction) ?? 0, type: "f32" },
          uRed: { value: options.red, type: "vec2<f32>" },
          uGreen: { value: options.green, type: "vec2<f32>" },
          uBlue: { value: options.blue, type: "vec2<f32>" }
        },
        uDisplacementMap: texture.source,
        uDisplacementSampler: texture.source.style
      }
    });
    __publicField19(this, "uniforms");
    __publicField19(this, "average", false);
    __publicField19(this, "minSize", 8);
    __publicField19(this, "sampleSize", 512);
    __publicField19(this, "_canvas");
    __publicField19(this, "texture");
    __publicField19(this, "_slices", 0);
    __publicField19(this, "_sizes", new Float32Array(1));
    __publicField19(this, "_offsets", new Float32Array(1));
    this.uniforms = this.resources.glitchUniforms.uniforms;
    this._canvas = canvas;
    this.texture = texture;
    Object.assign(this, options);
  }
  /**
   * Override existing apply method in Filter
   * @private
   */
  apply(filterManager, input, output, clearMode) {
    const { width, height } = input.frame;
    this.uniforms.uDimensions[0] = width;
    this.uniforms.uDimensions[1] = height;
    this.uniforms.uAspect = height / width;
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * Randomize the slices size (heights).
   *
   * @private
   */
  _randomizeSizes() {
    const arr = this._sizes;
    const last = this._slices - 1;
    const size = this.sampleSize;
    const min = Math.min(this.minSize / size, 0.9 / this._slices);
    if (this.average) {
      const count = this._slices;
      let rest = 1;
      for (let i = 0; i < last; i++) {
        const averageWidth = rest / (count - i);
        const w = Math.max(averageWidth * (1 - Math.random() * 0.6), min);
        arr[i] = w;
        rest -= w;
      }
      arr[last] = rest;
    } else {
      let rest = 1;
      const ratio = Math.sqrt(1 / this._slices);
      for (let i = 0; i < last; i++) {
        const w = Math.max(ratio * rest * Math.random(), min);
        arr[i] = w;
        rest -= w;
      }
      arr[last] = rest;
    }
    this.shuffle();
  }
  /**
   * Shuffle the sizes of the slices, advanced usage.
   */
  shuffle() {
    const arr = this._sizes;
    const last = this._slices - 1;
    for (let i = last; i > 0; i--) {
      const rand = Math.random() * i >> 0;
      const temp = arr[i];
      arr[i] = arr[rand];
      arr[rand] = temp;
    }
  }
  /**
   * Randomize the values for offset from -1 to 1
   *
   * @private
   */
  _randomizeOffsets() {
    for (let i = 0; i < this._slices; i++) {
      this._offsets[i] = Math.random() * (Math.random() < 0.5 ? -1 : 1);
    }
  }
  /**
   * Regenerating random size, offsets for slices.
   */
  refresh() {
    this._randomizeSizes();
    this._randomizeOffsets();
    this.redraw();
  }
  /**
   * Redraw displacement bitmap texture, advanced usage.
   */
  redraw() {
    const size = this.sampleSize;
    const texture = this.texture;
    const ctx = this._canvas.getContext("2d");
    ctx.clearRect(0, 0, 8, size);
    let offset;
    let y = 0;
    for (let i = 0; i < this._slices; i++) {
      offset = Math.floor(this._offsets[i] * 256);
      const height = this._sizes[i] * size;
      const red = offset > 0 ? offset : 0;
      const green = offset < 0 ? -offset : 0;
      ctx.fillStyle = `rgba(${red}, ${green}, 0, 1)`;
      ctx.fillRect(0, y >> 0, size, height + 1 >> 0);
      y += height;
    }
    texture.source.update();
  }
  /**
   * Manually custom slices size (height) of displacement bitmap
   *
   * @member {number[]|Float32Array}
   */
  set sizes(sizes) {
    const len = Math.min(this._slices, sizes.length);
    for (let i = 0; i < len; i++) {
      this._sizes[i] = sizes[i];
    }
  }
  get sizes() {
    return this._sizes;
  }
  /**
   * Manually set custom slices offset of displacement bitmap, this is
   * a collection of values from -1 to 1. To change the max offset value
   * set `offset`.
   *
   * @member {number[]|Float32Array}
   */
  set offsets(offsets) {
    const len = Math.min(this._slices, offsets.length);
    for (let i = 0; i < len; i++) {
      this._offsets[i] = offsets[i];
    }
  }
  get offsets() {
    return this._offsets;
  }
  /**
   * The count of slices.
   * @default 5
   */
  get slices() {
    return this._slices;
  }
  set slices(value) {
    if (this._slices === value)
      return;
    this._slices = value;
    this._sizes = new Float32Array(value);
    this._offsets = new Float32Array(value);
    this.refresh();
  }
  /**
   * The maximum offset amount of slices.
   * @default 100
   */
  get offset() {
    return this.uniforms.uOffset;
  }
  set offset(value) {
    this.uniforms.uOffset = value;
  }
  /**
   * A seed value for randomizing glitch effect.
   * @default 0
   */
  get seed() {
    return this.uniforms.uSeed;
  }
  set seed(value) {
    this.uniforms.uSeed = value;
  }
  /**
   * The fill mode of the space after the offset.
   * @default FILL_MODES.TRANSPARENT
   */
  get fillMode() {
    return this.uniforms.uFillMode;
  }
  set fillMode(value) {
    this.uniforms.uFillMode = value;
  }
  /**
   * The angle in degree of the offset of slices.
   * @default 0
   */
  get direction() {
    return this.uniforms.uDirection / DEG_TO_RAD;
  }
  set direction(value) {
    this.uniforms.uDirection = value * DEG_TO_RAD;
  }
  /**
   * Red channel offset.
   * @default {x:0,y:0}
   */
  get red() {
    return this.uniforms.uRed;
  }
  set red(value) {
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this.uniforms.uRed = value;
  }
  /**
   * Green channel offset.
   * @default {x:0,y:0}
   */
  get green() {
    return this.uniforms.uGreen;
  }
  set green(value) {
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this.uniforms.uGreen = value;
  }
  /**
   * Blue offset.
   * @default {x:0,y:0}
   */
  get blue() {
    return this.uniforms.uBlue;
  }
  set blue(value) {
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this.uniforms.uBlue = value;
  }
  /**
   * Removes all references
   */
  destroy() {
    var _a;
    (_a = this.texture) == null ? void 0 : _a.destroy(true);
    this.texture = this._canvas = this.red = this.green = this.blue = this._sizes = this._offsets = null;
  }
};
__publicField19(_GlitchFilter, "defaults", {
  slices: 5,
  offset: 100,
  direction: 0,
  fillMode: 0,
  average: false,
  seed: 0,
  red: { x: 0, y: 0 },
  green: { x: 0, y: 0 },
  blue: { x: 0, y: 0 },
  minSize: 8,
  sampleSize: 512
});
var GlitchFilter = _GlitchFilter;

// node_modules/pixi-filters/lib/glow/glow.mjs
var fragment20 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uStrength;\nuniform vec3 uColor;\nuniform float uKnockout;\nuniform float uAlpha;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nconst float PI = 3.14159265358979323846264;\n\n// Hard-assignment of DIST and ANGLE_STEP_SIZE instead of using uDistance and uQuality to allow them to be use on GLSL loop conditions\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.);\nconst float ANGLE_STEP_NUM = ceil(PI * 2. / ANGLE_STEP_SIZE);\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.) / 2.;\n\nvoid main(void) {\n    vec2 px = vec2(1.) / uInputSize.xy;\n\n    float totalAlpha = 0.;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.; angle < PI * 2.; angle += ANGLE_STEP_SIZE) {\n      direction = vec2(cos(angle), sin(angle)) * px;\n\n      for (float curDistance = 0.; curDistance < DIST; curDistance++) {\n          displaced = clamp(vTextureCoord + direction * (curDistance + 1.), uInputClamp.xy, uInputClamp.zw);\n          curColor = texture(uTexture, displaced);\n          totalAlpha += (DIST - curDistance) * curColor.a;\n      }\n    }\n    \n    curColor = texture(uTexture, vTextureCoord);\n\n    vec4 glowColor = vec4(uColor, uAlpha);\n    bool knockout = uKnockout > .5;\n    float innerStrength = uStrength[0];\n    float outerStrength = uStrength[1];\n\n    float alphaRatio = totalAlpha / MAX_TOTAL_ALPHA;\n    float innerGlowAlpha = (1. - alphaRatio) * innerStrength * curColor.a * uAlpha;\n    float innerGlowStrength = min(1., innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a) * uAlpha;\n    float outerGlowStrength = min(1. - innerColor.a, outerGlowAlpha);\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\n\n    if (knockout) {\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\n      finalColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      finalColor = innerColor + outerGlowColor;\n    }\n}\n";

// node_modules/pixi-filters/lib/glow/glow2.mjs
var source19 = "struct GlowUniforms {\n  uDistance: f32,\n  uStrength: vec2<f32>,\n  uColor: vec3<f32>,\n  uAlpha: f32,\n  uQuality: f32,\n  uKnockout: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> glowUniforms : GlowUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let quality = glowUniforms.uQuality;\n  let distance = glowUniforms.uDistance;\n\n  let dist: f32 = glowUniforms.uDistance;\n  let angleStepSize: f32 = min(1. / quality / distance, PI * 2.0);\n  let angleStepNum: f32 = ceil(PI * 2.0 / angleStepSize);\n\n  let px: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\n\n  var totalAlpha: f32 = 0.0;\n\n  var direction: vec2<f32>;\n  var displaced: vec2<f32>;\n  var curColor: vec4<f32>;\n\n  for (var angle = 0.0; angle < PI * 2.0; angle += angleStepSize) {\n    direction = vec2<f32>(cos(angle), sin(angle)) * px;\n    for (var curDistance = 0.0; curDistance < dist; curDistance+=1) {\n      displaced = vec2<f32>(clamp(uv + direction * (curDistance + 1.0), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n      curColor = textureSample(uTexture, uSampler, displaced);\n      totalAlpha += (dist - curDistance) * curColor.a;\n    }\n  }\n    \n  curColor = textureSample(uTexture, uSampler, uv);\n\n  let glowColorRGB = glowUniforms.uColor;\n  let glowAlpha = glowUniforms.uAlpha;\n  let glowColor = vec4<f32>(glowColorRGB, glowAlpha);\n  let knockout: bool = glowUniforms.uKnockout > 0.5;\n  let innerStrength = glowUniforms.uStrength[0];\n  let outerStrength = glowUniforms.uStrength[1];\n\n  let alphaRatio: f32 = (totalAlpha / (angleStepNum * dist * (dist + 1.0) / 2.0));\n  let innerGlowAlpha: f32 = (1.0 - alphaRatio) * innerStrength * curColor.a * glowAlpha;\n  let innerGlowStrength: f32 = min(1.0, innerGlowAlpha);\n  \n  let innerColor: vec4<f32> = mix(curColor, glowColor, innerGlowStrength);\n  let outerGlowAlpha: f32 = alphaRatio * outerStrength * (1. - curColor.a) * glowAlpha;\n  let outerGlowStrength: f32 = min(1.0 - innerColor.a, outerGlowAlpha);\n  let outerGlowColor: vec4<f32> = outerGlowStrength * glowColor.rgba;\n  \n  if (knockout) {\n    let resultAlpha: f32 = outerGlowAlpha + innerGlowAlpha;\n    return vec4<f32>(glowColor.rgb * resultAlpha, resultAlpha);\n  }\n  else {\n    return innerColor + outerGlowColor;\n  }\n}\n\nconst PI: f32 = 3.14159265358979323846264;";

// node_modules/pixi-filters/lib/glow/GlowFilter.mjs
var __defProp20 = Object.defineProperty;
var __defNormalProp20 = (obj, key, value) => key in obj ? __defProp20(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField20 = (obj, key, value) => {
  __defNormalProp20(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _GlowFilter = class _GlowFilter2 extends Filter {
  /**
   * @param options - Options for the GlowFilter constructor.
   */
  constructor(options) {
    options = { ..._GlowFilter2.DEFAULT_OPTIONS, ...options };
    const distance = options.distance ?? 10;
    const quality = options.quality ?? 0.1;
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source19,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment20.replace(/__ANGLE_STEP_SIZE__/gi, `${(1 / quality / distance).toFixed(7)}`).replace(/__DIST__/gi, `${distance.toFixed(0)}.0`),
      name: "glow-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        glowUniforms: {
          uDistance: { value: distance, type: "f32" },
          uStrength: { value: [options.innerStrength, options.outerStrength], type: "vec2<f32>" },
          uColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uAlpha: { value: options.alpha, type: "f32" },
          uQuality: { value: quality, type: "f32" },
          uKnockout: { value: (options == null ? void 0 : options.knockout) ?? false ? 1 : 0, type: "f32" }
        }
      },
      padding: distance
    });
    __publicField20(this, "uniforms");
    __publicField20(this, "_color");
    this.uniforms = this.resources.glowUniforms.uniforms;
    this._color = new Color();
    this.color = options.color ?? 16777215;
  }
  /**
   * Only draw the glow, not the texture itself
   * @default false
   */
  get distance() {
    return this.uniforms.uDistance;
  }
  set distance(value) {
    this.uniforms.uDistance = this.padding = value;
  }
  /**
  * The strength of the glow inward from the edge of the sprite.
  * @default 0
  */
  get innerStrength() {
    return this.uniforms.uStrength[0];
  }
  set innerStrength(value) {
    this.uniforms.uStrength[0] = value;
  }
  /**
  * The strength of the glow outward from the edge of the sprite.
  * @default 4
  */
  get outerStrength() {
    return this.uniforms.uStrength[1];
  }
  set outerStrength(value) {
    this.uniforms.uStrength[1] = value;
  }
  /**
  * The color of the glow.
  * @default 0xFFFFFF
  */
  get color() {
    return this._color.value;
  }
  set color(value) {
    this._color.setValue(value);
    const [r, g, b] = this._color.toArray();
    this.uniforms.uColor[0] = r;
    this.uniforms.uColor[1] = g;
    this.uniforms.uColor[2] = b;
  }
  /**
  * The alpha of the glow
  * @default 1
  */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
  /**
  * A number between 0 and 1 that describes the quality of the glow. The higher the number the less performant
  * @default 0.1
  */
  get quality() {
    return this.uniforms.uQuality;
  }
  set quality(value) {
    this.uniforms.uQuality = value;
  }
  /**
  * Only draw the glow, not the texture itself
  * @default false
  */
  get knockout() {
    return this.uniforms.uKnockout === 1;
  }
  set knockout(value) {
    this.uniforms.uKnockout = value ? 1 : 0;
  }
};
__publicField20(_GlowFilter, "DEFAULT_OPTIONS", {
  distance: 10,
  outerStrength: 4,
  innerStrength: 0,
  color: 16777215,
  alpha: 1,
  quality: 0.1,
  knockout: false
});
var GlowFilter = _GlowFilter;

// node_modules/pixi-filters/lib/godray/god-ray2.mjs
var fragment21 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uDimensions;\nuniform float uParallel;\nuniform vec2 uLight;\nuniform float uAspect;\nuniform float uTime;\nuniform vec3 uRay;\n\nuniform vec4 uInputSize;\n\n${PERLIN}\n\nvoid main(void) {\n    vec2 uDimensions = uDimensions;\n    bool uParallel = uParallel > 0.5;\n    vec2 uLight = uLight;\n    float uAspect = uAspect;\n\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;\n\n    float d;\n\n    if (uParallel) {\n        float _cos = uLight.x;\n        float _sin = uLight.y;\n        d = (_cos * coord.x) + (_sin * coord.y * uAspect);\n    } else {\n        float dx = coord.x - uLight.x / uDimensions.x;\n        float dy = (coord.y - uLight.y / uDimensions.y) * uAspect;\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\n        d = dy / dis;\n    }\n\n    float uTime = uTime;\n    vec3 uRay = uRay;\n\n    float gain = uRay[0];\n    float lacunarity = uRay[1];\n    float alpha = uRay[2];\n\n    vec3 dir = vec3(d, d, 0.0);\n    float noise = turb(dir + vec3(uTime, 0.0, 62.1 + uTime) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\n    noise = mix(noise, 0.0, 0.3);\n    //fade vertically.\n    vec4 mist = vec4(vec3(noise), 1.0) * (1.0 - coord.y);\n    mist.a = 1.0;\n    // apply user alpha\n    mist *= alpha;\n\n    finalColor = texture(uTexture, vTextureCoord) + mist;\n}\n";

// node_modules/pixi-filters/lib/godray/god-ray.mjs
var source20 = "struct GodrayUniforms {\n  uLight: vec2<f32>,\n  uParallel: f32,\n  uAspect: f32,\n  uTime: f32,\n  uRay: vec3<f32>,\n  uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> godrayUniforms : GodrayUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uDimensions: vec2<f32> = godrayUniforms.uDimensions;\n  let uParallel: bool = godrayUniforms.uParallel > 0.5;\n  let uLight: vec2<f32> = godrayUniforms.uLight;\n  let uAspect: f32 = godrayUniforms.uAspect;\n\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / uDimensions;\n\n  var d: f32;\n\n  if (uParallel) {\n    let _cos: f32 = uLight.x;\n    let _sin: f32 = uLight.y;\n    d = (_cos * coord.x) + (_sin * coord.y * uAspect);\n  } else {\n    let dx: f32 = coord.x - uLight.x / uDimensions.x;\n    let dy: f32 = (coord.y - uLight.y / uDimensions.y) * uAspect;\n    let dis: f32 = sqrt(dx * dx + dy * dy) + 0.00001;\n    d = dy / dis;\n  }\n\n  let uTime: f32 = godrayUniforms.uTime;\n  let uRay: vec3<f32> = godrayUniforms.uRay;\n  \n  let gain = uRay[0];\n  let lacunarity = uRay[1];\n  let alpha = uRay[2];\n\n  let dir: vec3<f32> = vec3<f32>(d, d, 0.0);\n  var noise: f32 = turb(dir + vec3<f32>(uTime, 0.0, 62.1 + uTime) * 0.05, vec3<f32>(480.0, 320.0, 480.0), lacunarity, gain);\n  noise = mix(noise, 0.0, 0.3);\n  //fade vertically.\n  var mist: vec4<f32> = vec4<f32>(vec3<f32>(noise), 1.0) * (1.0 - coord.y);\n  mist.a = 1.0;\n  // apply user alpha\n  mist *= alpha;\n  return textureSample(uTexture, uSampler, uv) + mist;\n}\n\n${PERLIN}";

// node_modules/pixi-filters/lib/godray/perlin.mjs
var perlin = "vec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float sc = 1.0;\n    float totalgain = 1.0;\n    for (float i = 0.0; i < 6.0; i++)\n    {\n        sum += totalgain * pnoise(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}\n";

// node_modules/pixi-filters/lib/godray/perlin2.mjs
var sourcePerlin = "// Taken from https://gist.github.com/munrocket/236ed5ba7e409b8bdf1ff6eca5dcdc39\n\nfn moduloVec3(x: vec3<f32>, y: vec3<f32>) -> vec3<f32>\n{\n  return x - y * floor(x/y);\n}\nfn mod289Vec3(x: vec3<f32>) -> vec3<f32>\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nfn mod289Vec4(x: vec4<f32>) -> vec4<f32>\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nfn permute4(x: vec4<f32>) -> vec4<f32>\n{\n    return mod289Vec4(((x * 34.0) + 1.0) * x);\n}\nfn taylorInvSqrt(r: vec4<f32>) -> vec4<f32>\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nfn fade3(t: vec3<f32>) -> vec3<f32>\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\nfn fade2(t: vec2<f32>) -> vec2<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }\n\nfn perlinNoise2(P: vec2<f32>) -> f32 {\n  var Pi: vec4<f32> = floor(P.xyxy) + vec4<f32>(0., 0., 1., 1.);\n  let Pf = fract(P.xyxy) - vec4<f32>(0., 0., 1., 1.);\n  Pi = Pi % vec4<f32>(289.); // To avoid truncation effects in permutation\n  let ix = Pi.xzxz;\n  let iy = Pi.yyww;\n  let fx = Pf.xzxz;\n  let fy = Pf.yyww;\n  let i = permute4(permute4(ix) + iy);\n  var gx: vec4<f32> = 2. * fract(i * 0.0243902439) - 1.; // 1/41 = 0.024...\n  let gy = abs(gx) - 0.5;\n  let tx = floor(gx + 0.5);\n  gx = gx - tx;\n  var g00: vec2<f32> = vec2<f32>(gx.x, gy.x);\n  var g10: vec2<f32> = vec2<f32>(gx.y, gy.y);\n  var g01: vec2<f32> = vec2<f32>(gx.z, gy.z);\n  var g11: vec2<f32> = vec2<f32>(gx.w, gy.w);\n  let norm = 1.79284291400159 - 0.85373472095314 *\n      vec4<f32>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 = g00 * norm.x;\n  g01 = g01 * norm.y;\n  g10 = g10 * norm.z;\n  g11 = g11 * norm.w;\n  let n00 = dot(g00, vec2<f32>(fx.x, fy.x));\n  let n10 = dot(g10, vec2<f32>(fx.y, fy.y));\n  let n01 = dot(g01, vec2<f32>(fx.z, fy.z));\n  let n11 = dot(g11, vec2<f32>(fx.w, fy.w));\n  let fade_xy = fade2(Pf.xy);\n  let n_x = mix(vec2<f32>(n00, n01), vec2<f32>(n10, n11), vec2<f32>(fade_xy.x));\n  let n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfn perlinNoise3(P: vec3<f32>, rep: vec3<f32>) -> f32\n{\n    var Pi0: vec3<f32> = moduloVec3(floor(P), rep); // Integer part, modulo period\n    var Pi1: vec3<f32> = moduloVec3(Pi0 + vec3<f32>(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289Vec3(Pi0);\n    Pi1 = mod289Vec3(Pi1);\n    let Pf0: vec3<f32> = fract(P); // Fractional part for interpolation\n    let Pf1: vec3<f32> = Pf0 - vec3<f32>(1.0); // Fractional part - 1.0\n    let ix: vec4<f32> = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    let iy: vec4<f32> = vec4<f32>(Pi0.yy, Pi1.yy);\n    let iz0: vec4<f32> = Pi0.zzzz;\n    let iz1: vec4<f32> = Pi1.zzzz;\n    let ixy: vec4<f32> = permute4(permute4(ix) + iy);\n    let ixy0: vec4<f32> = permute4(ixy + iz0);\n    let ixy1: vec4<f32> = permute4(ixy + iz1);\n    var gx0: vec4<f32> = ixy0 * (1.0 / 7.0);\n    var gy0: vec4<f32> = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    let gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);\n    let sz0: vec4<f32> = step(gz0, vec4<f32>(0.0));\n    gx0 -= sz0 * (step(vec4<f32>(0.0), gx0) - 0.5);\n    gy0 -= sz0 * (step(vec4<f32>(0.0), gy0) - 0.5);\n    var gx1: vec4<f32> = ixy1 * (1.0 / 7.0);\n    var gy1: vec4<f32> = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    let gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);\n    let sz1: vec4<f32> = step(gz1, vec4<f32>(0.0));\n    gx1 -= sz1 * (step(vec4<f32>(0.0), gx1) - 0.5);\n    gy1 -= sz1 * (step(vec4<f32>(0.0), gy1) - 0.5);\n    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);\n    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);\n    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);\n    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);\n    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);\n    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);\n    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);\n    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);\n    let norm0: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    let norm1: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    let n000: f32 = dot(g000, Pf0);\n    let n100: f32 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));\n    let n010: f32 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));\n    let n110: f32 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));\n    let n001: f32 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));\n    let n101: f32 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));\n    let n011: f32 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));\n    let n111: f32 = dot(g111, Pf1);\n    let fade_xyz: vec3<f32> = fade3(Pf0);\n    let n_z: vec4<f32> = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), fade_xyz.z);\n    let n_yz: vec2<f32> = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    let n_xyz: f32 = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfn turb(P: vec3<f32>, rep: vec3<f32>, lacunarity: f32, gain: f32) -> f32\n{\n    var sum: f32 = 0.0;\n    var sc: f32 = 1.0;\n    var totalgain: f32 = 1.0;\n    for (var i = 0.0; i < 6.0; i += 1)\n    {\n        sum += totalgain * perlinNoise3(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}";

// node_modules/pixi-filters/lib/godray/GodrayFilter.mjs
var __defProp21 = Object.defineProperty;
var __defNormalProp21 = (obj, key, value) => key in obj ? __defProp21(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField21 = (obj, key, value) => {
  __defNormalProp21(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _GodrayFilter = class _GodrayFilter2 extends Filter {
  /**
   * @param options - Options for the GodrayFilter constructor.
   */
  constructor(options) {
    options = { ..._GodrayFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source20.replace("${PERLIN}", sourcePerlin),
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment21.replace("${PERLIN}", perlin),
      name: "god-ray-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        godrayUniforms: {
          uLight: { value: new Float32Array(2), type: "vec2<f32>" },
          uParallel: { value: 0, type: "f32" },
          uAspect: { value: 0, type: "f32" },
          uTime: { value: options.time, type: "f32" },
          uRay: { value: new Float32Array(3), type: "vec3<f32>" },
          uDimensions: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    });
    __publicField21(this, "uniforms");
    __publicField21(this, "time", 0);
    __publicField21(this, "_angleLight", [0, 0]);
    __publicField21(this, "_angle", 0);
    __publicField21(this, "_center");
    this.uniforms = this.resources.godrayUniforms.uniforms;
    Object.assign(this, options);
  }
  /**
   * Override existing apply method in Filter
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    const width = input.frame.width;
    const height = input.frame.height;
    this.uniforms.uLight[0] = this.parallel ? this._angleLight[0] : this._center.x;
    this.uniforms.uLight[1] = this.parallel ? this._angleLight[1] : this._center.y;
    this.uniforms.uDimensions[0] = width;
    this.uniforms.uDimensions[1] = height;
    this.uniforms.uAspect = height / width;
    this.uniforms.uTime = this.time;
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * The angle/light-source of the rays in degrees. For instance,
   * a value of 0 is vertical rays, values of 90 or -90 produce horizontal rays
   * @default 30
   */
  get angle() {
    return this._angle;
  }
  set angle(value) {
    this._angle = value;
    const radians = value * DEG_TO_RAD;
    this._angleLight[0] = Math.cos(radians);
    this._angleLight[1] = Math.sin(radians);
  }
  /**
   * `true` if light rays are parallel (uses angle), `false` to use the focal `center` point
   * @default true
   */
  get parallel() {
    return this.uniforms.uParallel > 0.5;
  }
  set parallel(value) {
    this.uniforms.uParallel = value ? 1 : 0;
  }
  /**
   * Focal point for non-parallel rays, to use this `parallel` must be set to `false`.
   * @default {x:0,y:0}
   */
  get center() {
    return this._center;
  }
  set center(value) {
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this._center = value;
  }
  /**
   * Focal point for non-parallel rays on the `x` axis, to use this `parallel` must be set to `false`.
   * @default 0
   */
  get centerX() {
    return this.center.x;
  }
  set centerX(value) {
    this.center.x = value;
  }
  /**
   * Focal point for non-parallel rays on the `y` axis, to use this `parallel` must be set to `false`.
   * @default 0
   */
  get centerY() {
    return this.center.y;
  }
  set centerY(value) {
    this.center.y = value;
  }
  /**
   * General intensity of the effect. A value closer to 1 will produce a more intense effect,
   * where a value closer to 0 will produce a subtler effect
   * @default 0.5
   */
  get gain() {
    return this.uniforms.uRay[0];
  }
  set gain(value) {
    this.uniforms.uRay[0] = value;
  }
  /**
   * The density of the fractal noise.
   * A higher amount produces more rays and a smaller amount produces fewer waves
   * @default 2.5
   */
  get lacunarity() {
    return this.uniforms.uRay[1];
  }
  set lacunarity(value) {
    this.uniforms.uRay[1] = value;
  }
  /**
   * The alpha (opacity) of the rays.  0 is fully transparent, 1 is fully opaque.
   * @default 1
   */
  get alpha() {
    return this.uniforms.uRay[2];
  }
  set alpha(value) {
    this.uniforms.uRay[2] = value;
  }
};
__publicField21(_GodrayFilter, "DEFAULT_OPTIONS", {
  angle: 30,
  gain: 0.5,
  lacunarity: 2.5,
  parallel: true,
  time: 0,
  center: { x: 0, y: 0 },
  alpha: 1
});
var GodrayFilter = _GodrayFilter;

// node_modules/pixi-filters/lib/grayscale/grayscale2.mjs
var fragment22 = "in vec2 vTextureCoord;\n\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\n\n// https://en.wikipedia.org/wiki/Luma_(video)\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\n\nvoid main()\n{\n    vec4 c = texture(uTexture, vTextureCoord);\n    finalColor = vec4(\n        vec3(c.r * weight.r + c.g * weight.g  + c.b * weight.b),\n        c.a\n    );\n}\n";

// node_modules/pixi-filters/lib/grayscale/grayscale.mjs
var source21 = "@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  let g: f32 = dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114));\n  return vec4<f32>(vec3<f32>(g), 1.);\n}";

// node_modules/pixi-filters/lib/grayscale/GrayscaleFilter.mjs
var GrayscaleFilter = class extends Filter {
  constructor() {
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source21,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment22,
      name: "grayscale-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {}
    });
  }
};

// node_modules/pixi-filters/lib/hsl-adjustment/hsladjustment.mjs
var fragment23 = "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec3 uHsl;\nuniform float uAlpha;\nuniform float uColorize;\n\n// https://en.wikipedia.org/wiki/Luma_(video)\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\n\nfloat getWeightedAverage(vec3 rgb) {\n    return rgb.r * weight.r + rgb.g * weight.g + rgb.b * weight.b;\n}\n\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\nconst vec3 k = vec3(0.57735, 0.57735, 0.57735);\n\nvec3 hueShift(vec3 color, float angle) {\n    float cosAngle = cos(angle);\n    return vec3(\n    color * cosAngle +\n    cross(k, color) * sin(angle) +\n    k * dot(k, color) * (1.0 - cosAngle)\n    );\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    vec3 resultRGB = color.rgb;\n\n    float hue = uHsl[0];\n    float saturation = uHsl[1];\n    float lightness = uHsl[2];\n\n    // colorize\n    if (uColorize > 0.5) {\n        resultRGB = vec3(getWeightedAverage(resultRGB), 0., 0.);\n    }\n\n    // hue\n    resultRGB = hueShift(resultRGB, hue);\n\n    // saturation\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\n    float average = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;\n\n    if (saturation > 0.) {\n        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));\n    } else {\n        resultRGB -= (average - resultRGB) * saturation;\n    }\n\n    // lightness\n    resultRGB = mix(resultRGB, vec3(ceil(lightness)) * color.a, abs(lightness));\n\n    // alpha\n    finalColor = mix(color, vec4(resultRGB, color.a), uAlpha);\n}\n";

// node_modules/pixi-filters/lib/hsl-adjustment/hsladjustment2.mjs
var source22 = "struct HslUniforms {\n  uHsl:vec3<f32>,\n  uColorize:f32,\n  uAlpha:f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> hslUniforms : HslUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n    let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n    var resultRGB: vec3<f32> = color.rgb;\n\n    let hue: f32 = hslUniforms.uHsl[0];\n    let saturation: f32 = hslUniforms.uHsl[1];\n    let lightness: f32 = hslUniforms.uHsl[2];\n\n    // colorize\n    if (hslUniforms.uColorize > 0.5) {\n        resultRGB = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)), 0., 0.);\n    }\n\n    // hue\n    resultRGB = hueShift(resultRGB, hue);\n\n    // saturation\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\n    let average: f32 = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;\n\n    if (saturation > 0.) {\n        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));\n    } else {\n        resultRGB -= (average - resultRGB) * saturation;\n    }\n\n    // lightness\n    resultRGB = mix(resultRGB, vec3<f32>(ceil(lightness)) * color.a, abs(lightness));\n\n    // alpha\n    return mix(color, vec4<f32>(resultRGB, color.a), hslUniforms.uAlpha);\n}\n\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\nconst k: vec3<f32> = vec3(0.57735, 0.57735, 0.57735);\n\nfn hueShift(color: vec3<f32>, angle: f32) -> vec3<f32> \n{\n    let cosAngle: f32 = cos(angle);\n    return vec3<f32>(\n    color * cosAngle +\n    cross(k, color) * sin(angle) +\n    k * dot(k, color) * (1.0 - cosAngle)\n    );\n}";

// node_modules/pixi-filters/lib/hsl-adjustment/HslAdjustmentFilter.mjs
var __defProp22 = Object.defineProperty;
var __defNormalProp22 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField22 = (obj, key, value) => {
  __defNormalProp22(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _HslAdjustmentFilter = class _HslAdjustmentFilter2 extends Filter {
  /**
   * @param options - Options for the HslAdjustmentFilter constructor.
   */
  constructor(options) {
    options = { ..._HslAdjustmentFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source22,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment23,
      name: "hsl-adjustment-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        hslUniforms: {
          uHsl: { value: new Float32Array(3), type: "vec3<f32>" },
          uColorize: { value: options.colorize ? 1 : 0, type: "f32" },
          uAlpha: { value: options.alpha, type: "f32" }
        }
      }
    });
    __publicField22(this, "uniforms");
    __publicField22(this, "_hue");
    this.uniforms = this.resources.hslUniforms.uniforms;
    Object.assign(this, options);
  }
  /**
   * The amount of hue in degrees (-180 to 180)
   * @default 0
   */
  get hue() {
    return this._hue;
  }
  set hue(value) {
    this._hue = value;
    this.uniforms.uHsl[0] = value * (Math.PI / 180);
  }
  /**
   * The amount of lightness (-1 to 1)
   * @default 0
   */
  get saturation() {
    return this.uniforms.uHsl[1];
  }
  set saturation(value) {
    this.uniforms.uHsl[1] = value;
  }
  /**
   * The amount of lightness (-1 to 1)
   * @default 0
   */
  get lightness() {
    return this.uniforms.uHsl[2];
  }
  set lightness(value) {
    this.uniforms.uHsl[2] = value;
  }
  /**
   * Whether to colorize the image
   * @default false
   */
  get colorize() {
    return this.uniforms.uColorize === 1;
  }
  set colorize(value) {
    this.uniforms.uColorize = value ? 1 : 0;
  }
  /**
   * The amount of alpha (0 to 1)
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
};
__publicField22(_HslAdjustmentFilter, "DEFAULT_OPTIONS", {
  hue: 0,
  saturation: 0,
  lightness: 0,
  colorize: false,
  alpha: 1
});
var HslAdjustmentFilter = _HslAdjustmentFilter;

// node_modules/pixi-filters/lib/motion-blur/motion-blur2.mjs
var fragment24 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nuniform vec4 uInputSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        finalColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / uInputSize.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture(uTexture, vTextureCoord + bias);\n    }\n    finalColor = color / float(uKernelSize);\n}\n";

// node_modules/pixi-filters/lib/motion-blur/motion-blur.mjs
var source23 = "struct MotionBlurUniforms {\n  uVelocity: vec2<f32>,\n  uKernelSize: i32,\n  uOffset: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> motionBlurUniforms : MotionBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uVelocity = motionBlurUniforms.uVelocity;\n  let uKernelSize = motionBlurUniforms.uKernelSize;\n  let uOffset = motionBlurUniforms.uOffset;\n\n  let velocity: vec2<f32> = uVelocity / gfu.uInputSize.xy;\n  let offset: f32 = -uOffset / length(uVelocity) - 0.5;\n  let k: i32 = min(uKernelSize - 1, MAX_KERNEL_SIZE - 1);\n\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  for(var i: i32 = 0; i < k; i += 1) {\n    let bias: vec2<f32> = velocity * (f32(i) / f32(k) + offset);\n    color += textureSample(uTexture, uSampler, uv + bias);\n  }\n  \n  return select(color / f32(uKernelSize), textureSample(uTexture, uSampler, uv), uKernelSize == 0);\n}\n\nconst MAX_KERNEL_SIZE: i32 = 2048;";

// node_modules/pixi-filters/lib/motion-blur/MotionBlurFilter.mjs
var __defProp23 = Object.defineProperty;
var __defNormalProp23 = (obj, key, value) => key in obj ? __defProp23(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField23 = (obj, key, value) => {
  __defNormalProp23(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _MotionBlurFilter = class _MotionBlurFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (Array.isArray(options) || "x" in options && "y" in options || options instanceof ObservablePoint) {
      deprecation("6.0.0", "MotionBlurFilter constructor params are now options object. See params: { velocity, kernelSize, offset }");
      const x = "x" in options ? options.x : options[0];
      const y = "y" in options ? options.y : options[1];
      options = { velocity: { x, y } };
      if (args[1] !== void 0)
        options.kernelSize = args[1];
      if (args[2] !== void 0)
        options.offset = args[2];
    }
    options = { ..._MotionBlurFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source23,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment24,
      name: "motion-blur-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        motionBlurUniforms: {
          uVelocity: { value: options.velocity, type: "vec2<f32>" },
          uKernelSize: { value: Math.trunc(options.kernelSize ?? 5), type: "i32" },
          uOffset: { value: options.offset, type: "f32" }
        }
      }
    });
    __publicField23(this, "uniforms");
    __publicField23(this, "_kernelSize");
    this.uniforms = this.resources.motionBlurUniforms.uniforms;
    Object.assign(this, options);
  }
  /**
   * Sets the velocity of the motion for blur effect
   * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types
   * once defined in the constructor
   * @default {x:0,y:0}
   */
  get velocity() {
    return this.uniforms.uVelocity;
  }
  set velocity(value) {
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this.uniforms.uVelocity = value;
    this._updateDirty();
  }
  /**
   * Sets the velocity of the motion for blur effect on the `x` axis
   * @default 0
   */
  get velocityX() {
    return this.velocity.x;
  }
  set velocityX(value) {
    this.velocity.x = value;
    this._updateDirty();
  }
  /**
   * Sets the velocity of the motion for blur effect on the `x` axis
   * @default 0
   */
  get velocityY() {
    return this.velocity.y;
  }
  set velocityY(value) {
    this.velocity.y = value;
    this._updateDirty();
  }
  /**
   * The kernelSize of the blur filter. Must be odd number >= 5
   * @default 5
   */
  get kernelSize() {
    return this._kernelSize;
  }
  set kernelSize(value) {
    this._kernelSize = value;
    this._updateDirty();
  }
  /**
   * The offset of the blur filter
   * @default 0
   */
  get offset() {
    return this.uniforms.uOffset;
  }
  set offset(value) {
    this.uniforms.uOffset = value;
  }
  _updateDirty() {
    this.padding = (Math.max(Math.abs(this.velocityX), Math.abs(this.velocityY)) >> 0) + 1;
    this.uniforms.uKernelSize = this.velocityX !== 0 || this.velocityY !== 0 ? this._kernelSize : 0;
  }
};
__publicField23(_MotionBlurFilter, "DEFAULT_OPTIONS", {
  velocity: { x: 0, y: 0 },
  kernelSize: 5,
  offset: 0
});
var MotionBlurFilter = _MotionBlurFilter;

// node_modules/pixi-filters/lib/multi-color-replace/multi-color-replace.mjs
var fragment25 = "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nconst int MAX_COLORS = ${MAX_COLORS};\n\nuniform sampler2D uTexture;\nuniform vec3 uOriginalColors[MAX_COLORS];\nuniform vec3 uTargetColors[MAX_COLORS];\nuniform float uTolerance;\n\nvoid main(void)\n{\n    finalColor = texture(uTexture, vTextureCoord);\n\n    float alpha = finalColor.a;\n    if (alpha < 0.0001)\n    {\n      return;\n    }\n\n    vec3 color = finalColor.rgb / alpha;\n\n    for(int i = 0; i < MAX_COLORS; i++)\n    {\n      vec3 origColor = uOriginalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      vec3 colorDiff = origColor - color;\n      if (length(colorDiff) < uTolerance)\n      {\n        vec3 targetColor = uTargetColors[i];\n        finalColor = vec4((targetColor + colorDiff) * alpha, alpha);\n        return;\n      }\n    }\n}\n";

// node_modules/pixi-filters/lib/multi-color-replace/multi-color-replace2.mjs
var source24 = "struct MultiColorReplaceUniforms {\n  uOriginalColors: array<vec3<f32>, MAX_COLORS>,\n  uTargetColors: array<vec3<f32>, MAX_COLORS>,\n  uTolerance:f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> multiColorReplaceUniforms : MultiColorReplaceUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uOriginalColors = multiColorReplaceUniforms.uOriginalColors;\n  let uTargetColors = multiColorReplaceUniforms.uTargetColors;\n  let uTolerance = multiColorReplaceUniforms.uTolerance;\n\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  let alpha: f32 = color.a;\n\n  if (alpha > 0.0001)\n  {\n    var modColor: vec3<f32> = vec3<f32>(color.rgb) / alpha;\n\n    for(var i: i32 = 0; i < MAX_COLORS; i += 1)\n    {\n      let origColor: vec3<f32> = uOriginalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      let colorDiff: vec3<f32> = origColor - modColor;\n      \n      if (length(colorDiff) < uTolerance)\n      {\n        let targetColor: vec3<f32> = uTargetColors[i];\n        color = vec4((targetColor + colorDiff) * alpha, alpha);\n        return color;\n      }\n    }\n  }\n\n  return color;\n}\n\nconst MAX_COLORS: i32 = ${MAX_COLORS};";

// node_modules/pixi-filters/lib/multi-color-replace/MultiColorReplaceFilter.mjs
var __defProp24 = Object.defineProperty;
var __defNormalProp24 = (obj, key, value) => key in obj ? __defProp24(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField24 = (obj, key, value) => {
  __defNormalProp24(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _MultiColorReplaceFilter = class _MultiColorReplaceFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (Array.isArray(options)) {
      deprecation("6.0.0", "MultiColorReplaceFilter constructor params are now options object. See params: { replacements, tolerance, maxColors }");
      options = { replacements: options };
      if (args[1])
        options.tolerance = args[1];
      if (args[2])
        options.maxColors = args[2];
    }
    options = { ..._MultiColorReplaceFilter2.DEFAULT_OPTIONS, ...options };
    const maxColors = options.maxColors ?? options.replacements.length;
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source24.replace(/\$\{MAX_COLORS\}/g, maxColors.toFixed(0)),
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment25.replace(/\$\{MAX_COLORS\}/g, maxColors.toFixed(0)),
      name: "multi-color-replace-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        multiColorReplaceUniforms: {
          uOriginalColors: {
            value: new Float32Array(3 * maxColors),
            type: "vec3<f32>",
            size: maxColors
          },
          uTargetColors: {
            value: new Float32Array(3 * maxColors),
            type: "vec3<f32>",
            size: maxColors
          },
          uTolerance: { value: options.tolerance, type: "f32" }
        }
      }
    });
    __publicField24(this, "uniforms");
    __publicField24(this, "_replacements", []);
    __publicField24(this, "_maxColors");
    this._maxColors = maxColors;
    this.uniforms = this.resources.multiColorReplaceUniforms.uniforms;
    this.replacements = options.replacements;
  }
  /**
   * The collection of replacement items. Each item is color-pair
   * (an array length is 2). In the pair, the first value is original color , the second value is target color
   */
  set replacements(replacements) {
    const originals = this.uniforms.uOriginalColors;
    const targets = this.uniforms.uTargetColors;
    const colorCount = replacements.length;
    const color = new Color();
    if (colorCount > this._maxColors) {
      throw new Error(`Length of replacements (${colorCount}) exceeds the maximum colors length (${this._maxColors})`);
    }
    originals[colorCount * 3] = -1;
    let r;
    let g;
    let b;
    for (let i = 0; i < colorCount; i++) {
      const pair = replacements[i];
      color.setValue(pair[0]);
      [r, g, b] = color.toArray();
      originals[i * 3] = r;
      originals[i * 3 + 1] = g;
      originals[i * 3 + 2] = b;
      color.setValue(pair[1]);
      [r, g, b] = color.toArray();
      targets[i * 3] = r;
      targets[i * 3 + 1] = g;
      targets[i * 3 + 2] = b;
    }
    this._replacements = replacements;
  }
  get replacements() {
    return this._replacements;
  }
  /**
    * Should be called after changing any of the contents of the replacements.
    * This is a convenience method for resetting the `replacements`.
    * @todo implement nested proxy to remove the need for this function
    */
  refresh() {
    this.replacements = this._replacements;
  }
  /**
    * The maximum number of color replacements supported by this filter. Can be changed
    * _only_ during construction.
    * @readonly
    */
  get maxColors() {
    return this._maxColors;
  }
  /**
    * Tolerance of the floating-point comparison between colors (lower = more exact, higher = more inclusive)
    * @default 0.05
    */
  get tolerance() {
    return this.uniforms.uTolerance;
  }
  set tolerance(value) {
    this.uniforms.uTolerance = value;
  }
  /**
   * @deprecated since 6.0.0
   *
   * Tolerance of the floating-point comparison between colors (lower = more exact, higher = more inclusive)
   * @default 0.05
   */
  set epsilon(value) {
    deprecation("6.0.0", "MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead");
    this.tolerance = value;
  }
  get epsilon() {
    deprecation("6.0.0", "MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead");
    return this.tolerance;
  }
};
__publicField24(_MultiColorReplaceFilter, "DEFAULT_OPTIONS", {
  replacements: [[16711680, 255]],
  tolerance: 0.05,
  maxColors: void 0
});
var MultiColorReplaceFilter = _MultiColorReplaceFilter;

// node_modules/pixi-filters/lib/old-film/old-film.mjs
var fragment26 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uSepia;\nuniform vec2 uNoise;\nuniform vec3 uScratch;\nuniform vec3 uVignetting;\nuniform float uSeed;\nuniform vec2 uDimensions;\n\nuniform vec4 uInputSize;\n\nconst float SQRT_2 = 1.414213;\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 Overlay(vec3 src, vec3 dst)\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\n\nvoid main()\n{\n    finalColor = texture(uTexture, vTextureCoord);\n    vec3 color = finalColor.rgb;\n\n    if (uSepia > 0.0)\n    {\n        float gray = (color.x + color.y + color.z) / 3.0;\n        vec3 grayscale = vec3(gray);\n\n        color = Overlay(SEPIA_RGB, grayscale);\n\n        color = grayscale + uSepia * (color - grayscale);\n    }\n\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions.xy;\n\n    float vignette = uVignetting[0];\n    float vignetteAlpha = uVignetting[1];\n    float vignetteBlur = uVignetting[2];\n\n    if (vignette > 0.0)\n    {\n        float outter = SQRT_2 - vignette * SQRT_2;\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\n        dir.y *= uDimensions.y / uDimensions.x;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignetteBlur * SQRT_2), 0.0, 1.0);\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignetteAlpha);\n    }\n\n    float scratch = uScratch[0];\n    float scratchDensity = uScratch[1];\n    float scratchWidth = uScratch[2];\n\n    if (scratchDensity > uSeed && scratch != 0.0)\n    {\n        float phase = uSeed * 256.0;\n        float s = mod(floor(phase), 2.0);\n        float dist = 1.0 / scratchDensity;\n        float d = distance(coord, vec2(uSeed * dist, abs(s - uSeed * dist)));\n        if (d < uSeed * 0.6 + 0.4)\n        {\n            highp float period = scratchDensity * 10.0;\n\n            float xx = coord.x * period + phase;\n            float aa = abs(mod(xx, 0.5) * 4.0);\n            float bb = mod(floor(xx / 0.5), 2.0);\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n            float kk = 2.0 * period;\n            float dw = scratchWidth / uDimensions.x * (0.75 + uSeed);\n            float dh = dw * kk;\n\n            float tine = (yy - (2.0 - dh));\n\n            if (tine > 0.0) {\n                float _sign = sign(scratch);\n\n                tine = s * tine / period + scratch + 0.1;\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n                color.rgb *= tine;\n            }\n        }\n    }\n\n    float noise = uNoise[0];\n    float noiseSize = uNoise[1];\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + uSeed * 512.0, 1024.0 - uSeed * 512.0);\n        // float _noise = snoise(d) * 0.5;\n        float _noise = rand(pixelCoord * noiseSize * uSeed) - 0.5;\n        color += _noise * noise;\n    }\n\n    finalColor.rgb = color;\n}";

// node_modules/pixi-filters/lib/old-film/old-film2.mjs
var source25 = "struct OldFilmUniforms {\n    uSepia: f32,\n    uNoise: vec2<f32>,\n    uScratch: vec3<f32>,\n    uVignetting: vec3<f32>,\n    uSeed: f32,\n    uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> oldFilmUniforms : OldFilmUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  if (oldFilmUniforms.uSepia > 0.)\n  {\n    color = vec4<f32>(sepia(color.rgb), color.a);\n  }\n\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / oldFilmUniforms.uDimensions;\n\n  if (oldFilmUniforms.uVignetting[0] > 0.)\n  {\n    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);\n  }\n\n  let uScratch = oldFilmUniforms.uScratch; \n\n  if (uScratch[1] > oldFilmUniforms.uSeed && uScratch[0] != 0.)\n  {\n    color = vec4<f32>(scratch(color.rgb, coord), color.a);\n  }\n\n  let uNoise = oldFilmUniforms.uNoise;\n\n  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\n  {\n    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);\n  }\n\n  return color;\n}\n\nconst SQRT_2: f32 = 1.414213;\nconst SEPIA_RGB: vec3<f32> = vec3<f32>(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfn modulo(x: f32, y: f32) -> f32\n{\n  return x - y * floor(x/y);\n}\n\nfn rand(co: vec2<f32>) -> f32\n{\n  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\n}\n\nfn overlay(src: vec3<f32>, dst: vec3<f32>) -> vec3<f32>\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n\n    return vec3<f32>(\n      select((1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (2.0 * src.x * dst.x), (dst.x <= 0.5)), \n      select((1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (2.0 * src.y * dst.y), (dst.y <= 0.5)),\n      select((1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)), (2.0 * src.z * dst.z), (dst.z <= 0.5))\n    );\n}\n\nfn sepia(co: vec3<f32>) -> vec3<f32>\n{\n  let gray: f32 = (co.x + co.y + co.z) / 3.0;\n  let grayscale: vec3<f32> = vec3<f32>(gray);\n  let color = overlay(SEPIA_RGB, grayscale);\n  return grayscale + oldFilmUniforms.uSepia * (color - grayscale);\n}\n\nfn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32\n{\n  let uVignetting = oldFilmUniforms.uVignetting;\n  let uDimensions = oldFilmUniforms.uDimensions;\n  \n  let outter: f32 = SQRT_2 - uVignetting[0] * SQRT_2;\n  var dir: vec2<f32> = vec2<f32>(vec2<f32>(0.5) - coord);\n  dir.y *= uDimensions.y / uDimensions.x;\n  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignetting[2] * SQRT_2), 0.0, 1.0);\n  return darker + (1.0 - darker) * (1.0 - uVignetting[1]);\n}\n\nfn scratch(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>\n{\n  var color = co;\n  let uScratch = oldFilmUniforms.uScratch;\n  let uSeed = oldFilmUniforms.uSeed;\n  let uDimensions = oldFilmUniforms.uDimensions;\n\n  let phase: f32 = uSeed * 256.0;\n  let s: f32 = modulo(floor(phase), 2.0);\n  let dist: f32 = 1.0 / uScratch[1];\n  let d: f32 = distance(coord, vec2<f32>(uSeed * dist, abs(s - uSeed * dist)));\n\n  if (d < uSeed * 0.6 + 0.4)\n  {\n    let period: f32 = uScratch[1] * 10.0;\n\n    let xx: f32 = coord.x * period + phase;\n    let aa: f32 = abs(modulo(xx, 0.5) * 4.0);\n    let bb: f32 = modulo(floor(xx / 0.5), 2.0);\n    let yy: f32 = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n    let kk: f32 = 2.0 * period;\n    let dw: f32 = uScratch[2] / uDimensions.x * (0.75 + uSeed);\n    let dh: f32 = dw * kk;\n\n    var tine: f32 = (yy - (2.0 - dh));\n\n    if (tine > 0.0) {\n        let _sign: f32 = sign(uScratch[0]);\n\n        tine = s * tine / period + uScratch[0] + 0.1;\n        tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n        color *= tine;\n    }\n  }\n\n  return color;\n}\n\nfn noise(coord: vec2<f32>) -> f32\n{\n  let uNoise = oldFilmUniforms.uNoise;\n  let uSeed = oldFilmUniforms.uSeed;\n\n  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;\n  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\n  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\n  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\n}";

// node_modules/pixi-filters/lib/old-film/OldFilmFilter.mjs
var __defProp25 = Object.defineProperty;
var __defNormalProp25 = (obj, key, value) => key in obj ? __defProp25(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField25 = (obj, key, value) => {
  __defNormalProp25(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _OldFilmFilter = class _OldFilmFilter2 extends Filter {
  /**
   * @param options - Options for the OldFilmFilter constructor.
   */
  constructor(options) {
    options = { ..._OldFilmFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source25,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment26,
      name: "old-film-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        oldFilmUniforms: {
          uSepia: { value: options.sepia, type: "f32" },
          uNoise: { value: new Float32Array(2), type: "vec2<f32>" },
          uScratch: { value: new Float32Array(3), type: "vec3<f32>" },
          uVignetting: { value: new Float32Array(3), type: "vec3<f32>" },
          uSeed: { value: options.seed, type: "f32" },
          uDimensions: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    });
    __publicField25(this, "uniforms");
    __publicField25(this, "seed");
    this.uniforms = this.resources.oldFilmUniforms.uniforms;
    Object.assign(this, options);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    this.uniforms.uDimensions[0] = input.frame.width;
    this.uniforms.uDimensions[1] = input.frame.height;
    this.uniforms.uSeed = this.seed;
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * The amount of saturation of sepia effect,
   * a value of `1` is more saturation and closer to `0` is less, and a value of `0` produces no sepia effect
   * @default 0.3
   */
  get sepia() {
    return this.uniforms.uSepia;
  }
  set sepia(value) {
    this.uniforms.uSepia = value;
  }
  /**
   * Opacity/intensity of the noise effect between `0` and `1`
   * @default 0.3
   */
  get noise() {
    return this.uniforms.uNoise[0];
  }
  set noise(value) {
    this.uniforms.uNoise[0] = value;
  }
  /**
   * The size of the noise particles
   * @default 1
   */
  get noiseSize() {
    return this.uniforms.uNoise[1];
  }
  set noiseSize(value) {
    this.uniforms.uNoise[1] = value;
  }
  /**
   * How often scratches appear
   * @default 0.5
   */
  get scratch() {
    return this.uniforms.uScratch[0];
  }
  set scratch(value) {
    this.uniforms.uScratch[0] = value;
  }
  /**
   * The density of the number of scratches
   * @default 0.3
   */
  get scratchDensity() {
    return this.uniforms.uScratch[1];
  }
  set scratchDensity(value) {
    this.uniforms.uScratch[1] = value;
  }
  /**
   * The width of the scratches
   * @default 1
   */
  get scratchWidth() {
    return this.uniforms.uScratch[2];
  }
  set scratchWidth(value) {
    this.uniforms.uScratch[2] = value;
  }
  /**
   * The radius of the vignette effect, smaller values produces a smaller vignette
   * @default 0.3
   */
  get vignetting() {
    return this.uniforms.uVignetting[0];
  }
  set vignetting(value) {
    this.uniforms.uVignetting[0] = value;
  }
  /**
   * Amount of opacity on the vignette
   * @default 1
   */
  get vignettingAlpha() {
    return this.uniforms.uVignetting[1];
  }
  set vignettingAlpha(value) {
    this.uniforms.uVignetting[1] = value;
  }
  /**
   * Blur intensity of the vignette
   * @default 1
   */
  get vignettingBlur() {
    return this.uniforms.uVignetting[2];
  }
  set vignettingBlur(value) {
    this.uniforms.uVignetting[2] = value;
  }
};
__publicField25(_OldFilmFilter, "DEFAULT_OPTIONS", {
  sepia: 0.3,
  noise: 0.3,
  noiseSize: 1,
  scratch: 0.5,
  scratchDensity: 0.3,
  scratchWidth: 1,
  vignetting: 0.3,
  vignettingAlpha: 1,
  vignettingBlur: 0.3,
  seed: 0
});
var OldFilmFilter = _OldFilmFilter;

// node_modules/pixi-filters/lib/outline/outline.mjs
var fragment27 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uThickness;\nuniform vec3 uColor;\nuniform float uAlpha;\nuniform float uKnockout;\n\nuniform vec4 uInputClamp;\n\nconst float DOUBLE_PI = 2. * 3.14159265358979323846264;\nconst float ANGLE_STEP = ${ANGLE_STEP};\n\nfloat outlineMaxAlphaAtPos(vec2 pos) {\n    if (uThickness.x == 0. || uThickness.y == 0.) {\n        return 0.;\n    }\n\n    vec4 displacedColor;\n    vec2 displacedPos;\n    float maxAlpha = 0.;\n\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ANGLE_STEP) {\n        displacedPos.x = vTextureCoord.x + uThickness.x * cos(angle);\n        displacedPos.y = vTextureCoord.y + uThickness.y * sin(angle);\n        displacedColor = texture(uTexture, clamp(displacedPos, uInputClamp.xy, uInputClamp.zw));\n        maxAlpha = max(maxAlpha, displacedColor.a);\n    }\n\n    return maxAlpha;\n}\n\nvoid main(void) {\n    vec4 sourceColor = texture(uTexture, vTextureCoord);\n    vec4 contentColor = sourceColor * float(uKnockout < 0.5);\n    float outlineAlpha = uAlpha * outlineMaxAlphaAtPos(vTextureCoord.xy) * (1.-sourceColor.a);\n    vec4 outlineColor = vec4(vec3(uColor) * outlineAlpha, outlineAlpha);\n    finalColor = contentColor + outlineColor;\n}\n";

// node_modules/pixi-filters/lib/outline/outline2.mjs
var source26 = "struct OutlineUniforms {\n  uThickness:vec2<f32>,\n  uColor:vec3<f32>,\n  uAlpha:f32,\n  uAngleStep:f32,\n  uKnockout:f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> outlineUniforms : OutlineUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let sourceColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let contentColor: vec4<f32> = sourceColor * (1. - outlineUniforms.uKnockout);\n  \n  let outlineAlpha: f32 = outlineUniforms.uAlpha * outlineMaxAlphaAtPos(uv) * (1. - sourceColor.a);\n  let outlineColor: vec4<f32> = vec4<f32>(vec3<f32>(outlineUniforms.uColor) * outlineAlpha, outlineAlpha);\n  \n  return contentColor + outlineColor;\n}\n\nfn outlineMaxAlphaAtPos(uv: vec2<f32>) -> f32 {\n  let thickness = outlineUniforms.uThickness;\n\n  if (thickness.x == 0. || thickness.y == 0.) {\n    return 0.;\n  }\n  \n  let angleStep = outlineUniforms.uAngleStep;\n\n  var displacedColor: vec4<f32>;\n  var displacedPos: vec2<f32>;\n\n  var maxAlpha: f32 = 0.;\n  var displaced: vec2<f32>;\n  var curColor: vec4<f32>;\n\n  for (var angle = 0.; angle <= DOUBLE_PI; angle += angleStep)\n  {\n    displaced.x = uv.x + thickness.x * cos(angle);\n    displaced.y = uv.y + thickness.y * sin(angle);\n    curColor = textureSample(uTexture, uSampler, clamp(displaced, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n    maxAlpha = max(maxAlpha, curColor.a);\n  }\n\n  return maxAlpha;\n}\n\nconst DOUBLE_PI: f32 = 3.14159265358979323846264 * 2.;";

// node_modules/pixi-filters/lib/outline/OutlineFilter.mjs
var __defProp26 = Object.defineProperty;
var __defNormalProp26 = (obj, key, value) => key in obj ? __defProp26(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField26 = (obj, key, value) => {
  __defNormalProp26(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _OutlineFilter = class _OutlineFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (typeof options === "number") {
      deprecation("6.0.0", "OutlineFilter constructor params are now options object. See params: { thickness, color, quality, alpha, knockout }");
      options = { thickness: options };
      if (args[1] !== void 0)
        options.color = args[1];
      if (args[2] !== void 0)
        options.quality = args[2];
      if (args[3] !== void 0)
        options.alpha = args[3];
      if (args[4] !== void 0)
        options.knockout = args[4];
    }
    options = { ..._OutlineFilter2.DEFAULT_OPTIONS, ...options };
    const quality = options.quality ?? 0.1;
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source26,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment27.replace(/\$\{ANGLE_STEP\}/, _OutlineFilter2.getAngleStep(quality).toFixed(7)),
      name: "outline-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        outlineUniforms: {
          uThickness: { value: new Float32Array(2), type: "vec2<f32>" },
          uColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uAlpha: { value: options.alpha, type: "f32" },
          uAngleStep: { value: 0, type: "f32" },
          uKnockout: { value: options.knockout ? 1 : 0, type: "f32" }
        }
      }
    });
    __publicField26(this, "uniforms");
    __publicField26(this, "_thickness");
    __publicField26(this, "_quality");
    __publicField26(this, "_color");
    this.uniforms = this.resources.outlineUniforms.uniforms;
    this.uniforms.uAngleStep = _OutlineFilter2.getAngleStep(quality);
    this._color = new Color();
    this.color = options.color ?? 0;
    Object.assign(this, options);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    this.uniforms.uThickness[0] = this.thickness / input.source.width;
    this.uniforms.uThickness[1] = this.thickness / input.source.height;
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * Get the angleStep by quality
   * @param quality
   */
  static getAngleStep(quality) {
    return parseFloat((Math.PI * 2 / Math.max(
      quality * _OutlineFilter2.MAX_SAMPLES,
      _OutlineFilter2.MIN_SAMPLES
    )).toFixed(7));
  }
  /**
   * The thickness of the outline
   * @default 1
   */
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = this.padding = value;
  }
  /**
   * The color value of the ambient color
   * @example [1.0, 1.0, 1.0] = 0xffffff
   * @default 0x000000
   */
  get color() {
    return this._color.value;
  }
  set color(value) {
    this._color.setValue(value);
    const [r, g, b] = this._color.toArray();
    this.uniforms.uColor[0] = r;
    this.uniforms.uColor[1] = g;
    this.uniforms.uColor[2] = b;
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
  /**
   * The quality of the outline from `0` to `1`.
   * Using a higher quality setting will result in more accuracy but slower performance
   * @default 0.1
   */
  get quality() {
    return this._quality;
  }
  set quality(value) {
    this._quality = value;
    this.uniforms.uAngleStep = _OutlineFilter2.getAngleStep(value);
  }
  /**
   * Whether to only render outline, not the contents.
   * @default false
   */
  get knockout() {
    return this.uniforms.uKnockout === 1;
  }
  set knockout(value) {
    this.uniforms.uKnockout = value ? 1 : 0;
  }
};
__publicField26(_OutlineFilter, "DEFAULT_OPTIONS", {
  thickness: 1,
  color: 0,
  alpha: 1,
  quality: 0.1,
  knockout: false
});
__publicField26(_OutlineFilter, "MIN_SAMPLES", 1);
__publicField26(_OutlineFilter, "MAX_SAMPLES", 100);
var OutlineFilter = _OutlineFilter;

// node_modules/pixi-filters/lib/pixelate/pixelate2.mjs
var fragment28 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform vec2 uSize;\nuniform sampler2D uTexture;\nuniform vec4 uInputSize;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= uInputSize.xy;\n    coord += uInputSize.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= uInputSize.zw;\n    coord /= uInputSize.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 uSize)\n{\n	return floor( coord / uSize ) * uSize;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n    coord = pixelate(coord, uSize);\n    coord = unmapCoord(coord);\n    finalColor = texture(uTexture, coord);\n}\n";

// node_modules/pixi-filters/lib/pixelate/pixelate.mjs
var source27 = "struct PixelateUniforms {\n  uSize:vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> pixelateUniforms : PixelateUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n  let pixelSize: vec2<f32> = pixelateUniforms.uSize;\n  let coord: vec2<f32> = mapCoord(uv);\n\n  var pixCoord: vec2<f32> = pixelate(coord, pixelSize);\n  pixCoord = unmapCoord(pixCoord);\n\n  return textureSample(uTexture, uSampler, pixCoord);\n}\n\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n  var mappedCoord: vec2<f32> = coord;\n  mappedCoord *= gfu.uInputSize.xy;\n  mappedCoord += gfu.uOutputFrame.xy;\n  return mappedCoord;\n}\n\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n  var mappedCoord: vec2<f32> = coord;\n  mappedCoord -= gfu.uOutputFrame.xy;\n  mappedCoord /= gfu.uInputSize.xy;\n  return mappedCoord;\n}\n\nfn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\n{\n  return floor( coord / size ) * size;\n}\n\n";

// node_modules/pixi-filters/lib/pixelate/PixelateFilter.mjs
var PixelateFilter = class extends Filter {
  /**
   * @param {Point|Array<number>|number} [size=10] - Either the width/height of the size of the pixels, or square size
   */
  constructor(size = 10) {
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source27,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment28,
      name: "pixelate-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        pixelateUniforms: {
          uSize: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    });
    this.size = size;
  }
  /**
   * The size of the pixels
   * @default [10,10]
   */
  get size() {
    return this.resources.pixelateUniforms.uniforms.uSize;
  }
  set size(value) {
    if (value instanceof Point) {
      this.sizeX = value.x;
      this.sizeY = value.y;
    } else if (Array.isArray(value)) {
      this.resources.pixelateUniforms.uniforms.uSize = value;
    } else {
      this.sizeX = this.sizeY = value;
    }
  }
  /**
  * The size of the pixels on the `x` axis
  * @default 10
  */
  get sizeX() {
    return this.resources.pixelateUniforms.uniforms.uSize[0];
  }
  set sizeX(value) {
    this.resources.pixelateUniforms.uniforms.uSize[0] = value;
  }
  /**
  * The size of the pixels on the `y` axis
  * @default 10
  */
  get sizeY() {
    return this.resources.pixelateUniforms.uniforms.uSize[1];
  }
  set sizeY(value) {
    this.resources.pixelateUniforms.uniforms.uSize[1] = value;
  }
};

// node_modules/pixi-filters/lib/radial-blur/radial-blur.mjs
var fragment29 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uRadian;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform int uKernelSize;\n\nuniform vec4 uInputSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\nvoid main(void)\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        finalColor = color;\n        return;\n    }\n\n    float aspect = uInputSize.y / uInputSize.x;\n    vec2 center = uCenter.xy / uInputSize.xy;\n    float gradient = uRadius / uInputSize.x * 0.3;\n    float radius = uRadius / uInputSize.x - gradient * 0.5;\n    int k = uKernelSize - 1;\n\n    vec2 coord = vTextureCoord;\n    vec2 dir = vec2(center - coord);\n    float dist = length(vec2(dir.x, dir.y * aspect));\n\n    float radianStep = uRadian;\n    if (radius >= 0.0 && dist > radius) {\n        float delta = dist - radius;\n        float gap = gradient;\n        float scale = 1.0 - abs(delta / gap);\n        if (scale <= 0.0) {\n            finalColor = color;\n            return;\n        }\n        radianStep *= scale;\n    }\n    radianStep /= float(k);\n\n    float s = sin(radianStep);\n    float c = cos(radianStep);\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n\n        coord -= center;\n        coord.y *= aspect;\n        coord = rotationMatrix * coord;\n        coord.y /= aspect;\n        coord += center;\n\n        vec4 sample = texture(uTexture, coord);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample;\n    }\n\n    finalColor = color / float(uKernelSize);\n}\n";

// node_modules/pixi-filters/lib/radial-blur/radial-blur2.mjs
var source28 = "struct RadialBlurUniforms {\n  uRadian: f32,\n  uCenter: vec2<f32>,\n  uKernelSize: f32,\n  uRadius: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> radialBlurUniforms : RadialBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uRadian = radialBlurUniforms.uRadian;\n  let uCenter = radialBlurUniforms.uCenter;\n  let uKernelSize = radialBlurUniforms.uKernelSize;\n  let uRadius = radialBlurUniforms.uRadius;\n  \n  var returnColorOnly = false;\n\n  if (uKernelSize == 0)\n  {\n    returnColorOnly = true;\n  }\n\n  let aspect: f32 = gfu.uInputSize.y / gfu.uInputSize.x;\n  let center: vec2<f32> = uCenter.xy / gfu.uInputSize.xy;\n  let gradient: f32 = uRadius / gfu.uInputSize.x * 0.3;\n  let radius: f32 = uRadius / gfu.uInputSize.x - gradient * 0.5;\n  let k: i32 = i32(uKernelSize - 1);\n\n  var coord: vec2<f32> = uv;\n  let dir: vec2<f32> = vec2<f32>(center - coord);\n  let dist: f32 = length(vec2<f32>(dir.x, dir.y * aspect));\n\n  var radianStep: f32 = uRadian;\n  \n  if (radius >= 0.0 && dist > radius)\n  {\n    let delta: f32 = dist - radius;\n    let gap: f32 = gradient;\n    let scale: f32 = 1.0 - abs(delta / gap);\n    if (scale <= 0.0) {\n      returnColorOnly = true;\n    }\n    radianStep *= scale;\n  }\n\n  radianStep /= f32(k);\n\n  let s: f32 = sin(radianStep);\n  let c: f32 = cos(radianStep);\n  let rotationMatrix: mat2x2<f32> = mat2x2<f32>(vec2<f32>(c, -s), vec2<f32>(s, c));\n  \n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let baseColor = vec4<f32>(color);\n\n  let minK: i32 = min(i32(uKernelSize) - 1, MAX_KERNEL_SIZE - 1);\n\n  for(var i: i32 = 0; i < minK; i += 1) \n  {\n    coord -= center;\n    coord.y *= aspect;\n    coord = rotationMatrix * coord;\n    coord.y /= aspect;\n    coord += center;\n    let sample: vec4<f32> = textureSample(uTexture, uSampler, coord);\n    // switch to pre-multiplied alpha to correctly blur transparent images\n    // sample.rgb *= sample.a;\n    color += sample;\n  }\n\n  return select(color / f32(uKernelSize), baseColor, returnColorOnly);\n}\n\nconst MAX_KERNEL_SIZE: i32 = 2048;";

// node_modules/pixi-filters/lib/radial-blur/RadialBlurFilter.mjs
var __defProp27 = Object.defineProperty;
var __defNormalProp27 = (obj, key, value) => key in obj ? __defProp27(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField27 = (obj, key, value) => {
  __defNormalProp27(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _RadialBlurFilter = class _RadialBlurFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (typeof options === "number") {
      deprecation("6.0.0", "RadialBlurFilter constructor params are now options object. See params: { angle, center, kernelSize, radius }");
      options = { angle: options };
      if (args[1]) {
        const x = "x" in args[1] ? args[1].x : args[1][0];
        const y = "y" in args[1] ? args[1].y : args[1][1];
        options.center = { x, y };
      }
      if (args[2])
        options.kernelSize = args[2];
      if (args[3])
        options.radius = args[3];
    }
    options = { ..._RadialBlurFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source28,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment29,
      name: "radial-blur-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        radialBlurUniforms: {
          uRadian: { value: 0, type: "f32" },
          uCenter: { value: options.center, type: "vec2<f32>" },
          uKernelSize: { value: options.kernelSize, type: "i32" },
          uRadius: { value: options.radius, type: "f32" }
        }
      }
    });
    __publicField27(this, "uniforms");
    __publicField27(this, "_angle");
    __publicField27(this, "_kernelSize");
    this.uniforms = this.resources.radialBlurUniforms.uniforms;
    Object.assign(this, options);
  }
  _updateKernelSize() {
    this.uniforms.uKernelSize = this._angle !== 0 ? this.kernelSize : 0;
  }
  /**
   * Sets the angle in degrees of the motion for blur effect.
   * @default 0
   */
  get angle() {
    return this._angle;
  }
  set angle(value) {
    this._angle = value;
    this.uniforms.uRadian = value * Math.PI / 180;
    this._updateKernelSize();
  }
  /**
   * The `x` and `y` offset coordinates to change the position of the center of the circle of effect.
   * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types
   * once defined in the constructor
   * @default {x:0,y:0}
   */
  get center() {
    return this.uniforms.uCenter;
  }
  set center(value) {
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this.uniforms.uCenter = value;
  }
  /**
   * Sets the velocity of the motion for blur effect on the `x` axis
   * @default 0
   */
  get centerX() {
    return this.center.x;
  }
  set centerX(value) {
    this.center.x = value;
  }
  /**
   * Sets the velocity of the motion for blur effect on the `x` axis
   * @default 0
   */
  get centerY() {
    return this.center.y;
  }
  set centerY(value) {
    this.center.y = value;
  }
  /**
   * The kernelSize of the blur filter. Must be odd number >= 3
   * @default 5
   */
  get kernelSize() {
    return this._kernelSize;
  }
  set kernelSize(value) {
    this._kernelSize = value;
    this._updateKernelSize();
  }
  /**
   * The maximum size of the blur radius, less than `0` equates to infinity
   * @default -1
   */
  get radius() {
    return this.uniforms.uRadius;
  }
  set radius(value) {
    this.uniforms.uRadius = value < 0 || value === Infinity ? -1 : value;
  }
};
__publicField27(_RadialBlurFilter, "DEFAULT_OPTIONS", {
  angle: 0,
  center: { x: 0, y: 0 },
  kernelSize: 5,
  radius: -1
});
var RadialBlurFilter = _RadialBlurFilter;

// node_modules/pixi-filters/lib/reflection/reflection.mjs
var fragment30 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uMirror;\nuniform float uBoundary;\nuniform vec2 uAmplitude;\nuniform vec2 uWavelength;\nuniform vec2 uAlpha;\nuniform float uTime;\nuniform vec2 uDimensions;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;\n    vec2 coord = pixelCoord / uDimensions;\n\n    if (coord.y < uBoundary) {\n        finalColor = texture(uTexture, vTextureCoord);\n        return;\n    }\n\n    float k = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);\n    float areaY = uBoundary * uDimensions.y / uInputSize.y;\n    float v = areaY + areaY - vTextureCoord.y;\n    float y = uMirror > 0.5 ? v : vTextureCoord.y;\n\n    float _amplitude = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / uInputSize.x;\n    float _waveLength = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / uInputSize.y;\n    float _alpha = (uAlpha.y - uAlpha.x) * k + uAlpha.x;\n\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - uTime) * _amplitude;\n    x = clamp(x, uInputClamp.x, uInputClamp.z);\n\n    vec4 color = texture(uTexture, vec2(x, y));\n\n    finalColor = color * _alpha;\n}\n";

// node_modules/pixi-filters/lib/reflection/reflection2.mjs
var source29 = "struct ReflectionUniforms {\n  uMirror: f32,\n  uBoundary: f32,\n  uAmplitude: vec2<f32>,\n  uWavelength: vec2<f32>,\n  uAlpha: vec2<f32>,\n  uTime: f32,\n  uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> reflectionUniforms : ReflectionUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uDimensions: vec2<f32> = reflectionUniforms.uDimensions;\n  let uBoundary: f32 = reflectionUniforms.uBoundary;\n  let uMirror: bool = reflectionUniforms.uMirror > 0.5;\n  let uAmplitude: vec2<f32> = reflectionUniforms.uAmplitude;\n  let uWavelength: vec2<f32> = reflectionUniforms.uWavelength;\n  let uAlpha: vec2<f32> = reflectionUniforms.uAlpha;\n  let uTime: f32 = reflectionUniforms.uTime;\n\n  let pixelCoord: vec2<f32> = uv * gfu.uInputSize.xy;\n  let coord: vec2<f32> = pixelCoord /uDimensions;\n  var returnColorOnly: bool = false;\n\n  if (coord.y < uBoundary) {\n    returnColorOnly = true;\n  }\n\n  let k: f32 = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);\n  let areaY: f32 = uBoundary * uDimensions.y / gfu.uInputSize.y;\n  let v: f32 = areaY + areaY - uv.y;\n  let y: f32 = select(uv.y, v, uMirror);\n\n  let amplitude: f32 = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / gfu.uInputSize.x;\n  let waveLength: f32 = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / gfu.uInputSize.y;\n  let alpha: f32 = select((uAlpha.y - uAlpha.x) * k + uAlpha.x, 1., returnColorOnly);\n\n  var x: f32 = uv.x + cos(v * 6.28 / waveLength - uTime) * amplitude;\n  x = clamp(x, gfu.uInputClamp.x, gfu.uInputClamp.z);\n  \n  return textureSample(uTexture, uSampler, select(vec2<f32>(x, y), uv, returnColorOnly)) * alpha;\n}\n\nfn rand(co: vec2<f32>) -> f32 \n{\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}";

// node_modules/pixi-filters/lib/reflection/ReflectionFilter.mjs
var __defProp28 = Object.defineProperty;
var __defNormalProp28 = (obj, key, value) => key in obj ? __defProp28(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField28 = (obj, key, value) => {
  __defNormalProp28(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _ReflectionFilter = class _ReflectionFilter2 extends Filter {
  /**
   * @param options - Options for the ReflectionFilter constructor.
   */
  constructor(options) {
    options = { ..._ReflectionFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source29,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment30,
      name: "reflection-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        reflectionUniforms: {
          uMirror: { value: options.mirror ? 1 : 0, type: "f32" },
          uBoundary: { value: options.boundary, type: "f32" },
          uAmplitude: { value: options.amplitude, type: "vec2<f32>" },
          uWavelength: { value: options.waveLength, type: "vec2<f32>" },
          uAlpha: { value: options.alpha, type: "vec2<f32>" },
          uTime: { value: options.time, type: "f32" },
          uDimensions: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    });
    __publicField28(this, "uniforms");
    __publicField28(this, "time", 0);
    this.uniforms = this.resources.reflectionUniforms.uniforms;
    Object.assign(this, options);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    this.uniforms.uDimensions[0] = input.frame.width;
    this.uniforms.uDimensions[1] = input.frame.height;
    this.uniforms.uTime = this.time;
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * `true` to reflect the image, `false` for waves-only
   * @default true
   */
  get mirror() {
    return this.uniforms.uMirror > 0.5;
  }
  set mirror(value) {
    this.uniforms.uMirror = value ? 1 : 0;
  }
  /**
   * Vertical position of the reflection point, default is 50% (middle)
   * smaller numbers produce a larger reflection, larger numbers produce a smaller reflection.
   * @default 0.5
   */
  get boundary() {
    return this.uniforms.uBoundary;
  }
  set boundary(value) {
    this.uniforms.uBoundary = value;
  }
  /**
   * Starting and ending amplitude of waves
   * @default [0,20]
   */
  get amplitude() {
    return Array.from(this.uniforms.uAmplitude);
  }
  set amplitude(value) {
    this.uniforms.uAmplitude[0] = value[0];
    this.uniforms.uAmplitude[1] = value[1];
  }
  /**
   * Starting amplitude of waves
   * @default 0
   */
  get amplitudeStart() {
    return this.uniforms.uAmplitude[0];
  }
  set amplitudeStart(value) {
    this.uniforms.uAmplitude[0] = value;
  }
  /**
   * Starting amplitude of waves
   * @default 20
   */
  get amplitudeEnd() {
    return this.uniforms.uAmplitude[1];
  }
  set amplitudeEnd(value) {
    this.uniforms.uAmplitude[1] = value;
  }
  /**
   * Starting and ending length of waves
   * @default [30,100]
   */
  get waveLength() {
    return Array.from(this.uniforms.uWavelength);
  }
  set waveLength(value) {
    this.uniforms.uWavelength[0] = value[0];
    this.uniforms.uWavelength[1] = value[1];
  }
  /**
   * Starting wavelength of waves
   * @default 30
   */
  get wavelengthStart() {
    return this.uniforms.uWavelength[0];
  }
  set wavelengthStart(value) {
    this.uniforms.uWavelength[0] = value;
  }
  /**
   * Starting wavelength of waves
   * @default 100
   */
  get wavelengthEnd() {
    return this.uniforms.uWavelength[1];
  }
  set wavelengthEnd(value) {
    this.uniforms.uWavelength[1] = value;
  }
  /**
   * Starting and ending alpha values
   * @default [1,1]
   */
  get alpha() {
    return Array.from(this.uniforms.uAlpha);
  }
  set alpha(value) {
    this.uniforms.uAlpha[0] = value[0];
    this.uniforms.uAlpha[1] = value[1];
  }
  /**
   * Starting wavelength of waves
   * @default 1
   */
  get alphaStart() {
    return this.uniforms.uAlpha[0];
  }
  set alphaStart(value) {
    this.uniforms.uAlpha[0] = value;
  }
  /**
   * Starting wavelength of waves
   * @default 1
   */
  get alphaEnd() {
    return this.uniforms.uAlpha[1];
  }
  set alphaEnd(value) {
    this.uniforms.uAlpha[1] = value;
  }
};
__publicField28(_ReflectionFilter, "DEFAULT_OPTIONS", {
  mirror: true,
  boundary: 0.5,
  amplitude: [0, 20],
  waveLength: [30, 100],
  alpha: [1, 1],
  time: 0
});
var ReflectionFilter = _ReflectionFilter;

// node_modules/pixi-filters/lib/rgb-split/rgb-split2.mjs
var fragment31 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec4 uInputSize;\nuniform vec2 uRed;\nuniform vec2 uGreen;\nuniform vec2 uBlue;\n\nvoid main(void)\n{\n   float r = texture(uTexture, vTextureCoord + uRed/uInputSize.xy).r;\n   float g = texture(uTexture, vTextureCoord + uGreen/uInputSize.xy).g;\n   float b = texture(uTexture, vTextureCoord + uBlue/uInputSize.xy).b;\n   float a = texture(uTexture, vTextureCoord).a;\n   finalColor = vec4(r, g, b, a);\n}\n";

// node_modules/pixi-filters/lib/rgb-split/rgb-split.mjs
var source30 = "struct RgbSplitUniforms {\n    uRed: vec2<f32>,\n    uGreen: vec2<f32>,\n    uBlue: vec3<f32>,\n};\n\nstruct GlobalFilterUniforms {\n    uInputSize:vec4<f32>,\n    uInputPixel:vec4<f32>,\n    uInputClamp:vec4<f32>,\n    uOutputFrame:vec4<f32>,\n    uGlobalFrame:vec4<f32>,\n    uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> rgbSplitUniforms : RgbSplitUniforms;\n\n@fragment\nfn mainFragment(\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n    let r = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uRed.x / gfu.uInputSize.x, rgbSplitUniforms.uRed.y / gfu.uInputSize.y)).r;\n    let g = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uGreen.x / gfu.uInputSize.x, rgbSplitUniforms.uGreen.y / gfu.uInputSize.y)).g;\n    let b = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uBlue.x / gfu.uInputSize.x, rgbSplitUniforms.uBlue.y / gfu.uInputSize.y)).b;\n    let a = textureSample(uTexture, uSampler, uv).a;\n    return vec4<f32>(r, g, b, a);\n}\n";

// node_modules/pixi-filters/lib/rgb-split/RGBSplitFilter.mjs
var __defProp29 = Object.defineProperty;
var __defNormalProp29 = (obj, key, value) => key in obj ? __defProp29(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField29 = (obj, key, value) => {
  __defNormalProp29(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _RGBSplitFilter = class _RGBSplitFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (Array.isArray(options) || "x" in options && "y" in options) {
      deprecation("6.0.0", "RGBSplitFilter constructor params are now options object. See params: { red, green, blue }");
      options = { red: options };
      if (args[1] !== void 0)
        options.green = args[1];
      if (args[2] !== void 0)
        options.blue = args[2];
    }
    options = { ..._RGBSplitFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source30,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment31,
      name: "rgb-split-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        rgbSplitUniforms: {
          uRed: { value: options.red, type: "vec2<f32>" },
          uGreen: { value: options.green, type: "vec2<f32>" },
          uBlue: { value: options.blue, type: "vec2<f32>" }
        }
      }
    });
    __publicField29(this, "uniforms");
    this.uniforms = this.resources.rgbSplitUniforms.uniforms;
    Object.assign(this, options);
  }
  /**
   * Red channel offset.
   * @default {x:-10,y:0}
   */
  get red() {
    return this.uniforms.uRed;
  }
  set red(value) {
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this.uniforms.uRed = value;
  }
  /**
   * Amount of x-axis offset for the red channel.
   * @default -10
   */
  get redX() {
    return this.red.x;
  }
  set redX(value) {
    this.red.x = value;
  }
  /**
   * Amount of y-axis offset for the red channel.
   * @default 0
   */
  get redY() {
    return this.red.y;
  }
  set redY(value) {
    this.red.y = value;
  }
  /**
   * Green channel offset.
   * @default {x:0,y:10}
   */
  get green() {
    return this.uniforms.uGreen;
  }
  set green(value) {
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this.uniforms.uGreen = value;
  }
  /**
   * Amount of x-axis offset for the green channel.
   * @default 0
   */
  get greenX() {
    return this.green.x;
  }
  set greenX(value) {
    this.green.x = value;
  }
  /**
   * Amount of y-axis offset for the green channel.
   * @default 10
   */
  get greenY() {
    return this.green.y;
  }
  set greenY(value) {
    this.green.y = value;
  }
  /**
   * Blue channel offset.
   * @default {x:0,y:0}
   */
  get blue() {
    return this.uniforms.uBlue;
  }
  set blue(value) {
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this.uniforms.uBlue = value;
  }
  /**
   * Amount of x-axis offset for the blue channel.
   * @default 0
   */
  get blueX() {
    return this.blue.x;
  }
  set blueX(value) {
    this.blue.x = value;
  }
  /**
   * Amount of y-axis offset for the blue channel.
   * @default 0
   */
  get blueY() {
    return this.blue.y;
  }
  set blueY(value) {
    this.blue.y = value;
  }
};
__publicField29(_RGBSplitFilter, "DEFAULT_OPTIONS", {
  red: { x: -10, y: 0 },
  green: { x: 0, y: 10 },
  blue: { x: 0, y: 0 }
});
var RGBSplitFilter = _RGBSplitFilter;

// node_modules/pixi-filters/lib/shockwave/shockwave2.mjs
var fragment32 = "\nprecision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uCenter;\nuniform float uTime;\nuniform float uSpeed;\nuniform vec4 uWave;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float uAmplitude = uWave[0];\n    float uWavelength = uWave[1];\n    float uBrightness = uWave[2];\n    float uRadius = uWave[3];\n\n    float halfWavelength = uWavelength * 0.5 / uInputSize.x;\n    float maxRadius = uRadius / uInputSize.x;\n    float currentRadius = uTime * uSpeed / uInputSize.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            finalColor = texture(uTexture, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - uCenter / uInputSize.xy);\n    dir.y *= uInputSize.y / uInputSize.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        finalColor = texture(uTexture, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\n\n    vec2 offset = diffUV * powDiff / uInputSize.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\n    vec4 color = texture(uTexture, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // finalColor = texture(uTexture, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (uBrightness - 1.0) * p * fade;\n\n    finalColor = color;\n}\n";

// node_modules/pixi-filters/lib/shockwave/shockwave.mjs
var source31 = "\nstruct ShockWaveUniforms {\n    uTime: f32,\n    uOffset: vec2<f32>,\n    uSpeed: f32,\n    uWave: vec4<f32>,\n};\n\nstruct GlobalFilterUniforms {\n    uInputSize:vec4<f32>,\n    uInputPixel:vec4<f32>,\n    uInputClamp:vec4<f32>,\n    uOutputFrame:vec4<f32>,\n    uGlobalFrame:vec4<f32>,\n    uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> shockwaveUniforms : ShockWaveUniforms;\n\n@fragment\nfn mainFragment(\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n\n    let uTime = shockwaveUniforms.uTime;\n    let uOffset = shockwaveUniforms.uOffset;\n    let uSpeed = shockwaveUniforms.uSpeed;\n    let uAmplitude = shockwaveUniforms.uWave[0];\n    let uWavelength = shockwaveUniforms.uWave[1];\n    let uBrightness = shockwaveUniforms.uWave[2];\n    let uRadius = shockwaveUniforms.uWave[3];\n    let halfWavelength: f32 = uWavelength * 0.5 / gfu.uInputSize.x;\n    let maxRadius: f32 = uRadius / gfu.uInputSize.x;\n    let currentRadius: f32 = uTime * uSpeed / gfu.uInputSize.x;\n    var fade: f32 = 1.0;\n    var returnColorOnly: bool = false;\n    \n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            returnColorOnly = true;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n    var dir: vec2<f32> = vec2<f32>(uv - uOffset / gfu.uInputSize.xy);\n    dir.y *= gfu.uInputSize.y / gfu.uInputSize.x;\n\n    let dist:f32 = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        returnColorOnly = true;\n    }\n\n    let diffUV: vec2<f32> = normalize(dir);\n    let diff: f32 = (dist - currentRadius) / halfWavelength;\n    let p: f32 = 1.0 - pow(abs(diff), 2.0);\n    let powDiff: f32 = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\n    let offset: vec2<f32> = diffUV * powDiff / gfu.uInputSize.xy;\n    // Do clamp :\n    let coord: vec2<f32> = uv + offset;\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);\n\n    var clampedColor: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);\n    \n    if (boolVec2(coord, clampedCoord)) \n    {\n        clampedColor *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n    // No clamp :\n    var finalColor = clampedColor;\n\n    return select(finalColor, textureSample(uTexture, uSampler, uv), returnColorOnly);\n}\n\nfn boolVec2(x: vec2<f32>, y: vec2<f32>) -> bool\n{\n    if (x.x == y.x && x.y == y.y)\n    {\n        return true;\n    }\n    \n    return false;\n}\n\nconst PI: f32 = 3.14159265358979323846264;\n";

// node_modules/pixi-filters/lib/shockwave/ShockwaveFilter.mjs
var __defProp30 = Object.defineProperty;
var __defNormalProp30 = (obj, key, value) => key in obj ? __defProp30(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField30 = (obj, key, value) => {
  __defNormalProp30(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _ShockwaveFilter = class _ShockwaveFilter2 extends Filter {
  /** @ignore */
  // eslint-disable-next-line max-len
  constructor(...args) {
    let options = args[0] ?? {};
    if (Array.isArray(options) || "x" in options && "y" in options) {
      deprecation("6.0.0", "ShockwaveFilter constructor params are now options object. See params: { center, speed, amplitude, wavelength, brightness, radius, time }");
      options = { center: options, ...args[1] };
      if (args[2] !== void 0)
        options.time = args[2];
    }
    options = { ..._ShockwaveFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source31,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment32,
      name: "shockwave-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        shockwaveUniforms: {
          uTime: { value: options.time, type: "f32" },
          uCenter: { value: options.center, type: "vec2<f32>" },
          uSpeed: { value: options.speed, type: "f32" },
          uWave: { value: new Float32Array(4), type: "vec4<f32>" }
        }
      }
    });
    __publicField30(this, "uniforms");
    __publicField30(this, "time");
    this.time = 0;
    this.uniforms = this.resources.shockwaveUniforms.uniforms;
    Object.assign(this, options);
  }
  apply(filterManager, input, output, clearMode) {
    this.uniforms.uTime = this.time;
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * The `x` and `y` center coordinates to change the position of the center of the circle of effect.
   * @default [0,0]
   */
  get center() {
    return this.uniforms.uCenter;
  }
  set center(value) {
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this.uniforms.uCenter = value;
  }
  /**
   * Sets the center of the effect in normalized screen coords on the `x` axis
   * @default 0
   */
  get centerX() {
    return this.uniforms.uCenter.x;
  }
  set centerX(value) {
    this.uniforms.uCenter.x = value;
  }
  /**
   * Sets the center of the effect in normalized screen coords on the `y` axis
   * @default 0
   */
  get centerY() {
    return this.uniforms.uCenter.y;
  }
  set centerY(value) {
    this.uniforms.uCenter.y = value;
  }
  /**
   * The speed about the shockwave ripples out. The unit is `pixel-per-second`
   * @default 500
   */
  get speed() {
    return this.uniforms.uSpeed;
  }
  set speed(value) {
    this.uniforms.uSpeed = value;
  }
  /**
   * The amplitude of the shockwave
   * @default 30
   */
  get amplitude() {
    return this.uniforms.uWave[0];
  }
  set amplitude(value) {
    this.uniforms.uWave[0] = value;
  }
  /**
   * The wavelength of the shockwave
   * @default 160
   */
  get wavelength() {
    return this.uniforms.uWave[1];
  }
  set wavelength(value) {
    this.uniforms.uWave[1] = value;
  }
  /**
   * The brightness of the shockwave
   * @default 1
   */
  get brightness() {
    return this.uniforms.uWave[2];
  }
  set brightness(value) {
    this.uniforms.uWave[2] = value;
  }
  /**
   * The maximum radius of shockwave. less than `0` means the max is an infinite distance
   * @default -1
   */
  get radius() {
    return this.uniforms.uWave[3];
  }
  set radius(value) {
    this.uniforms.uWave[3] = value;
  }
};
__publicField30(_ShockwaveFilter, "DEFAULT_OPTIONS", {
  /** The `x` and `y` center coordinates to change the position of the center of the circle of effect. */
  center: { x: 0, y: 0 },
  /** The speed about the shockwave ripples out. The unit is `pixel-per-second` */
  speed: 500,
  /** The amplitude of the shockwave */
  amplitude: 30,
  /** The wavelength of the shockwave */
  wavelength: 160,
  /** The brightness of the shockwave */
  brightness: 1,
  /** The maximum radius of shockwave. less than `0` means the max is an infinite distance */
  radius: -1
});
var ShockwaveFilter = _ShockwaveFilter;

// node_modules/pixi-filters/lib/simple-lightmap/simple-lightmap.mjs
var fragment33 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\nuniform vec3 uColor;\nuniform float uAlpha;\nuniform vec2 uDimensions;\n\nuniform vec4 uInputSize;\n\nvoid main() {\n    vec4 diffuseColor = texture(uTexture, vTextureCoord);\n    vec2 lightCoord = (vTextureCoord * uInputSize.xy) / uDimensions;\n    vec4 light = texture(uMapTexture, lightCoord);\n    vec3 ambient = uColor.rgb * uAlpha;\n    vec3 intensity = ambient + light.rgb;\n    vec3 color = diffuseColor.rgb * intensity;\n    finalColor = vec4(color, diffuseColor.a);\n}\n";

// node_modules/pixi-filters/lib/simple-lightmap/simple-lightmap2.mjs
var source32 = "struct SimpleLightmapUniforms {\n  uColor: vec3<f32>,\n  uAlpha: f32,\n  uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> simpleLightmapUniforms : SimpleLightmapUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n@group(1) @binding(2) var uMapSampler: sampler;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>,\n) -> @location(0) vec4<f32> {\n  let uColor = simpleLightmapUniforms.uColor;\n  let uAlpha = simpleLightmapUniforms.uAlpha;\n  let uDimensions = simpleLightmapUniforms.uDimensions;\n\n  let diffuseColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let lightCoord: vec2<f32> = (uv * gfu.uInputSize.xy) / simpleLightmapUniforms.uDimensions;\n  let light: vec4<f32> = textureSample(uMapTexture, uMapSampler, lightCoord);\n  let ambient: vec3<f32> = uColor * uAlpha;\n  let intensity: vec3<f32> = ambient + light.rgb;\n  let finalColor: vec3<f32> = diffuseColor.rgb * intensity;\n  return vec4<f32>(finalColor, diffuseColor.a);\n}";

// node_modules/pixi-filters/lib/simple-lightmap/SimpleLightmapFilter.mjs
var __defProp31 = Object.defineProperty;
var __defNormalProp31 = (obj, key, value) => key in obj ? __defProp31(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField31 = (obj, key, value) => {
  __defNormalProp31(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _SimpleLightmapFilter = class _SimpleLightmapFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (options instanceof Texture) {
      deprecation("6.0.0", "SimpleLightmapFilter constructor params are now options object. See params: { lightMap, color, alpha }");
      options = { lightMap: options };
      if (args[1] !== void 0)
        options.color = args[1];
      if (args[2] !== void 0)
        options.alpha = args[2];
    }
    options = { ..._SimpleLightmapFilter2.DEFAULT_OPTIONS, ...options };
    if (!options.lightMap)
      throw Error("No light map texture source was provided to SimpleLightmapFilter");
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source32,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment33,
      name: "simple-lightmap-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        simpleLightmapUniforms: {
          uColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uAlpha: { value: options.alpha, type: "f32" },
          uDimensions: { value: new Float32Array(2), type: "vec2<f32>" }
        },
        uMapTexture: options.lightMap.source,
        uMapSampler: options.lightMap.source.style
      }
    });
    __publicField31(this, "uniforms");
    __publicField31(this, "_color");
    __publicField31(this, "_lightMap");
    this.uniforms = this.resources.simpleLightmapUniforms.uniforms;
    this._color = new Color();
    this.color = options.color ?? 0;
    Object.assign(this, options);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    this.uniforms.uDimensions[0] = input.frame.width;
    this.uniforms.uDimensions[1] = input.frame.height;
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /** A sprite where your lightmap is rendered */
  get lightMap() {
    return this._lightMap;
  }
  set lightMap(value) {
    this._lightMap = value;
    this.resources.uMapTexture = value.source;
    this.resources.uMapSampler = value.source.style;
  }
  /**
   * The color value of the ambient color
   * @example [1.0, 1.0, 1.0] = 0xffffff
   * @default 0x000000
   */
  get color() {
    return this._color.value;
  }
  set color(value) {
    this._color.setValue(value);
    const [r, g, b] = this._color.toArray();
    this.uniforms.uColor[0] = r;
    this.uniforms.uColor[1] = g;
    this.uniforms.uColor[2] = b;
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
};
__publicField31(_SimpleLightmapFilter, "DEFAULT_OPTIONS", {
  lightMap: Texture.WHITE,
  color: 0,
  alpha: 1
});
var SimpleLightmapFilter = _SimpleLightmapFilter;

// node_modules/pixi-filters/lib/simplex-noise/simplex.mjs
var fragment34 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uStrength;\nuniform float uNoiseScale;\nuniform float uOffsetX;\nuniform float uOffsetY;\nuniform float uOffsetZ;\nuniform float uStep;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\n//Noise from: https://www.shadertoy.com/view/4sc3z2\nconst vec3 MOD3 = vec3(.1031,.11369,.13787);\nvec3 hash33(vec3 p3)\n{\n	p3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n	vec3 i1 = e * (1.0 - e.zxy);\n	vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nvoid main(void)\n{\n    float noise = simplex_noise(\n                    vec3(vTextureCoord*uNoiseScale+vec2(uOffsetX, uOffsetY), uOffsetZ)\n                ) * 0.5 + 0.5;\n\n    noise += 2.0 * uStrength - 1.0;\n    noise = clamp(noise, 0.0, 1.0);\n\n    if (uStep > 0.0) {  //step > 0.5\n        noise = 1.0 - step(noise, uStep);\n    }\n\n    finalColor = texture(uTexture, vTextureCoord) * noise;\n}\n";

// node_modules/pixi-filters/lib/simplex-noise/simplex2.mjs
var source33 = "struct SimplexUniforms {\n  uStrength:f32,\n  uNoiseScale:f32,\n  uOffsetX:f32,\n  uOffsetY:f32,\n  uOffsetZ:f32,\n  uStep:f32\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> simplexUniforms : SimplexUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n  var noise: f32 = simplex_noise(vec3<f32>(uv * simplexUniforms.uNoiseScale + vec2<f32>(simplexUniforms.uOffsetX, simplexUniforms.uOffsetY), simplexUniforms.uOffsetZ)) * 0.5 + 0.5;\n	noise = noise + (2. * simplexUniforms.uStrength - 1.);\n	noise = clamp(noise, 0.0, 1.0);\n	if (simplexUniforms.uStep > 0.0) {\n		noise = 1. - step(noise, simplexUniforms.uStep);\n	}\n	return textureSample(uTexture, uSampler, uv) * noise;\n}\n\nconst MOD3: vec3<f32> = vec3<f32>(0.1031, 0.11369, 0.13787);\nfn hash33(p3: vec3<f32>) -> vec3<f32> {\n	var p3_var = p3;\n	p3_var = fract(p3_var * MOD3);\n	p3_var = p3_var + (dot(p3_var, p3_var.yxz + 19.19));\n	return -1. + 2. * fract(vec3<f32>((p3_var.x + p3_var.y) * p3_var.z, (p3_var.x + p3_var.z) * p3_var.y, (p3_var.y + p3_var.z) * p3_var.x));\n} \n\nfn simplex_noise(p: vec3<f32>) -> f32 {\n	let K1: f32 = 0.33333334;\n	let K2: f32 = 0.16666667;\n	let i: vec3<f32> = floor(p + (p.x + p.y + p.z) * K1);\n	let d0: vec3<f32> = p - (i - (i.x + i.y + i.z) * K2);\n	let e: vec3<f32> = step(vec3<f32>(0.), d0 - d0.yzx);\n	let i1: vec3<f32> = e * (1. - e.zxy);\n	let i2: vec3<f32> = 1. - e.zxy * (1. - e);\n	let d1: vec3<f32> = d0 - (i1 - 1. * K2);\n	let d2: vec3<f32> = d0 - (i2 - 2. * K2);\n	let d3: vec3<f32> = d0 - (1. - 3. * K2);\n	let h: vec4<f32> = max(vec4<f32>(0.6) - vec4<f32>(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), vec4<f32>(0.0));\n	let n: vec4<f32> = h * h * h * h * vec4<f32>(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.)));\n	return dot(vec4<f32>(31.316), n);\n} ";

// node_modules/pixi-filters/lib/simplex-noise/SimplexNoiseFilter.mjs
var __defProp32 = Object.defineProperty;
var __defNormalProp32 = (obj, key, value) => key in obj ? __defProp32(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField32 = (obj, key, value) => {
  __defNormalProp32(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _SimplexNoiseFilter = class _SimplexNoiseFilter2 extends Filter {
  /**
   * @param options - Options for the SimplexNoise constructor.
   */
  constructor(options) {
    options = { ..._SimplexNoiseFilter2.defaults, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source33,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment34,
      name: "simplex-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        simplexUniforms: {
          uStrength: { value: (options == null ? void 0 : options.strength) ?? 0, type: "f32" },
          uNoiseScale: { value: (options == null ? void 0 : options.noiseScale) ?? 0, type: "f32" },
          uOffsetX: { value: (options == null ? void 0 : options.offsetX) ?? 0, type: "f32" },
          uOffsetY: { value: (options == null ? void 0 : options.offsetY) ?? 0, type: "f32" },
          uOffsetZ: { value: (options == null ? void 0 : options.offsetZ) ?? 0, type: "f32" },
          uStep: { value: (options == null ? void 0 : options.step) ?? 0, type: "f32" }
        }
      }
    });
  }
  /**
   * Strength of the noise (color = (noiseMap + strength) * texture)
   * @default 0.5
   */
  get strength() {
    return this.resources.simplexUniforms.uniforms.uStrength;
  }
  set strength(value) {
    this.resources.simplexUniforms.uniforms.uStrength = value;
  }
  /**
   * Noise map scale.
   * @default 10
   */
  get noiseScale() {
    return this.resources.simplexUniforms.uniforms.uNoiseScale;
  }
  set noiseScale(value) {
    this.resources.simplexUniforms.uniforms.uNoiseScale = value;
  }
  /**
   * Horizontal offset for the noise map.
   * @default 0
   */
  get offsetX() {
    return this.resources.simplexUniforms.uniforms.uOffsetX;
  }
  set offsetX(value) {
    this.resources.simplexUniforms.uniforms.uOffsetX = value;
  }
  /**
   * Vertical offset for the noise map.
   * @default 0
   */
  get offsetY() {
    return this.resources.simplexUniforms.uniforms.uOffsetY;
  }
  set offsetY(value) {
    this.resources.simplexUniforms.uniforms.uOffsetY = value;
  }
  /**
   * Depth offset for the noise map.
   * @default 0
   */
  get offsetZ() {
    return this.resources.simplexUniforms.uniforms.uOffsetZ;
  }
  set offsetZ(value) {
    this.resources.simplexUniforms.uniforms.uOffsetZ = value;
  }
  /**
   * The threshold used with the step function to create a blocky effect in the noise pattern.
   * When this is greater than 0, the step function is used to compare the noise value to this threshold.
   * @default -1
   */
  get step() {
    return this.resources.simplexUniforms.uniforms.uStep;
  }
  set step(value) {
    this.resources.simplexUniforms.uniforms.uStep = value;
  }
};
__publicField32(_SimplexNoiseFilter, "defaults", {
  strength: 0.5,
  noiseScale: 10,
  offsetX: 0,
  offsetY: 0,
  offsetZ: 0,
  step: -1
});
var SimplexNoiseFilter = _SimplexNoiseFilter;

// node_modules/pixi-filters/lib/tilt-shift/tilt-shift.mjs
var fragment35 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uBlur;\nuniform vec2 uStart;\nuniform vec2 uEnd;\nuniform vec2 uDelta;\nuniform vec4 uInputSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float blur = uBlur[0];\n    float gradientBlur = uBlur[1];\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(uStart.y - uEnd.y, uEnd.x - uStart.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * uInputSize.xy - uStart, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture(uTexture, vTextureCoord + uDelta / uInputSize.xy * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    color /= total;\n    color.rgb /= color.a + 0.00001;\n\n    finalColor = color;\n}\n";

// node_modules/pixi-filters/lib/tilt-shift/tilt-shift2.mjs
var source34 = "struct TiltShiftUniforms {\n  uBlur: vec2<f32>,\n  uStart: vec2<f32>,\n  uEnd: vec2<f32>,\n  uDelta: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> tiltShiftUniforms : TiltShiftUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uBlur = tiltShiftUniforms.uBlur[0];\n  let uBlurGradient = tiltShiftUniforms.uBlur[1];\n  let uStart = tiltShiftUniforms.uStart;\n  let uEnd = tiltShiftUniforms.uEnd;\n  let uDelta = tiltShiftUniforms.uDelta;\n\n  var color: vec4<f32> = vec4<f32>(0.0);\n  var total: f32 = 0.0;\n\n  let offset: f32 = random(position, vec3<f32>(12.9898, 78.233, 151.7182), 0.0);\n  let normal: vec2<f32> = normalize(vec2<f32>(uStart.y - uEnd.y, uEnd.x - uStart.x));\n  let radius: f32 = smoothstep(0.0, 1.0, abs(dot(uv * gfu.uInputSize.xy - uStart, normal)) / uBlurGradient) * uBlur;\n\n  for (var t: f32 = -30.0; t <= 30.0; t += 1.0)\n  {\n    var percent: f32 = (t + offset - 0.5) / 30.0;\n    var weight: f32 = 1.0 - abs(percent);\n    var sample: vec4<f32> = textureSample(uTexture, uSampler, uv + uDelta / gfu.uInputSize.xy * percent * radius);\n    sample = vec4<f32>(sample.xyz * sample.a, sample.a); // multiply sample.rgb with sample.a\n    color += sample * weight;\n    total += weight;\n  }\n\n  color /= total;\n  color = vec4<f32>(color.xyz / (color.a + 0.00001), color.a); // divide color.rgb by color.a + 0.00001\n\n  return color;\n}\n\n\nfn random(position: vec4<f32>, scale: vec3<f32>, seed: f32) -> f32\n{\n  return fract(sin(dot(position.xyz + seed, scale)) * 43758.5453 + seed);\n}";

// node_modules/pixi-filters/lib/tilt-shift/TiltShiftAxisFilter.mjs
var __defProp33 = Object.defineProperty;
var __defNormalProp33 = (obj, key, value) => key in obj ? __defProp33(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField33 = (obj, key, value) => {
  __defNormalProp33(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _TiltShiftAxisFilter = class _TiltShiftAxisFilter2 extends Filter {
  constructor(options) {
    const { width, height } = ViewSystem.defaultOptions;
    options = {
      ..._TiltShiftAxisFilter2.DEFAULT_OPTIONS,
      /** The position to start the effect at. */
      start: { x: 0, y: height / 2 },
      /** The position to end the effect at. */
      end: { x: width, y: height / 2 },
      ...options
    };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source34,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment35,
      name: "tilt-shift-axis-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        tiltShiftUniforms: {
          uBlur: {
            value: new Float32Array([
              options.blur,
              options.gradientBlur
            ]),
            type: "vec2<f32>"
          },
          uStart: { value: options.start, type: "vec2<f32>" },
          uEnd: { value: options.end, type: "vec2<f32>" },
          uDelta: { value: new Float32Array([0, 0]), type: "vec2<f32>" }
        }
      }
    });
    __publicField33(this, "uniforms");
    __publicField33(this, "_tiltAxis");
    this.uniforms = this.resources.tiltShiftUniforms.uniforms;
    this._tiltAxis = options.axis;
  }
  /**
   * Updates the filter delta values.
   * @ignore
   */
  updateDelta() {
    this.uniforms.uDelta[0] = 0;
    this.uniforms.uDelta[1] = 0;
    if (this._tiltAxis === void 0)
      return;
    const end = this.uniforms.uEnd;
    const start = this.uniforms.uStart;
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const d = Math.sqrt(dx * dx + dy * dy);
    const isVert = this._tiltAxis === "vertical";
    this.uniforms.uDelta[0] = !isVert ? dx / d : -dy / d;
    this.uniforms.uDelta[1] = !isVert ? dy / d : dx / d;
  }
};
__publicField33(_TiltShiftAxisFilter, "DEFAULT_OPTIONS", {
  /** The strength of the blur. */
  blur: 100,
  /** The strength of the blur gradient */
  gradientBlur: 600
});
var TiltShiftAxisFilter = _TiltShiftAxisFilter;

// node_modules/pixi-filters/lib/tilt-shift/TiltShiftFilter.mjs
var __defProp34 = Object.defineProperty;
var __defNormalProp34 = (obj, key, value) => key in obj ? __defProp34(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField34 = (obj, key, value) => {
  __defNormalProp34(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var TiltShiftFilter = class extends TiltShiftAxisFilter {
  /**
   * @param options - Options for the TiltShiftFilter constructor.
   */
  constructor(options) {
    options = { ...TiltShiftAxisFilter.DEFAULT_OPTIONS, ...options };
    super({ ...options, axis: "horizontal" });
    __publicField34(this, "_tiltShiftYFilter");
    this._tiltShiftYFilter = new TiltShiftAxisFilter({ ...options, axis: "vertical" });
    this.updateDelta();
    Object.assign(this, options);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    const renderTarget = TexturePool.getSameSizeTexture(input);
    filterManager.applyFilter(this, input, renderTarget, true);
    filterManager.applyFilter(this._tiltShiftYFilter, renderTarget, output, clearMode);
    TexturePool.returnTexture(renderTarget);
  }
  /** @ignore */
  updateDelta() {
    super.updateDelta();
    this._tiltShiftYFilter.updateDelta();
  }
  /** The strength of the blur. */
  get blur() {
    return this.uniforms.uBlur[0];
  }
  set blur(value) {
    this.uniforms.uBlur[0] = this._tiltShiftYFilter.uniforms.uBlur[0] = value;
  }
  /** The strength of the gradient blur. */
  get gradientBlur() {
    return this.uniforms.uBlur[1];
  }
  set gradientBlur(value) {
    this.uniforms.uBlur[1] = this._tiltShiftYFilter.uniforms.uBlur[1] = value;
  }
  /** The position to start the effect at. */
  get start() {
    return this.uniforms.uStart;
  }
  set start(value) {
    this.uniforms.uStart = this._tiltShiftYFilter.uniforms.uStart = value;
    this.updateDelta();
  }
  /** The position to start the effect at on the `x` axis. */
  get startX() {
    return this.start.x;
  }
  set startX(value) {
    this.start.x = value;
    this.updateDelta();
  }
  /** The position to start the effect at on the `x` axis. */
  get startY() {
    return this.start.y;
  }
  set startY(value) {
    this.start.y = value;
    this.updateDelta();
  }
  /** The position to end the effect at. */
  get end() {
    return this.uniforms.uEnd;
  }
  set end(value) {
    this.uniforms.uEnd = this._tiltShiftYFilter.uniforms.uEnd = value;
    this.updateDelta();
  }
  /** The position to end the effect at on the `x` axis. */
  get endX() {
    return this.end.x;
  }
  set endX(value) {
    this.end.x = value;
    this.updateDelta();
  }
  /** The position to end the effect at on the `y` axis. */
  get endY() {
    return this.end.y;
  }
  set endY(value) {
    this.end.y = value;
    this.updateDelta();
  }
};

// node_modules/pixi-filters/lib/twist/twist2.mjs
var fragment36 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uTwist;\nuniform vec2 uOffset;\nuniform vec4 uInputSize;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= uInputSize.xy;\n    coord += uInputSize.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= uInputSize.zw;\n    coord /= uInputSize.xy;\n\n    return coord;\n}\n\nvec2 twist(vec2 coord)\n{\n    coord -= uOffset;\n\n    float dist = length(coord);\n    float uRadius = uTwist[0];\n    float uAngle = uTwist[1];\n\n    if (dist < uRadius)\n    {\n        float ratioDist = (uRadius - dist) / uRadius;\n        float angleMod = ratioDist * ratioDist * uAngle;\n        float s = sin(angleMod);\n        float c = cos(angleMod);\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n    }\n\n    coord += uOffset;\n\n    return coord;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n    coord = twist(coord);\n    coord = unmapCoord(coord);\n    finalColor = texture(uTexture, coord);\n}\n";

// node_modules/pixi-filters/lib/twist/twist.mjs
var source35 = "struct TwistUniforms {\n  uTwist:vec2<f32>,\n  uOffset:vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> twistUniforms : TwistUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n  return textureSample(uTexture, uSampler, unmapCoord(twist(mapCoord(uv))));\n}\n\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n  var mappedCoord: vec2<f32> = coord;\n  mappedCoord *= gfu.uInputSize.xy;\n  mappedCoord += gfu.uOutputFrame.xy;\n  return mappedCoord;\n}\n\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n  var mappedCoord: vec2<f32> = coord;\n  mappedCoord -= gfu.uOutputFrame.xy;\n  mappedCoord /= gfu.uInputSize.xy;\n  return mappedCoord;\n}\n\nfn twist(coord: vec2<f32>) -> vec2<f32>\n{\n  var twistedCoord: vec2<f32> = coord;\n  let uRadius = twistUniforms.uTwist[0];\n  let uAngle = twistUniforms.uTwist[1];\n  let uOffset = twistUniforms.uOffset;\n\n  twistedCoord -= uOffset;\n  \n  let dist = length(twistedCoord);\n\n  if (dist < uRadius)\n  {\n    let ratioDist: f32 = (uRadius - dist) / uRadius;\n    let angleMod: f32 = ratioDist * ratioDist * uAngle;\n    let s: f32 = sin(angleMod);\n    let c: f32 = cos(angleMod);\n    twistedCoord = vec2<f32>(twistedCoord.x * c - twistedCoord.y * s, twistedCoord.x * s + twistedCoord.y * c);\n  }\n\n  twistedCoord += uOffset;\n  return twistedCoord;\n}\n";

// node_modules/pixi-filters/lib/twist/TwistFilter.mjs
var __defProp35 = Object.defineProperty;
var __defNormalProp35 = (obj, key, value) => key in obj ? __defProp35(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField35 = (obj, key, value) => {
  __defNormalProp35(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _TwistFilter = class _TwistFilter2 extends Filter {
  /**
   * @param options - Options for the TwistFilter constructor.
   */
  constructor(options) {
    options = { ..._TwistFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source35,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment36,
      name: "twist-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        twistUniforms: {
          uTwist: {
            value: [options.radius ?? 0, options.angle ?? 0],
            type: "vec2<f32>"
          },
          uOffset: {
            value: options.offset,
            type: "vec2<f32>"
          }
        }
      },
      ...options
    });
    __publicField35(this, "uniforms");
    this.uniforms = this.resources.twistUniforms.uniforms;
  }
  /**
   * The radius of the twist
   * @default 200
   */
  get radius() {
    return this.uniforms.uTwist[0];
  }
  set radius(value) {
    this.uniforms.uTwist[0] = value;
  }
  /**
   * The angle of the twist
   * @default 4
   */
  get angle() {
    return this.uniforms.uTwist[1];
  }
  set angle(value) {
    this.uniforms.uTwist[1] = value;
  }
  /**
   * The `x` offset coordinate to change the position of the center of the circle of effect
   * @default 0
   */
  get offset() {
    return this.uniforms.uOffset;
  }
  set offset(value) {
    this.uniforms.uOffset = value;
  }
  /**
   * The `x` offset coordinate to change the position of the center of the circle of effect
   * @default 0
   */
  get offsetX() {
    return this.offset.x;
  }
  set offsetX(value) {
    this.offset.x = value;
  }
  /**
   * The `y` offset coordinate to change the position of the center of the circle of effect
   * @default 0
   */
  get offsetY() {
    return this.offset.y;
  }
  set offsetY(value) {
    this.offset.y = value;
  }
};
__publicField35(_TwistFilter, "DEFAULT_OPTIONS", {
  padding: 20,
  radius: 200,
  angle: 4,
  offset: { x: 0, y: 0 }
});
var TwistFilter = _TwistFilter;

// node_modules/pixi-filters/lib/zoom-blur/zoom-blur2.mjs
var fragment37 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uStrength;\nuniform vec2 uCenter;\nuniform vec2 uRadii;\n\nuniform vec4 uInputSize;\n\nconst float MAX_KERNEL_SIZE = ${MAX_KERNEL_SIZE};\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 co, float seed) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\n    return fract(sin(sn) * c + seed);\n}\n\nvoid main() {\n    float minGradient = uRadii[0] * 0.3;\n    float innerRadius = (uRadii[0] + minGradient * 0.5) / uInputSize.x;\n\n    float gradient = uRadii[1] * 0.3;\n    float radius = (uRadii[1] - gradient * 0.5) / uInputSize.x;\n\n    float countLimit = MAX_KERNEL_SIZE;\n\n    vec2 dir = vec2(uCenter.xy / uInputSize.xy - vTextureCoord);\n    float dist = length(vec2(dir.x, dir.y * uInputSize.y / uInputSize.x));\n\n    float strength = uStrength;\n\n    float delta = 0.0;\n    float gap;\n    if (dist < innerRadius) {\n        delta = innerRadius - dist;\n        gap = minGradient;\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n        delta = dist - radius;\n        gap = gradient;\n    }\n\n    if (delta > 0.0) {\n        float normalCount = gap / uInputSize.x;\n        delta = (normalCount - delta) / normalCount;\n        countLimit *= delta;\n        strength *= delta;\n        if (countLimit < 1.0)\n        {\n            gl_FragColor = texture(uTexture, vTextureCoord);\n            return;\n        }\n    }\n\n    // randomize the lookup values to hide the fixed number of samples\n    float offset = rand(vTextureCoord, 0.0);\n\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n\n    dir *= strength;\n\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\n        float weight = 4.0 * (percent - percent * percent);\n        vec2 p = vTextureCoord + dir * percent;\n        vec4 sample = texture(uTexture, p);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n\n        if (t > countLimit){\n            break;\n        }\n    }\n\n    color /= total;\n    // switch back from pre-multiplied alpha\n    // color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n";

// node_modules/pixi-filters/lib/zoom-blur/zoom-blur.mjs
var source36 = "struct ZoomBlurUniforms {\n    uStrength:f32,\n    uCenter:vec2<f32>,\n    uRadii:vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> zoomBlurUniforms : ZoomBlurUniforms;\n\n@fragment\nfn mainFragment(\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uStrength = zoomBlurUniforms.uStrength;\n  let uCenter = zoomBlurUniforms.uCenter;\n  let uRadii = zoomBlurUniforms.uRadii;\n\n  let minGradient: f32 = uRadii[0] * 0.3;\n  let innerRadius: f32 = (uRadii[0] + minGradient * 0.5) / gfu.uInputSize.x;\n\n  let gradient: f32 = uRadii[1] * 0.3;\n  let radius: f32 = (uRadii[1] - gradient * 0.5) / gfu.uInputSize.x;\n\n  let MAX_KERNEL_SIZE: f32 = ${MAX_KERNEL_SIZE};\n\n  var countLimit: f32 = MAX_KERNEL_SIZE;\n\n  var dir: vec2<f32> = vec2<f32>(uCenter / gfu.uInputSize.xy - uv);\n  let dist: f32 = length(vec2<f32>(dir.x, dir.y * gfu.uInputSize.y / gfu.uInputSize.x));\n\n  var strength: f32 = uStrength;\n\n  var delta: f32 = 0.0;\n  var gap: f32;\n\n  if (dist < innerRadius) {\n      delta = innerRadius - dist;\n      gap = minGradient;\n  } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n      delta = dist - radius;\n      gap = gradient;\n  }\n\n  var returnColorOnly: bool = false;\n\n  if (delta > 0.0) {\n    let normalCount: f32 = gap / gfu.uInputSize.x;\n    delta = (normalCount - delta) / normalCount;\n    countLimit *= delta;\n    strength *= delta;\n    \n    if (countLimit < 1.0)\n    {\n      returnColorOnly = true;;\n    }\n  }\n\n  // randomize the lookup values to hide the fixed number of samples\n  let offset: f32 = rand(uv, 0.0);\n\n  var total: f32 = 0.0;\n  var color: vec4<f32> = vec4<f32>(0.);\n\n  dir *= strength;\n\n  for (var t = 0.0; t < MAX_KERNEL_SIZE; t += 1.0) {\n    let percent: f32 = (t + offset) / MAX_KERNEL_SIZE;\n    let weight: f32 = 4.0 * (percent - percent * percent);\n    let p: vec2<f32> = uv + dir * percent;\n    let sample: vec4<f32> = textureSample(uTexture, uSampler, p);\n    \n    if (t < countLimit)\n    {\n      color += sample * weight;\n      total += weight;\n    }\n  }\n\n  color /= total;\n\n  return select(color, textureSample(uTexture, uSampler, uv), returnColorOnly);\n}\n\nfn modulo(x: f32, y: f32) -> f32\n{\n  return x - y * floor(x/y);\n}\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nfn rand(co: vec2<f32>, seed: f32) -> f32\n{\n  let a: f32 = 12.9898;\n  let b: f32 = 78.233;\n  let c: f32 = 43758.5453;\n  let dt: f32 = dot(co + seed, vec2<f32>(a, b));\n  let sn: f32 = modulo(dt, 3.14159);\n  return fract(sin(sn) * c + seed);\n}";

// node_modules/pixi-filters/lib/zoom-blur/ZoomBlurFilter.mjs
var __defProp36 = Object.defineProperty;
var __defNormalProp36 = (obj, key, value) => key in obj ? __defProp36(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField36 = (obj, key, value) => {
  __defNormalProp36(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _ZoomBlurFilter = class _ZoomBlurFilter2 extends Filter {
  /**
   * @param options - Options for the ZoomBlurFilter constructor.
   */
  constructor(options) {
    options = { ..._ZoomBlurFilter2.DEFAULT_OPTIONS, ...options };
    const kernelSize = options.maxKernelSize ?? 32;
    const gpuProgram = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source36.replace("${MAX_KERNEL_SIZE}", kernelSize.toFixed(1)),
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex,
      fragment: fragment37.replace("${MAX_KERNEL_SIZE}", kernelSize.toFixed(1)),
      name: "zoom-blur-filter"
    });
    super({
      gpuProgram,
      glProgram,
      resources: {
        zoomBlurUniforms: {
          uStrength: { value: options.strength, type: "f32" },
          uCenter: { value: options.center, type: "vec2<f32>" },
          uRadii: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    });
    __publicField36(this, "uniforms");
    this.uniforms = this.resources.zoomBlurUniforms.uniforms;
    Object.assign(this, options);
  }
  /**
   * Sets the strength of the zoom blur effect
   * @default 0.1
   */
  get strength() {
    return this.uniforms.uStrength;
  }
  set strength(value) {
    this.uniforms.uStrength = value;
  }
  /**
   * The center of the zoom
   * @default [0,0]
   */
  get center() {
    return this.uniforms.uCenter;
  }
  set center(value) {
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this.uniforms.uCenter = value;
  }
  /**
   * Sets the center of the effect in normalized screen coords on the `x` axis
   * @default 0
   */
  get centerX() {
    return this.uniforms.uCenter.x;
  }
  set centerX(value) {
    this.uniforms.uCenter.x = value;
  }
  /**
   * Sets the center of the effect in normalized screen coords on the `y` axis
   * @default 0
   */
  get centerY() {
    return this.uniforms.uCenter.y;
  }
  set centerY(value) {
    this.uniforms.uCenter.y = value;
  }
  /**
   * The inner radius of zoom. The part in inner circle won't apply zoom blur effect
   * @default 0
   */
  get innerRadius() {
    return this.uniforms.uRadii[0];
  }
  set innerRadius(value) {
    this.uniforms.uRadii[0] = value;
  }
  /**
   * Outer radius of the effect. less than `0` equates to infinity
   * @default -1
   */
  get radius() {
    return this.uniforms.uRadii[1];
  }
  set radius(value) {
    this.uniforms.uRadii[1] = value < 0 || value === Infinity ? -1 : value;
  }
};
__publicField36(_ZoomBlurFilter, "DEFAULT_OPTIONS", {
  strength: 0.1,
  center: { x: 0, y: 0 },
  innerRadius: 0,
  radius: -1,
  maxKernelSize: 32
});
var ZoomBlurFilter = _ZoomBlurFilter;
export {
  AdjustmentFilter,
  AdvancedBloomFilter,
  AsciiFilter,
  BackdropBlurFilter,
  BevelFilter,
  BloomFilter,
  BulgePinchFilter,
  CRTFilter,
  ColorGradientFilter,
  ColorMapFilter,
  ColorOverlayFilter,
  ColorReplaceFilter,
  ConvolutionFilter,
  CrossHatchFilter,
  DotFilter,
  DropShadowFilter,
  EmbossFilter,
  GlitchFilter,
  GlowFilter,
  GodrayFilter,
  GrayscaleFilter,
  HslAdjustmentFilter,
  KawaseBlurFilter,
  MotionBlurFilter,
  MultiColorReplaceFilter,
  OldFilmFilter,
  OutlineFilter,
  PixelateFilter,
  RGBSplitFilter,
  RadialBlurFilter,
  ReflectionFilter,
  ShockwaveFilter,
  SimpleLightmapFilter,
  SimplexNoiseFilter,
  TiltShiftAxisFilter,
  TiltShiftFilter,
  TwistFilter,
  ZoomBlurFilter,
  angleFromCssOrientation,
  angleFromDirectionalValue,
  colorAsStringFromCssStop,
  offsetsFromCssColorStops,
  parseCssGradient,
  stopsFromCssStops,
  trimCssGradient,
  typeFromCssType,
  vertex,
  wgslVertex
};
//# sourceMappingURL=pixi-filters.js.map
