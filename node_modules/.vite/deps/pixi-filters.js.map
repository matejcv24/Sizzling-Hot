{
  "version": 3,
  "sources": ["../../pixi-filters/lib/defaults/default.mjs", "../../pixi-filters/lib/defaults/default2.mjs", "../../pixi-filters/lib/adjustment/adjustment.mjs", "../../pixi-filters/lib/adjustment/adjustment2.mjs", "../../pixi-filters/src/adjustment/AdjustmentFilter.ts", "../../pixi-filters/lib/kawase-blur/kawase-blur.mjs", "../../pixi-filters/lib/kawase-blur/kawase-blur2.mjs", "../../pixi-filters/lib/kawase-blur/kawase-blur-clamp2.mjs", "../../pixi-filters/lib/kawase-blur/kawase-blur-clamp.mjs", "../../pixi-filters/src/kawase-blur/KawaseBlurFilter.ts", "../../pixi-filters/lib/advanced-bloom/advanced-bloom.mjs", "../../pixi-filters/lib/advanced-bloom/advanced-bloom2.mjs", "../../pixi-filters/lib/advanced-bloom/extract-brightness.mjs", "../../pixi-filters/lib/advanced-bloom/extract-brightness2.mjs", "../../pixi-filters/src/advanced-bloom/ExtractBrightnessFilter.ts", "../../pixi-filters/src/advanced-bloom/AdvancedBloomFilter.ts", "../../pixi-filters/lib/ascii/ascii.mjs", "../../pixi-filters/lib/ascii/ascii2.mjs", "../../pixi-filters/src/ascii/AsciiFilter.ts", "../../pixi-filters/lib/backdrop-blur/backdrop-blur-blend2.mjs", "../../pixi-filters/lib/backdrop-blur/backdrop-blur-blend.mjs", "../../pixi-filters/src/backdrop-blur/BackdropBlurFilter.ts", "../../pixi-filters/lib/bevel/bevel.mjs", "../../pixi-filters/lib/bevel/bevel2.mjs", "../../pixi-filters/src/bevel/BevelFilter.ts", "../../pixi-filters/src/bloom/BloomFilter.ts", "../../pixi-filters/lib/bulge-pinch/bulge-pinch.mjs", "../../pixi-filters/lib/bulge-pinch/bulge-pinch2.mjs", "../../pixi-filters/src/bulge-pinch/BulgePinchFilter.ts", "../../pixi-filters/lib/color-gradient/color-gradient2.mjs", "../../pixi-filters/lib/color-gradient/color-gradient.mjs", "../../pixi-filters/lib/color-gradient/color-gradient3.mjs", "../../pixi-filters/node_modules/gradient-parser/build/node.js", "", "../../pixi-filters/src/color-gradient/ColorGradientFilter.ts", "../../pixi-filters/lib/color-map/color-map2.mjs", "../../pixi-filters/lib/color-map/color-map.mjs", "../../pixi-filters/src/color-map/ColorMapFilter.ts", "../../pixi-filters/lib/color-overlay/color-overlay2.mjs", "../../pixi-filters/lib/color-overlay/color-overlay.mjs", "../../pixi-filters/src/color-overlay/ColorOverlayFilter.ts", "../../pixi-filters/lib/color-replace/color-replace.mjs", "../../pixi-filters/lib/color-replace/color-replace2.mjs", "../../pixi-filters/src/color-replace/ColorReplaceFilter.ts", "../../pixi-filters/lib/convolution/convolution.mjs", "../../pixi-filters/lib/convolution/convolution2.mjs", "../../pixi-filters/src/convolution/ConvolutionFilter.ts", "../../pixi-filters/lib/cross-hatch/crosshatch.mjs", "../../pixi-filters/lib/cross-hatch/crosshatch2.mjs", "../../pixi-filters/src/cross-hatch/CrossHatchFilter.ts", "../../pixi-filters/lib/crt/crt2.mjs", "../../pixi-filters/lib/crt/crt.mjs", "../../pixi-filters/src/crt/CRTFilter.ts", "../../pixi-filters/lib/dot/dot.mjs", "../../pixi-filters/lib/dot/dot2.mjs", "../../pixi-filters/src/dot/DotFilter.ts", "../../pixi-filters/lib/drop-shadow/drop-shadow.mjs", "../../pixi-filters/lib/drop-shadow/drop-shadow2.mjs", "../../pixi-filters/src/drop-shadow/DropShadowFilter.ts", "../../pixi-filters/lib/emboss/emboss2.mjs", "../../pixi-filters/lib/emboss/emboss.mjs", "../../pixi-filters/src/emboss/EmbossFilter.ts", "../../pixi-filters/lib/glitch/glitch2.mjs", "../../pixi-filters/lib/glitch/glitch.mjs", "../../pixi-filters/src/glitch/GlitchFilter.ts", "../../pixi-filters/lib/glow/glow.mjs", "../../pixi-filters/lib/glow/glow2.mjs", "../../pixi-filters/src/glow/GlowFilter.ts", "../../pixi-filters/lib/godray/god-ray2.mjs", "../../pixi-filters/lib/godray/god-ray.mjs", "../../pixi-filters/lib/godray/perlin.mjs", "../../pixi-filters/lib/godray/perlin2.mjs", "../../pixi-filters/src/godray/GodrayFilter.ts", "../../pixi-filters/lib/grayscale/grayscale2.mjs", "../../pixi-filters/lib/grayscale/grayscale.mjs", "../../pixi-filters/src/grayscale/GrayscaleFilter.ts", "../../pixi-filters/lib/hsl-adjustment/hsladjustment.mjs", "../../pixi-filters/lib/hsl-adjustment/hsladjustment2.mjs", "../../pixi-filters/src/hsl-adjustment/HslAdjustmentFilter.ts", "../../pixi-filters/lib/motion-blur/motion-blur2.mjs", "../../pixi-filters/lib/motion-blur/motion-blur.mjs", "../../pixi-filters/src/motion-blur/MotionBlurFilter.ts", "../../pixi-filters/lib/multi-color-replace/multi-color-replace.mjs", "../../pixi-filters/lib/multi-color-replace/multi-color-replace2.mjs", "../../pixi-filters/src/multi-color-replace/MultiColorReplaceFilter.ts", "../../pixi-filters/lib/old-film/old-film.mjs", "../../pixi-filters/lib/old-film/old-film2.mjs", "../../pixi-filters/src/old-film/OldFilmFilter.ts", "../../pixi-filters/lib/outline/outline.mjs", "../../pixi-filters/lib/outline/outline2.mjs", "../../pixi-filters/src/outline/OutlineFilter.ts", "../../pixi-filters/lib/pixelate/pixelate2.mjs", "../../pixi-filters/lib/pixelate/pixelate.mjs", "../../pixi-filters/src/pixelate/PixelateFilter.ts", "../../pixi-filters/lib/radial-blur/radial-blur.mjs", "../../pixi-filters/lib/radial-blur/radial-blur2.mjs", "../../pixi-filters/src/radial-blur/RadialBlurFilter.ts", "../../pixi-filters/lib/reflection/reflection.mjs", "../../pixi-filters/lib/reflection/reflection2.mjs", "../../pixi-filters/src/reflection/ReflectionFilter.ts", "../../pixi-filters/lib/rgb-split/rgb-split2.mjs", "../../pixi-filters/lib/rgb-split/rgb-split.mjs", "../../pixi-filters/src/rgb-split/RGBSplitFilter.ts", "../../pixi-filters/lib/shockwave/shockwave2.mjs", "../../pixi-filters/lib/shockwave/shockwave.mjs", "../../pixi-filters/src/shockwave/ShockwaveFilter.ts", "../../pixi-filters/lib/simple-lightmap/simple-lightmap.mjs", "../../pixi-filters/lib/simple-lightmap/simple-lightmap2.mjs", "../../pixi-filters/src/simple-lightmap/SimpleLightmapFilter.ts", "../../pixi-filters/lib/simplex-noise/simplex.mjs", "../../pixi-filters/lib/simplex-noise/simplex2.mjs", "../../pixi-filters/src/simplex-noise/SimplexNoiseFilter.ts", "../../pixi-filters/lib/tilt-shift/tilt-shift.mjs", "../../pixi-filters/lib/tilt-shift/tilt-shift2.mjs", "../../pixi-filters/src/tilt-shift/TiltShiftAxisFilter.ts", "../../pixi-filters/src/tilt-shift/TiltShiftFilter.ts", "../../pixi-filters/lib/twist/twist2.mjs", "../../pixi-filters/lib/twist/twist.mjs", "../../pixi-filters/src/twist/TwistFilter.ts", "../../pixi-filters/lib/zoom-blur/zoom-blur2.mjs", "../../pixi-filters/lib/zoom-blur/zoom-blur.mjs", "../../pixi-filters/src/zoom-blur/ZoomBlurFilter.ts"],
  "sourcesContent": ["var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=default.mjs.map\n", "var wgslVertex = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\";\n\nexport { wgslVertex as default };\n//# sourceMappingURL=default2.mjs.map\n", "var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uGamma;\\nuniform float uContrast;\\nuniform float uSaturation;\\nuniform float uBrightness;\\nuniform vec4 uColor;\\n\\nvoid main()\\n{\\n    vec4 c = texture(uTexture, vTextureCoord);\\n\\n    if (c.a > 0.0) {\\n        c.rgb /= c.a;\\n\\n        vec3 rgb = pow(c.rgb, vec3(1. / uGamma));\\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, uSaturation), uContrast);\\n        rgb.r *= uColor.r;\\n        rgb.g *= uColor.g;\\n        rgb.b *= uColor.b;\\n        c.rgb = rgb * uBrightness;\\n\\n        c.rgb *= c.a;\\n    }\\n\\n    finalColor = c * uColor.a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=adjustment.mjs.map\n", "var source = \"struct AdjustmentUniforms {\\n  uGamma: f32,\\n  uContrast: f32,\\n  uSaturation: f32,\\n  uBrightness: f32,\\n  uColor: vec4<f32>,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> adjustmentUniforms : AdjustmentUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  var sample = textureSample(uTexture, uSampler, uv);\\n  let color = adjustmentUniforms.uColor;\\n\\n  if (sample.a > 0.0) \\n  {\\n    sample = vec4<f32>(sample.rgb / sample.a, sample.a);\\n    var rgb: vec3<f32> = pow(sample.rgb, vec3<f32>(1. / adjustmentUniforms.uGamma));\\n    rgb = mix(vec3<f32>(.5), mix(vec3<f32>(dot(vec3<f32>(.2125, .7154, .0721), rgb)), rgb, adjustmentUniforms.uSaturation), adjustmentUniforms.uContrast);\\n    rgb.r *= color.r;\\n    rgb.g *= color.g;\\n    rgb.b *= color.b;\\n    sample = vec4<f32>(rgb.rgb * adjustmentUniforms.uBrightness, sample.a);\\n    sample = vec4<f32>(sample.rgb * sample.a, sample.a);\\n  }\\n\\n  return sample * color.a;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=adjustment2.mjs.map\n", "import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './adjustment.frag';\nimport source from './adjustment.wgsl';\n\n/** Options for the AdjustmentFilter constructor */\nexport interface AdjustmentFilterOptions\n{\n    /**\n     * The amount of luminance\n     * @default 1\n     */\n    gamma?: number;\n    /**\n     * The amount of contrast\n     * @default 1\n     */\n    contrast?: number;\n    /**\n     * The amount of color saturation\n     * @default 1\n     */\n    saturation?: number;\n    /**\n     * The overall brightness\n     * @default 1\n     */\n    brightness?: number;\n    /**\n     * The multiplied red channel\n     * @default 1\n     */\n    red?: number;\n    /**\n     * The multiplied green channel\n     * @default 1\n     */\n    green?: number;\n    /**\n     * The multiplied blue channel\n     * @default 1\n     */\n    blue?: number;\n    /**\n     * The overall alpha channel\n     * @default 1\n     */\n    alpha?: number;\n}\n\n/**\n * The ability to adjust gamma, contrast, saturation, brightness, alpha or color-channel shift.\n * This is a faster and much simpler to use than\n * {@link http://pixijs.download/release/docs/ColorMatrixFilter.html ColorMatrixFilter}\n * because it does not use a matrix.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/adjustment.png)\n *\n * @class\n * @extends Filter\n */\nexport class AdjustmentFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: AdjustmentFilterOptions = {\n        gamma: 1,\n        contrast: 1,\n        saturation: 1,\n        brightness: 1,\n        red: 1,\n        green: 1,\n        blue: 1,\n        alpha: 1,\n    };\n\n    public uniforms: {\n        uGamma: number;\n        uContrast: number;\n        uSaturation: number;\n        uBrightness: number;\n        uColor: Float32Array;\n    };\n\n    /**\n     * @param options - The options of the adjustment filter.\n     */\n    constructor(options?: AdjustmentFilterOptions)\n    {\n        options = { ...AdjustmentFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'adjustment-filter'\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                adjustmentUniforms: {\n                    uGamma: { value: options.gamma, type: 'f32' },\n                    uContrast: { value: options.contrast, type: 'f32' },\n                    uSaturation: { value: options.saturation, type: 'f32' },\n                    uBrightness: { value: options.brightness, type: 'f32' },\n                    uColor: {\n                        value: [\n                            options.red,\n                            options.green,\n                            options.blue,\n                            options.alpha,\n                        ],\n                        type: 'vec4<f32>',\n                    },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.adjustmentUniforms.uniforms;\n    }\n\n    /**\n     * Amount of luminance\n     * @default 1\n     */\n    get gamma(): number { return this.uniforms.uGamma; }\n    set gamma(value: number) { this.uniforms.uGamma = value; }\n\n    /**\n     * Amount of contrast\n     * @default 1\n     */\n    get contrast(): number { return this.uniforms.uContrast; }\n    set contrast(value: number) { this.uniforms.uContrast = value; }\n\n    /**\n     * Amount of color saturation\n     * @default 1\n     */\n    get saturation(): number { return this.uniforms.uSaturation; }\n    set saturation(value: number) { this.uniforms.uSaturation = value; }\n\n    /**\n     * The overall brightness\n     * @default 1\n     */\n    get brightness(): number { return this.uniforms.uBrightness; }\n    set brightness(value: number) { this.uniforms.uBrightness = value; }\n\n    /**\n     * The multiplied red channel\n     * @default 1\n     */\n    get red(): number { return this.uniforms.uColor[0]; }\n    set red(value: number) { this.uniforms.uColor[0] = value; }\n\n    /**\n     * The multiplied blue channel\n     * @default 1\n     */\n    get green(): number { return this.uniforms.uColor[1]; }\n    set green(value: number) { this.uniforms.uColor[1] = value; }\n\n    /**\n     * The multiplied green channel\n     * @default 1\n     */\n    get blue(): number { return this.uniforms.uColor[2]; }\n    set blue(value: number) { this.uniforms.uColor[2] = value; }\n\n    /**\n     * The overall alpha channel\n     * @default 1\n     */\n    get alpha(): number { return this.uniforms.uColor[3]; }\n    set alpha(value: number) { this.uniforms.uColor[3] = value; }\n}\n", "var fragment = \"\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uOffset;\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n\\n    // Sample top left pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\\n\\n    // Sample top right pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\\n\\n    // Sample bottom right pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\\n\\n    // Sample bottom left pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\\n\\n    // Average\\n    color *= 0.25;\\n\\n    finalColor = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=kawase-blur.mjs.map\n", "var source = \"struct KawaseBlurUniforms {\\n  uOffset:vec2<f32>,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uOffset = kawaseBlurUniforms.uOffset;\\n  var color: vec4<f32> = vec4<f32>(0.0);\\n\\n  // Sample top left pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y));\\n  // Sample top right pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y));\\n  // Sample bottom right pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y));\\n  // Sample bottom left pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y));\\n  // Average\\n  color *= 0.25;\\n\\n  return color;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=kawase-blur2.mjs.map\n", "var fragmentClamp = \"\\nprecision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uOffset;\\n\\nuniform vec4 uInputClamp;\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n\\n    // Sample top left pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample top right pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample bottom right pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample bottom left pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Average\\n    color *= 0.25;\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragmentClamp as default };\n//# sourceMappingURL=kawase-blur-clamp2.mjs.map\n", "var sourceClamp = \"struct KawaseBlurUniforms {\\n  uOffset:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uOffset = kawaseBlurUniforms.uOffset;\\n  var color: vec4<f32> = vec4(0.0);\\n\\n  // Sample top left pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample top right pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample bottom right pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample bottom left pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Average\\n  color *= 0.25;\\n    \\n  return color;\\n}\";\n\nexport { sourceClamp as default };\n//# sourceMappingURL=kawase-blur-clamp.mjs.map\n", "import { deprecation, Filter, GlProgram, GpuProgram, TexturePool } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './kawase-blur.frag';\nimport source from './kawase-blur.wgsl';\nimport fragmentClamp from './kawase-blur-clamp.frag';\nimport sourceClamp from './kawase-blur-clamp.wgsl';\n\nimport type { FilterSystem, PointData, RenderSurface, Texture } from 'pixi.js';\n\n/** Options for the KawaseBlurFilter constructor. */\nexport interface KawaseBlurFilterOptions\n{\n    /**\n     * The blur of the filter. Should be greater than `0`.\n     * If value is an Array, setting kernels.\n     * @default 4\n     */\n    strength?: number | [number, number];\n    /**\n     * The quality of the filter. Should be an integer greater than `1`\n     * @default 3\n     */\n    quality?: number;\n    /**\n     * Clamp edges, useful for removing dark edges from fullscreen filters or bleeding to the edge of filterArea.\n     * @default false\n     */\n    clamp?: boolean;\n    /**\n     * Sets the pixel size of the filter. Large size is blurrier. For advanced usage.\n     * @default {x:1,y:1}\n     */\n    pixelSize?: PointData | number[] | number;\n}\n\n/**\n * A much faster blur than Gaussian blur, but more complicated to use.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/kawase-blur.png)\n *\n * @see https://software.intel.com/en-us/blogs/2014/07/15/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms\n * @class\n * @extends Filter\n */\nexport class KawaseBlurFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: KawaseBlurFilterOptions = {\n        strength: 4,\n        quality: 3,\n        clamp: false,\n        pixelSize: { x: 1, y: 1 },\n    };\n\n    public uniforms: {\n        uOffset: Float32Array;\n    };\n\n    private _pixelSize = { x: 0, y: 0 };\n    private _clamp: boolean;\n    private _kernels: number[] = [];\n    private _blur!: number;\n    private _quality!: number;\n\n    /**\n     * @param options - Options for the KawaseBlurFilter constructor.\n     */\n    constructor(options?: KawaseBlurFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number|number[]} [blur=4] - The blur of the filter. Should be greater than `0`. If\n     *        value is an Array, setting kernels.\n     * @param {number} [quality=3] - The quality of the filter. Should be an integer greater than `1`.\n     * @param {boolean} [clamp=false] - Clamp edges, useful for removing dark edges\n     *        from fullscreen filters or bleeding to the edge of filterArea.\n     */\n    constructor(blur?: number | number[], quality?: number, clamp?: boolean);\n    /** @ignore */\n    constructor(...args: [KawaseBlurFilterOptions?] | [(number | number[])?, number?, boolean?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number' || Array.isArray(options))\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'KawaseBlurFilter constructor params are now options object. See params: { strength, quality, clamp, pixelSize }');\n\n            options = { strength: options as number | [number, number] };\n\n            if (args[1] !== undefined) options.quality = args[1];\n            if (args[2] !== undefined) options.clamp = args[2];\n        }\n\n        options = { ...KawaseBlurFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source: options?.clamp ? sourceClamp : source,\n                entryPoint: 'mainFragment',\n            },\n        });\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment: options?.clamp ? fragmentClamp : fragment,\n            name: 'kawase-blur-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                kawaseBlurUniforms: {\n                    uOffset: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.kawaseBlurUniforms.uniforms;\n\n        this.pixelSize = options.pixelSize ?? { x: 1, y: 1 };\n\n        if (Array.isArray(options.strength))\n        {\n            this.kernels = options.strength;\n        }\n        else if (typeof options.strength === 'number')\n        {\n            this._blur = options.strength;\n            this.quality = options.quality ?? 3;\n        }\n\n        this._clamp = !!options.clamp;\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        const uvX = this.pixelSizeX / input.source.width;\n        const uvY = this.pixelSizeY / input.source.height;\n        let offset;\n\n        if (this._quality === 1 || this._blur === 0)\n        {\n            offset = this._kernels[0] + 0.5;\n            this.uniforms.uOffset[0] = offset * uvX;\n            this.uniforms.uOffset[1] = offset * uvY;\n            filterManager.applyFilter(this, input, output, clearMode);\n        }\n        else\n        {\n            const renderTarget = TexturePool.getSameSizeTexture(input);\n\n            let source = input;\n            let target = renderTarget;\n            let tmp;\n\n            const last = this._quality - 1;\n\n            for (let i = 0; i < last; i++)\n            {\n                offset = this._kernels[i] + 0.5;\n                this.uniforms.uOffset[0] = offset * uvX;\n                this.uniforms.uOffset[1] = offset * uvY;\n                filterManager.applyFilter(this, source, target, true);\n\n                tmp = source;\n                source = target;\n                target = tmp;\n            }\n\n            offset = this._kernels[last] + 0.5;\n            this.uniforms.uOffset[0] = offset * uvX;\n            this.uniforms.uOffset[1] = offset * uvY;\n\n            filterManager.applyFilter(this, source, output, clearMode);\n            TexturePool.returnTexture(renderTarget);\n        }\n    }\n\n    /**\n      * The amount of blur, value greater than `0`.\n      * @default 4\n      */\n    get strength(): number { return this._blur; }\n    set strength(value: number)\n    {\n        this._blur = value;\n        this._generateKernels();\n    }\n\n    /**\n      * The quality of the filter, integer greater than `1`.\n      * @default 3\n      */\n    get quality(): number { return this._quality; }\n    set quality(value: number)\n    {\n        this._quality = Math.max(1, Math.round(value));\n        this._generateKernels();\n    }\n\n    /**\n      * The kernel size of the blur filter, for advanced usage\n      * @default [0]\n      */\n    get kernels(): number[] { return this._kernels; }\n    set kernels(value: number[])\n    {\n        if (Array.isArray(value) && value.length > 0)\n        {\n            this._kernels = value;\n            this._quality = value.length;\n            this._blur = Math.max(...value);\n        }\n        else\n        {\n            // If value is invalid, set default value\n            this._kernels = [0];\n            this._quality = 1;\n        }\n    }\n\n    /**\n      * The size of the pixels. Large size is blurrier. For advanced usage.\n      * @default {x:1,y:1}\n      */\n    get pixelSize(): PointData { return this._pixelSize; }\n    set pixelSize(value: PointData | number[] | number)\n    {\n        if (typeof value === 'number')\n        {\n            this.pixelSizeX = this.pixelSizeY = value;\n\n            return;\n        }\n\n        if (Array.isArray(value))\n        {\n            this.pixelSizeX = value[0];\n            this.pixelSizeY = value[1];\n\n            return;\n        }\n\n        this._pixelSize = value;\n    }\n\n    /**\n      * The size of the pixels on the `x` axis. Large size is blurrier. For advanced usage.\n      * @default 1\n      */\n    get pixelSizeX(): number { return this.pixelSize.x; }\n    set pixelSizeX(value: number) { this.pixelSize.x = value; }\n\n    /**\n      * The size of the pixels on the `y` axis. Large size is blurrier. For advanced usage.\n      * @default 1\n      */\n    get pixelSizeY(): number { return this.pixelSize.y; }\n    set pixelSizeY(value: number) { this.pixelSize.y = value; }\n\n    /**\n      * Get the if the filter is clamped\n      * @default false\n      */\n    get clamp(): boolean { return this._clamp; }\n\n    /** Update padding based on kernel data */\n    private _updatePadding()\n    {\n        this.padding = Math.ceil(this._kernels.reduce((acc, v) => acc + v + 0.5, 0));\n    }\n\n    /** Auto generate kernels by blur & quality */\n    private _generateKernels()\n    {\n        const blur = this._blur;\n        const quality = this._quality;\n        const kernels: number[] = [blur];\n\n        if (blur > 0)\n        {\n            let k = blur;\n            const step = blur / quality;\n\n            for (let i = 1; i < quality; i++)\n            {\n                k -= step;\n                kernels.push(k);\n            }\n        }\n\n        this._kernels = kernels;\n        this._updatePadding();\n    }\n}\n", "var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\nuniform float uBloomScale;\\nuniform float uBrightness;\\n\\nvoid main() {\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    color.rgb *= uBrightness;\\n    vec4 bloomColor = vec4(texture(uMapTexture, vTextureCoord).rgb, 0.0);\\n    bloomColor.rgb *= uBloomScale;\\n    finalColor = color + bloomColor;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=advanced-bloom.mjs.map\n", "var source = \"struct AdvancedBloomUniforms {\\n  uBloomScale: f32,\\n  uBrightness: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> advancedBloomUniforms : AdvancedBloomUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  var color = textureSample(uTexture, uSampler, uv);\\n  color = vec4<f32>(color.rgb * advancedBloomUniforms.uBrightness, color.a);\\n\\n  var bloomColor = vec4<f32>(textureSample(uMapTexture, uSampler, uv).rgb, 0.0);\\n  bloomColor = vec4<f32>(bloomColor.rgb * advancedBloomUniforms.uBloomScale, bloomColor.a);\\n  \\n  return color + bloomColor;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=advanced-bloom2.mjs.map\n", "var fragment = \"\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uThreshold;\\n\\nvoid main() {\\n    vec4 color = texture(uTexture, vTextureCoord);\\n\\n    // A simple & fast algorithm for getting brightness.\\n    // It's inaccuracy , but good enought for this feature.\\n    float _max = max(max(color.r, color.g), color.b);\\n    float _min = min(min(color.r, color.g), color.b);\\n    float brightness = (_max + _min) * 0.5;\\n\\n    if(brightness > uThreshold) {\\n        finalColor = color;\\n    } else {\\n        finalColor = vec4(0.0, 0.0, 0.0, 0.0);\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=extract-brightness.mjs.map\n", "var source = \"struct ExtractBrightnessUniforms {\\n  uThreshold: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> extractBrightnessUniforms : ExtractBrightnessUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  // A simple & fast algorithm for getting brightness.\\n  // It's inaccurate, but good enough for this feature.\\n  let max: f32 = max(max(color.r, color.g), color.b);\\n  let min: f32 = min(min(color.r, color.g), color.b);\\n  let brightness: f32 = (max + min) * 0.5;\\n\\n  return select(vec4<f32>(0.), color, brightness > extractBrightnessUniforms.uThreshold);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=extract-brightness2.mjs.map\n", "import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './extract-brightness.frag';\nimport source from './extract-brightness.wgsl';\n\nexport interface ExtractBrightnessFilterOptions\n{\n    /**\n     * Defines how bright a color needs to be extracted.\n     */\n    threshold?: number;\n}\n\n/**\n * Internal filter for retrieving the brightness of the source image.\n * @class\n * @private\n */\nexport class ExtractBrightnessFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: ExtractBrightnessFilterOptions = {\n        threshold: 0.5\n    };\n\n    public uniforms: {\n        uThreshold: number;\n    };\n\n    constructor(options?: ExtractBrightnessFilterOptions)\n    {\n        options = { ...ExtractBrightnessFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'extract-brightness-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                extractBrightnessUniforms: {\n                    uThreshold: { value: options.threshold, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.extractBrightnessUniforms.uniforms;\n    }\n\n    /**\n     * Defines how bright a color needs to be extracted.\n     * @default 0.5\n     */\n    get threshold(): number { return this.uniforms.uThreshold; }\n    set threshold(value: number) { this.uniforms.uThreshold = value; }\n}\n", "import {\n    Filter,\n    FilterSystem,\n    GlProgram,\n    GpuProgram,\n    PointData,\n    RenderSurface,\n    Texture,\n    TexturePool,\n} from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport { KawaseBlurFilter } from '../kawase-blur/KawaseBlurFilter';\nimport fragment from './advanced-bloom.frag';\nimport source from './advanced-bloom.wgsl';\nimport { ExtractBrightnessFilter } from './ExtractBrightnessFilter';\n\n/** Options for the AdvancedBloomFilter constructor. */\nexport interface AdvancedBloomFilterOptions\n{\n    /**\n     * Defines how bright a color needs to be to affect bloom.\n     * @default 1\n     */\n    threshold?: number,\n    /**\n     * To adjust the strength of the bloom. Higher values is more intense brightness.\n     * @default 1\n     */\n    bloomScale?: number,\n    /**\n     * The brightness, lower value is more subtle brightness, higher value is blown-out.\n     * @default 1\n     */\n    brightness?: number,\n    /** The strength of the Blur properties simultaneously */\n    blur?: number,\n    /**\n     * The kernel size of the blur filter.\n     */\n    kernels?: number[],\n    /** The quality of the Blur filter. */\n    quality?: number,\n    /**\n     * The pixel size of the blur filter. Large size is blurrier. For advanced usage.\n     * @default {x:1,y:1}\n     */\n    pixelSize?: PointData | number[] | number,\n}\n\n/**\n * The AdvancedBloomFilter applies a Bloom Effect to an object. Unlike the normal BloomFilter\n * this had some advanced controls for adjusting the look of the bloom. Note: this filter\n * is slower than normal BloomFilter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/advanced-bloom.png)\n *\n * @class\n * @extends Filter\n */\nexport class AdvancedBloomFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: AdvancedBloomFilterOptions = {\n        threshold: 0.5,\n        bloomScale: 1,\n        brightness: 1,\n        blur: 8,\n        quality: 4,\n        pixelSize: { x: 1, y: 1 },\n    };\n\n    public uniforms: {\n        uBloomScale: number;\n        uBrightness: number;\n    };\n\n    /** To adjust the strength of the bloom. Higher values is more intense brightness. */\n    public bloomScale = 1;\n\n    /** The brightness, lower value is more subtle brightness, higher value is blown-out. */\n    public brightness = 1;\n\n    private _extractFilter: ExtractBrightnessFilter;\n    private _blurFilter: KawaseBlurFilter;\n\n    /**\n     * @param options - Options for the AdvancedBloomFilter constructor.\n     */\n    constructor(options?: AdvancedBloomFilterOptions)\n    {\n        options = { ...AdvancedBloomFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'advanced-bloom-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                advancedBloomUniforms: {\n                    uBloomScale: { value: options.bloomScale, type: 'f32' },\n                    uBrightness: { value: options.brightness, type: 'f32' },\n                },\n                uMapTexture: Texture.WHITE,\n            },\n        });\n\n        this.uniforms = this.resources.advancedBloomUniforms.uniforms;\n\n        this._extractFilter = new ExtractBrightnessFilter({\n            threshold: options.threshold\n        });\n\n        this._blurFilter = new KawaseBlurFilter({\n            strength: options.kernels as [number, number] ?? options.blur,\n            quality: options.kernels ? undefined : options.quality,\n        });\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        const brightTarget = TexturePool.getSameSizeTexture(input);\n\n        this._extractFilter.apply(filterManager, input, brightTarget, true);\n\n        const bloomTarget = TexturePool.getSameSizeTexture(input);\n\n        this._blurFilter.apply(filterManager, brightTarget, bloomTarget, true);\n\n        this.uniforms.uBloomScale = this.bloomScale;\n        this.uniforms.uBrightness = this.brightness;\n\n        this.resources.uMapTexture = bloomTarget.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n\n        TexturePool.returnTexture(bloomTarget);\n        TexturePool.returnTexture(brightTarget);\n    }\n\n    /**\n     * Defines how bright a color needs to be extracted.\n     * @default 0.5\n     */\n    get threshold(): number { return this._extractFilter.threshold; }\n    set threshold(value: number) { this._extractFilter.threshold = value; }\n\n    /** The kernels of the Blur Filter */\n    get kernels(): number[] { return this._blurFilter.kernels; }\n    set kernels(value: number[]) { this._blurFilter.kernels = value; }\n\n    /**\n     * The strength of the Blur properties simultaneously\n     * @default 2\n     */\n    get blur(): number { return this._blurFilter.strength; }\n    set blur(value: number) { this._blurFilter.strength = value; }\n\n    /**\n     * The quality of the Blur Filter\n     * @default 4\n     */\n    get quality(): number { return this._blurFilter.quality; }\n    set quality(value: number) { this._blurFilter.quality = value; }\n\n    /**\n     * The pixel size of the Kawase Blur filter\n     * @default {x:1,y:1}\n     */\n    get pixelSize(): PointData { return this._blurFilter.pixelSize; }\n    set pixelSize(value: PointData | number[] | number)\n    {\n        if (typeof value === 'number')\n        {\n            value = { x: value, y: value };\n        }\n\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this._blurFilter.pixelSize = value;\n    }\n\n    /**\n     * The horizontal pixelSize of the Kawase Blur filter\n     * @default 1\n     */\n    get pixelSizeX(): number { return this._blurFilter.pixelSizeX; }\n    set pixelSizeX(value: number) { this._blurFilter.pixelSizeX = value; }\n\n    /**\n     * The vertical pixel size of the Kawase Blur filter\n     * @default 1\n     */\n    get pixelSizeY(): number { return this._blurFilter.pixelSizeY; }\n    set pixelSizeY(value: number) { this._blurFilter.pixelSizeY = value; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uSize;\\nuniform vec3 uColor;\\nuniform float uReplaceColor;\\n\\nuniform vec4 uInputSize;\\n\\nvec2 mapCoord( vec2 coord )\\n{\\n    coord *= uInputSize.xy;\\n    coord += uInputSize.zw;\\n\\n    return coord;\\n}\\n\\nvec2 unmapCoord( vec2 coord )\\n{\\n    coord -= uInputSize.zw;\\n    coord /= uInputSize.xy;\\n\\n    return coord;\\n}\\n\\nvec2 pixelate(vec2 coord, vec2 size)\\n{\\n    return floor(coord / size) * size;\\n}\\n\\nvec2 getMod(vec2 coord, vec2 size)\\n{\\n    return mod(coord, size) / size;\\n}\\n\\nfloat character(float n, vec2 p)\\n{\\n    p = floor(p*vec2(4.0, 4.0) + 2.5);\\n\\n    if (clamp(p.x, 0.0, 4.0) == p.x)\\n    {\\n        if (clamp(p.y, 0.0, 4.0) == p.y)\\n        {\\n            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\\n        }\\n    }\\n    return 0.0;\\n}\\n\\nvoid main()\\n{\\n    vec2 coord = mapCoord(vTextureCoord);\\n\\n    // get the grid position\\n    vec2 pixCoord = pixelate(coord, vec2(uSize));\\n    pixCoord = unmapCoord(pixCoord);\\n\\n    // sample the color at grid position\\n    vec4 color = texture(uTexture, pixCoord);\\n\\n    // brightness of the color as it's perceived by the human eye\\n    float gray = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\\n\\n    // determine the character to use\\n    float n =  65536.0;             // .\\n    if (gray > 0.2) n = 65600.0;    // :\\n    if (gray > 0.3) n = 332772.0;   // *\\n    if (gray > 0.4) n = 15255086.0; // o\\n    if (gray > 0.5) n = 23385164.0; // &\\n    if (gray > 0.6) n = 15252014.0; // 8\\n    if (gray > 0.7) n = 13199452.0; // @\\n    if (gray > 0.8) n = 11512810.0; // #\\n\\n    // get the mod..\\n    vec2 modd = getMod(coord, vec2(uSize));\\n\\n    finalColor = (uReplaceColor > 0.5 ? vec4(uColor, 1.) : color) * character( n, vec2(-1.0) + modd * 2.0);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=ascii.mjs.map\n", "var source = \"struct AsciiUniforms {\\n    uSize: f32,\\n    uColor: vec3<f32>,\\n    uReplaceColor: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n    uInputSize:vec4<f32>,\\n    uInputPixel:vec4<f32>,\\n    uInputClamp:vec4<f32>,\\n    uOutputFrame:vec4<f32>,\\n    uGlobalFrame:vec4<f32>,\\n    uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> asciiUniforms : AsciiUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @location(0) uv: vec2<f32>,\\n    @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n    let pixelSize: f32 = asciiUniforms.uSize;\\n    let coord: vec2<f32> = mapCoord(uv);\\n\\n    // get the rounded color..\\n    var pixCoord: vec2<f32> = pixelate(coord, vec2<f32>(pixelSize));\\n    pixCoord = unmapCoord(pixCoord);\\n\\n    var color = textureSample(uTexture, uSampler, pixCoord);\\n\\n    // determine the character to use\\n    let gray: f32 = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\\n    \\n    var n: f32 = 65536.0; // .\\n    if (gray > 0.2) {\\n        n = 65600.0;    // :\\n    }\\n    if (gray > 0.3) {\\n        n = 332772.0;   // *\\n    }\\n    if (gray > 0.4) {\\n        n = 15255086.0; // o\\n    }\\n    if (gray > 0.5) {\\n        n = 23385164.0; // &\\n    }\\n    if (gray > 0.6) {\\n        n = 15252014.0; // 8\\n    }\\n    if (gray > 0.7) {\\n        n = 13199452.0; // @\\n    }\\n    if (gray > 0.8) {\\n        n = 11512810.0; // #\\n    }\\n\\n    // get the mod..\\n    let modd: vec2<f32> = getMod(coord, vec2<f32>(pixelSize));\\n    return select(color, vec4<f32>(asciiUniforms.uColor, 1.), asciiUniforms.uReplaceColor > 0.5) * character(n, vec2<f32>(-1.0) + modd * 2.0);\\n}\\n\\nfn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\\n{\\n    return floor( coord / size ) * size;\\n}\\n\\nfn getMod(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\\n{\\n    return moduloVec2( coord , size) / size;\\n}\\n\\nfn character(n: f32, p: vec2<f32>) -> f32\\n{\\n    var q: vec2<f32> = floor(p*vec2<f32>(4.0, 4.0) + 2.5);\\n\\n    if (clamp(q.x, 0.0, 4.0) == q.x)\\n    {\\n        if (clamp(q.y, 0.0, 4.0) == q.y)\\n        {\\n        if (i32(modulo(n/exp2(q.x + 5.0*q.y), 2.0)) == 1)\\n        {\\n            return 1.0;\\n        }\\n        }\\n    }\\n\\n    return 0.0;\\n}\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\\n\\nfn moduloVec2(x: vec2<f32>, y: vec2<f32>) -> vec2<f32>\\n{\\n  return x - y * floor(x/y);\\n}\\n\\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n    var mappedCoord: vec2<f32> = coord;\\n    mappedCoord *= gfu.uInputSize.xy;\\n    mappedCoord += gfu.uOutputFrame.xy;\\n    return mappedCoord;\\n}\\n\\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n    var mappedCoord: vec2<f32> = coord;\\n    mappedCoord -= gfu.uOutputFrame.xy;\\n    mappedCoord /= gfu.uInputSize.xy;\\n    return mappedCoord;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=ascii2.mjs.map\n", "import { Color, ColorSource, deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './ascii.frag';\nimport source from './ascii.wgsl';\n\n// This WebGPU filter has been ported from the WebGL renderer that was originally created by Vico (@vicocotea)\n\n/** Options for AsciiFilter constructor. */\nexport interface AsciiFilterOptions\n{\n    /**\n     * The pixel size used by the filter\n     * @default 8\n     */\n    size?: number;\n    /**\n     * A color to set the ascii characters to. If not set, the color will be taken from the source.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0x000000\n     */\n    color?: ColorSource;\n    /**\n     * Determine whether or not to replace the source colors with the provided.\n     *\n     * Will automatically be assigned to `true` if `color` is provided.\n     * Set `replaceColor` to `false` to prevent that.\n     * @default false\n     */\n    replaceColor?: boolean;\n}\n\n/**\n * An ASCII filter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/ascii.png)\n *\n * @class\n * @extends Filter\n */\nexport class AsciiFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: AsciiFilterOptions = {\n        size: 8,\n        color: 0xffffff,\n        replaceColor: false,\n    };\n\n    public uniforms: {\n        uSize: number;\n        uColor: Float32Array;\n        uReplaceColor: number;\n    };\n\n    private _color!: Color;\n\n    /**\n     * Constructor.\n     * @param {AsciiFilterOptions} options - The options of the ASCII filter.\n     */\n    constructor(options?: AsciiFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number} [size=8] - Size of the font\n     */\n    constructor(size: number);\n    /** @ignore */\n    constructor(...args: [AsciiFilterOptions?] | [number])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'AsciiFilter constructor params are now options object. See params: { size, color, replaceColor }');\n\n            options = { size: options };\n        }\n\n        const replaceColor = options?.color && options.replaceColor !== false;\n\n        options = { ...AsciiFilter.DEFAULT_OPTIONS, ...options } as AsciiFilterOptions;\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'ascii-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                asciiUniforms: {\n                    uSize: { value: options.size, type: 'f32' },\n                    uColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uReplaceColor: { value: Number(replaceColor), type: 'f32' },\n                },\n            },\n        });\n\n        this.uniforms = this.resources.asciiUniforms.uniforms;\n        this._color = new Color();\n        this.color = options.color ?? 0xffffff;\n    }\n\n    /**\n     * The pixel size used by the filter.\n     * @default 8\n     */\n    get size(): number { return this.uniforms.uSize; }\n    set size(value: number) { this.uniforms.uSize = value; }\n\n    /**\n     * The resulting color of the ascii characters, as a 3 component RGB or numerical hex\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0xffffff\n     */\n    get color(): ColorSource { return this._color.value as ColorSource; }\n    set color(value: ColorSource)\n    {\n        this._color.setValue(value);\n        const [r, g, b] = this._color.toArray();\n\n        this.uniforms.uColor[0] = r;\n        this.uniforms.uColor[1] = g;\n        this.uniforms.uColor[2] = b;\n    }\n\n    /**\n     * Determine whether or not to replace the source colors with the provided.\n     */\n    get replaceColor(): boolean { return this.uniforms.uReplaceColor > 0.5; }\n    set replaceColor(value: boolean) { this.uniforms.uReplaceColor = value ? 1 : 0; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uBackground;\\n\\nvoid main(void){\\n    vec4 front = texture(uTexture, vTextureCoord);\\n    vec4 back = texture(uBackground, vTextureCoord);\\n\\n    if (front.a == 0.0) {\\n        discard;\\n    }\\n    \\n    vec3 color = mix(back.rgb, front.rgb / front.a, front.a);\\n\\n    finalColor = vec4(color, 1.0);\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=backdrop-blur-blend2.mjs.map\n", "var wgslFragment = \"@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var uBackground: texture_2d<f32>; \\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n    var front: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n    var back: vec4<f32> = textureSample(uBackground, uSampler, uv);\\n    \\n    if (front.a == 0.0) {\\n        discard;\\n    }\\n\\n    var color: vec3<f32> = mix(back.rgb, front.rgb / front.a, front.a);\\n\\n    return vec4<f32>(color, 1.0);\\n}\";\n\nexport { wgslFragment as default };\n//# sourceMappingURL=backdrop-blur-blend.mjs.map\n", "import {\n    BlurFilter,\n    BlurFilterOptions,\n    Filter,\n    FilterSystem,\n    GlProgram,\n    GpuProgram,\n    RenderSurface,\n    Texture,\n    TexturePool,\n} from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './backdrop-blur-blend.frag';\nimport wgslFragment from './backdrop-blur-blend.wgsl';\n\n/**\n * The BackdropBlurFilter applies a Gaussian blur to everything behind an object, and then draws the object on top of it.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/backdrop-blur.png)\n *\n * @class\n * @extends BlurFilter\n */\nexport class BackdropBlurFilter extends BlurFilter\n{\n    private _blendPass: Filter;\n\n    /**\n     * @param options - The options of the blur filter.\n     */\n    constructor(options?: BlurFilterOptions)\n    {\n        super(options);\n\n        this.blendRequired = true;\n        this.padding = 0;\n\n        this._blendPass = new Filter({\n            gpuProgram: GpuProgram.from({\n                vertex: {\n                    source: wgslVertex,\n                    entryPoint: 'mainVertex',\n                },\n                fragment: {\n                    source: wgslFragment,\n                    entryPoint: 'mainFragment',\n                },\n            }),\n            glProgram: GlProgram.from({\n                vertex,\n                fragment,\n                name: 'drop-shadow-filter',\n            }),\n            resources: {\n                uBackground: Texture.EMPTY,\n            },\n        });\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        // @ts-expect-error - this should probably not be grabbed from a private property\n        const backTexture = filterManager._activeFilterData.backTexture;\n\n        const blurredBackground = TexturePool.getSameSizeTexture(input);\n\n        super.apply(filterManager, backTexture, blurredBackground, true);\n\n        this._blendPass.resources.uBackground = blurredBackground.source;\n        this._blendPass.apply(filterManager, input, output, clearMode);\n\n        TexturePool.returnTexture(blurredBackground);\n    }\n\n    protected updatePadding(): void\n    {\n        this.padding = 0;\n    }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uTransform;\\nuniform vec3 uLightColor;\\nuniform float uLightAlpha;\\nuniform vec3 uShadowColor;\\nuniform float uShadowAlpha;\\n\\nuniform vec4 uInputSize;\\n\\nvoid main(void) {\\n    vec2 transform = vec2(1.0 / uInputSize) * vec2(uTransform.x, uTransform.y);\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    float light = texture(uTexture, vTextureCoord - transform).a;\\n    float shadow = texture(uTexture, vTextureCoord + transform).a;\\n\\n    color.rgb = mix(color.rgb, uLightColor, clamp((color.a - light) * uLightAlpha, 0.0, 1.0));\\n    color.rgb = mix(color.rgb, uShadowColor, clamp((color.a - shadow) * uShadowAlpha, 0.0, 1.0));\\n    finalColor = vec4(color.rgb * color.a, color.a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=bevel.mjs.map\n", "var source = \"struct BevelUniforms {\\n  uLightColor: vec3<f32>,\\n  uLightAlpha: f32,\\n  uShadowColor: vec3<f32>,\\n  uShadowAlpha: f32,\\n  uTransform: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> bevelUniforms : BevelUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let transform = vec2<f32>(1.0 / gfu.uInputSize.xy) * vec2<f32>(bevelUniforms.uTransform.x, bevelUniforms.uTransform.y);\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let lightSample: f32 = textureSample(uTexture, uSampler, uv - transform).a;\\n  let shadowSample: f32 = textureSample(uTexture, uSampler, uv + transform).a;\\n\\n  let light = vec4<f32>(bevelUniforms.uLightColor, bevelUniforms.uLightAlpha);\\n  let shadow = vec4<f32>(bevelUniforms.uShadowColor, bevelUniforms.uShadowAlpha);\\n\\n  color = vec4<f32>(mix(color.rgb, light.rgb, clamp((color.a - lightSample) * light.a, 0.0, 1.0)), color.a);\\n  color = vec4<f32>(mix(color.rgb, shadow.rgb, clamp((color.a - shadowSample) * shadow.a, 0.0, 1.0)), color.a);\\n  \\n  return vec4<f32>(color.rgb * color.a, color.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=bevel2.mjs.map\n", "import { Color, ColorSource, DEG_TO_RAD, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './bevel.frag';\nimport source from './bevel.wgsl';\n\n/** Options for the BevelFilter constructor. */\nexport interface BevelFilterOptions\n{\n    /**\n     * The angle of the light in degrees\n     * @default 45\n     */\n    rotation?: number,\n    /**\n     * The thickness of the bevel\n     * @default 2\n     */\n    thickness?: number,\n    /**\n     * The color value of the left & top bevel.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0xffffff\n     */\n    lightColor?: ColorSource,\n    /**\n     * The alpha value of the left & top bevel.\n     * @default 0.7\n     */\n    lightAlpha?: number,\n    /**\n     * The color value of the right & bottom bevel.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0x000000\n     */\n    shadowColor?: ColorSource,\n    /**\n     * The alpha value of the right & bottom bevel.\n     * @default 0.7\n     */\n    shadowAlpha?: number,\n}\n\n/**\n * Bevel Filter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/bevel.png)\n *\n * @class\n * @extends Filter\n */\nexport class BevelFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: BevelFilterOptions = {\n        rotation: 45,\n        thickness: 2,\n        lightColor: 0xffffff,\n        lightAlpha: 0.7,\n        shadowColor: 0x000000,\n        shadowAlpha: 0.7,\n    };\n\n    public uniforms: {\n        uLightColor: Float32Array;\n        uLightAlpha: number;\n        uShadowColor: Float32Array;\n        uShadowAlpha: number;\n        uTransform: Float32Array;\n    };\n\n    private _thickness!: number;\n    private _rotation!: number;\n    private _lightColor: Color;\n    private _shadowColor: Color;\n\n    /**\n     * @param options - Options for the BevelFilter constructor.\n     */\n    constructor(options?: BevelFilterOptions)\n    {\n        options = { ...BevelFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'bevel-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                bevelUniforms: {\n                    uLightColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uLightAlpha: { value: options.lightAlpha, type: 'f32' },\n                    uShadowColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uShadowAlpha: { value: options.shadowAlpha, type: 'f32' },\n                    uTransform: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n            // Workaround: https://github.com/pixijs/filters/issues/230\n            // applies correctly only if there is at least a single-pixel padding with alpha=0 around an image\n            // To solve this problem, a padding of 1 put on the filter should suffice\n            padding: 1,\n        });\n\n        this.uniforms = this.resources.bevelUniforms.uniforms;\n        this._lightColor = new Color();\n        this._shadowColor = new Color();\n        this.lightColor = options.lightColor ?? 0xffffff;\n        this.shadowColor = options.shadowColor ?? 0x000000;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * The angle of the light in degrees\n     * @default 45\n     */\n    get rotation(): number { return this._rotation / DEG_TO_RAD; }\n    set rotation(value: number)\n    {\n        this._rotation = value * DEG_TO_RAD;\n        this._updateTransform();\n    }\n\n    /**\n     * The thickness of the bevel\n     * @default 2\n     */\n    get thickness(): number { return this._thickness; }\n    set thickness(value: number)\n    {\n        this._thickness = value;\n        this._updateTransform();\n    }\n\n    /**\n     * The color value of the left & top bevel.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0xffffff\n     */\n    get lightColor(): ColorSource { return this._lightColor.value as ColorSource; }\n    set lightColor(value: ColorSource)\n    {\n        this._lightColor.setValue(value);\n        const [r, g, b] = this._lightColor.toArray();\n\n        this.uniforms.uLightColor[0] = r;\n        this.uniforms.uLightColor[1] = g;\n        this.uniforms.uLightColor[2] = b;\n    }\n\n    /**\n     * The alpha value of the left & top bevel.\n     * @default 0.7\n     */\n    get lightAlpha(): number { return this.uniforms.uLightAlpha; }\n    set lightAlpha(value: number) { this.uniforms.uLightAlpha = value; }\n\n    /**\n     * The color value of the right & bottom bevel.\n     * @default 0xffffff\n     */\n    get shadowColor(): ColorSource { return this._shadowColor.value as ColorSource; }\n    set shadowColor(value: ColorSource)\n    {\n        this._shadowColor.setValue(value);\n        const [r, g, b] = this._shadowColor.toArray();\n\n        this.uniforms.uShadowColor[0] = r;\n        this.uniforms.uShadowColor[1] = g;\n        this.uniforms.uShadowColor[2] = b;\n    }\n\n    /**\n     * The alpha value of the right & bottom bevel.\n     * @default 0.7\n     */\n    get shadowAlpha(): number { return this.uniforms.uShadowAlpha; }\n    set shadowAlpha(value: number) { this.uniforms.uShadowAlpha = value; }\n\n    /**\n     * Update the transform matrix of offset angle.\n     * @private\n     */\n    private _updateTransform()\n    {\n        this.uniforms.uTransform[0] = this.thickness * Math.cos(this._rotation);\n        this.uniforms.uTransform[1] = this.thickness * Math.sin(this._rotation);\n    }\n}\n", "/* eslint-disable max-len */\nimport {\n    AlphaFilter,\n    BlurFilterPass,\n    deprecation,\n    FilterSystem,\n    PointData,\n    RenderSurface,\n    Texture,\n    TexturePool,\n} from 'pixi.js';\n\ntype DeprecatedBlurValue = number | PointData | number[];\n\n/** Options for the BloomFilter constructor. */\nexport interface BloomFilterOptions\n{\n    /**\n     * Sets the strength of the blur. If only a number is provided, it will assign to both x and y.\n     * @default {x:2,y:2}\n     */\n    strength?: PointData | number;\n    /**\n     * The quality of the blur.\n     * @default 4\n     */\n    quality?: number;\n    /**\n     * The resolution of the blurX & blurY filter.\n     * @default 1\n     */\n    resolution?: number;\n    /**\n     * The kernel size of the blur filter. Must be an odd number between 5 and 15 (inclusive).\n     * @default 5\n     */\n    kernelSize?: number;\n}\n\n/**\n * The BloomFilter applies a Gaussian blur to an object.\n * The strength of the blur can be set for x- and y-axis separately.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/bloom.png)\n *\n * @class\n * @extends Filter\n */\nexport class BloomFilter extends AlphaFilter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: BloomFilterOptions = {\n        strength: { x: 2, y: 2 },\n        quality: 4,\n        resolution: 1,\n        kernelSize: 5\n    };\n\n    private _blurXFilter: BlurFilterPass;\n    private _blurYFilter: BlurFilterPass;\n    private _strength: PointData;\n\n    /**\n     * @param {BloomFilterOptions} options - Options for the BloomFilter constructor.\n     */\n    constructor(options?: BloomFilterOptions);\n    /**\n    * @deprecated since 6.0.0\n    *\n    * @param {number|PIXI.PointData|number[]} [blur=2] - Sets the strength of both the blurX and blurY properties simultaneously\n    * @param {number} [quality=4] - The quality of the blurX & blurY filter.\n    * @param {number} [resolution=1] - The resolution of the blurX & blurY filter.\n    * @param {number} [kernelSize=5] - The kernelSize of the blurX & blurY filter.Options: 5, 7, 9, 11, 13, 15.\n    */\n    constructor(blur?: DeprecatedBlurValue, quality?: number, resolution?: number, kernelSize?: number);\n    /** @ignore */\n    constructor(...args: [BloomFilterOptions?] | [DeprecatedBlurValue?, number?, number?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number' || Array.isArray(options) || ('x' in options && 'y' in options))\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'BloomFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }');\n\n            let strength = options;\n\n            if (Array.isArray(strength)) strength = { x: strength[0], y: strength[1] };\n\n            options = { strength };\n\n            if (args[1] !== undefined) options.quality = args[1];\n            if (args[2] !== undefined) options.resolution = args[2];\n            if (args[3] !== undefined) options.kernelSize = args[3];\n        }\n\n        options = { ...BloomFilter.DEFAULT_OPTIONS, ...options } as BloomFilterOptions;\n\n        super();\n\n        this._strength = { x: 2, y: 2 };\n\n        if (options.strength)\n        {\n            if (typeof options.strength === 'number')\n            {\n                this._strength.x = options.strength;\n                this._strength.y = options.strength;\n            }\n            else\n            {\n                this._strength.x = options.strength.x;\n                this._strength.y = options.strength.y;\n            }\n        }\n\n        this._blurXFilter = new BlurFilterPass({\n            ...options,\n            horizontal: true,\n            strength: this.strengthX,\n        });\n\n        this._blurYFilter = new BlurFilterPass({\n            ...options,\n            horizontal: false,\n            strength: this.strengthY,\n        });\n\n        this._blurYFilter.blendMode = 'screen';\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clear: boolean,\n    ): void\n    {\n        const renderTarget = TexturePool.getSameSizeTexture(input);\n\n        filterManager.applyFilter(this, input, output, clear);\n        this._blurXFilter.apply(filterManager, input, renderTarget, true);\n        this._blurYFilter.apply(filterManager, renderTarget, output, false);\n\n        TexturePool.returnTexture(renderTarget);\n    }\n\n    /**\n     * Sets the strength of both the blurX and blurY properties simultaneously\n     * @default 2\n     */\n    get strength(): PointData { return this._strength; }\n    set strength(value: PointData | number)\n    {\n        this._strength = typeof value === 'number' ? { x: value, y: value } : value;\n        this._updateStrength();\n    }\n\n    /**\n     * Sets the strength of the blur on the `x` axis\n     * @default 2\n     */\n    get strengthX(): number { return this.strength.x; }\n    set strengthX(value: number)\n    {\n        this.strength.x = value;\n        this._updateStrength();\n    }\n\n    /**\n     * Sets the strength of the blur on the `y` axis\n     * @default 2\n     */\n    get strengthY(): number { return this.strength.y; }\n    set strengthY(value: number)\n    {\n        this.strength.y = value;\n        this._updateStrength();\n    }\n\n    private _updateStrength()\n    {\n        this._blurXFilter.blur = this.strengthX;\n        this._blurYFilter.blur = this.strengthY;\n    }\n\n    /**\n     * @deprecated since 6.0.0\n     *\n     * The strength of both the blurX and blurY properties simultaneously\n     * @default 2\n     * @see BloomFilter#strength\n     */\n    get blur(): number\n    {\n        deprecation('6.0.0', 'BloomFilter.blur is deprecated, please use BloomFilter.strength instead');\n\n        return this.strengthX;\n    }\n    set blur(value: number)\n    {\n        deprecation('6.0.0', 'BloomFilter.blur is deprecated, please use BloomFilter.strength instead');\n\n        this.strength = value;\n    }\n\n    /**\n     * @deprecated since 6.0.0\n     *\n     * The strength of the blurX property\n     * @default 2\n     * @see BloomFilter#strengthX\n     */\n    get blurX(): number\n    {\n        deprecation('6.0.0', 'BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead');\n\n        return this.strengthX;\n    }\n    set blurX(value: number)\n    {\n        deprecation('6.0.0', 'BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead');\n\n        this.strengthX = value;\n    }\n\n    /**\n     * @deprecated since 6.0.0\n     *\n     * The strength of the blurY property\n     * @default 2\n     * @see BloomFilter#strengthY\n     */\n    get blurY(): number\n    {\n        deprecation('6.0.0', 'BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead');\n\n        return this.strengthY;\n    }\n    set blurY(value: number)\n    {\n        deprecation('6.0.0', 'BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead');\n\n        this.strengthY = value;\n    }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uDimensions;\\nuniform vec2 uCenter;\\nuniform float uRadius;\\nuniform float uStrength;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nvoid main()\\n{\\n    vec2 coord = vTextureCoord * uInputSize.xy;\\n    coord -= uCenter * uDimensions.xy;\\n    float distance = length(coord);\\n\\n    if (distance < uRadius) {\\n        float percent = distance / uRadius;\\n        if (uStrength > 0.0) {\\n            coord *= mix(1.0, smoothstep(0.0, uRadius / distance, percent), uStrength * 0.75);\\n        } else {\\n            coord *= mix(1.0, pow(percent, 1.0 + uStrength * 0.75) * uRadius / distance, 1.0 - percent);\\n        }\\n    }\\n\\n    coord += uCenter * uDimensions.xy;\\n    coord /= uInputSize.xy;\\n    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\\n    vec4 color = texture(uTexture, clampedCoord);\\n\\n    if (coord != clampedCoord) {\\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\\n    }\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=bulge-pinch.mjs.map\n", "var source = \"struct BulgePinchUniforms {\\n  uDimensions: vec2<f32>,\\n  uCenter: vec2<f32>,\\n  uRadius: f32,\\n  uStrength: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> bulgePinchUniforms : BulgePinchUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let dimensions: vec2<f32> = bulgePinchUniforms.uDimensions;\\n  let center: vec2<f32> = bulgePinchUniforms.uCenter;\\n  let radius: f32 = bulgePinchUniforms.uRadius;\\n  let strength: f32 = bulgePinchUniforms.uStrength;\\n  var coord: vec2<f32> = (uv * gfu.uInputSize.xy) - center * dimensions.xy;\\n\\n  let distance: f32 = length(coord);\\n\\n  if (distance < radius) {\\n      let percent: f32 = distance / radius;\\n      if (strength > 0.0) {\\n          coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\\n      } else {\\n          coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\\n      }\\n  }\\n    coord += (center * dimensions.xy);\\n    coord /= gfu.uInputSize.xy;\\n\\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);\\n    var color: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);\\n    if (coord.x != clampedCoord.x && coord.y != clampedCoord.y) {\\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\\n    }\\n\\n    return color;\\n}\\n\\nfn compareVec2(x: vec2<f32>, y: vec2<f32>) -> bool\\n{\\n  if (x.x == y.x && x.y == y.y)\\n  {\\n    return true;\\n  }\\n\\n  return false;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=bulge-pinch2.mjs.map\n", "import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './bulge-pinch.frag';\nimport source from './bulge-pinch.wgsl';\n\nimport type { FilterSystem, PointData, RenderSurface, Texture } from 'pixi.js';\n\n// This WebGPU filter has been ported from the WebGL renderer that was originally created by Julien CLEREL (@JuloxRox)\n\n/** Options for the BulgePinchFilter constructor. */\nexport interface BulgePinchFilterOptions\n{\n    /**\n     * Offset coordinates to change the position of the center of the circle of effect.\n     * @default {x:0,y:0}\n     */\n    center?: PointData | number[] | number;\n    /**\n     * The radius of the circle of effect\n     * @default 100\n     */\n    radius?: number;\n    /**\n     * A value between -1 and 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)\n     * @default 1\n     */\n    strength?: number;\n}\n\n/**\n * Bulges or pinches the image in a circle.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/bulge-pinch.gif)\n *\n * @class\n * @extends Filter\n */\nexport class BulgePinchFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: BulgePinchFilterOptions = {\n        center: { x: 0.5, y: 0.5 },\n        radius: 100,\n        strength: 1\n    };\n\n    public uniforms: {\n        uDimensions: Float32Array;\n        uCenter: PointData;\n        uRadius: number;\n        uStrength: number;\n    };\n\n    /**\n     * @param options - Options for the BulgePinchFilter constructor.\n     */\n    constructor(options?: BulgePinchFilterOptions)\n    {\n        options = { ...BulgePinchFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'bulge-pinch-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                bulgePinchUniforms: {\n                    uDimensions: { value: [0, 0], type: 'vec2<f32>' },\n                    uCenter: { value: options.center, type: 'vec2<f32>' },\n                    uRadius: { value: options.radius, type: 'f32' },\n                    uStrength: { value: options.strength, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.bulgePinchUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        this.uniforms.uDimensions[0] = input.frame.width;\n        this.uniforms.uDimensions[1] = input.frame.height;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Sets the center of the effect in normalized screen coords.\n     * { x: 0, y: 0 } means top-left and { x: 1, y: 1 } mean bottom-right\n     * @default {x:0.5,y:0.5}\n     */\n    get center(): PointData { return this.uniforms.uCenter; }\n    set center(value: PointData | number[] | number)\n    {\n        if (typeof value === 'number')\n        {\n            value = { x: value, y: value };\n        }\n\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uCenter = value;\n    }\n\n    /**\n     * Sets the center of the effect in normalized screen coords on the `x` axis\n     * @default 0\n     */\n    get centerX(): number { return this.uniforms.uCenter.x; }\n    set centerX(value: number) { this.uniforms.uCenter.x = value; }\n\n    /**\n     * Sets the center of the effect in normalized screen coords on the `y` axis\n     * @default 0\n     */\n    get centerY(): number { return this.uniforms.uCenter.y; }\n    set centerY(value: number) { this.uniforms.uCenter.y = value; }\n\n    /**\n     * The radius of the circle of effect\n     * @default 100\n     */\n    get radius(): number { return this.uniforms.uRadius; }\n    set radius(value: number) { this.uniforms.uRadius = value; }\n\n    /**\n     * A value between -1 and 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)\n     * @default 1\n     */\n    get strength(): number { return this.uniforms.uStrength; }\n    set strength(value: number) { this.uniforms.uStrength = value; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nin vec2 vFilterCoord;\\nout vec4 finalColor;\\n\\nconst int TYPE_LINEAR = 0;\\nconst int TYPE_RADIAL = 1;\\nconst int TYPE_CONIC = 2;\\nconst int MAX_STOPS = 32;\\n\\nuniform sampler2D uTexture;\\nuniform vec4 uOptions;\\nuniform vec2 uCounts;\\nuniform vec3 uColors[MAX_STOPS];\\nuniform vec4 uStops[MAX_STOPS];\\n\\nconst float PI = 3.1415926538;\\nconst float PI_2 = PI*2.;\\n\\nstruct ColorStop {\\n    float offset;\\n    vec3 color;\\n    float alpha;\\n};\\n\\nmat2 rotate2d(float angle){\\n    return mat2(cos(angle), -sin(angle),\\n    sin(angle), cos(angle));\\n}\\n\\nfloat projectLinearPosition(vec2 pos, float angle){\\n    vec2 center = vec2(0.5);\\n    vec2 result = pos - center;\\n    result = rotate2d(angle) * result;\\n    result = result + center;\\n    return clamp(result.x, 0., 1.);\\n}\\n\\nfloat projectRadialPosition(vec2 pos) {\\n    float r = distance(pos, vec2(0.5));\\n    return clamp(2.*r, 0., 1.);\\n}\\n\\nfloat projectAnglePosition(vec2 pos, float angle) {\\n    vec2 center = pos - vec2(0.5);\\n    float polarAngle=atan(-center.y, center.x);\\n    return mod(polarAngle + angle, PI_2) / PI_2;\\n}\\n\\nfloat projectPosition(vec2 pos, int type, float angle) {\\n    if (type == TYPE_LINEAR) {\\n        return projectLinearPosition(pos, angle);\\n    } else if (type == TYPE_RADIAL) {\\n        return projectRadialPosition(pos);\\n    } else if (type == TYPE_CONIC) {\\n        return projectAnglePosition(pos, angle);\\n    }\\n\\n    return pos.y;\\n}\\n\\nvoid main(void) {\\n    int uType = int(uOptions[0]);\\n    float uAngle = uOptions[1];\\n    float uAlpha = uOptions[2];\\n    float uReplace = uOptions[3];\\n\\n    int uNumStops = int(uCounts[0]);\\n    float uMaxColors = uCounts[1];\\n\\n    // current/original color\\n    vec4 currentColor = texture(uTexture, vTextureCoord);\\n\\n    // skip calculations if gradient alpha is 0\\n    if (0.0 == uAlpha) {\\n        finalColor = currentColor;\\n        return;\\n    }\\n\\n    // project position\\n    float y = projectPosition(vFilterCoord, int(uType), radians(uAngle));\\n\\n    // check gradient bounds\\n    float offsetMin = uStops[0][0];\\n    float offsetMax = 0.0;\\n\\n    int numStops = int(uNumStops);\\n\\n    for (int i = 0; i < MAX_STOPS; i++) {\\n        if (i == numStops-1){ // last index\\n            offsetMax = uStops[i][0];\\n        }\\n    }\\n\\n    if (y  < offsetMin || y > offsetMax) {\\n        finalColor = currentColor;\\n        return;\\n    }\\n\\n    // limit colors\\n    if (uMaxColors > 0.) {\\n        float stepSize = 1./uMaxColors;\\n        float stepNumber = float(floor(y/stepSize));\\n        y = stepSize * (stepNumber + 0.5);// offset by 0.5 to use color from middle of segment\\n    }\\n\\n    // find color stops\\n    ColorStop from;\\n    ColorStop to;\\n\\n    for (int i = 0; i < MAX_STOPS; i++) {\\n        if (y >= uStops[i][0]) {\\n            from = ColorStop(uStops[i][0], uColors[i], uStops[i][1]);\\n            to = ColorStop(uStops[i+1][0], uColors[i+1], uStops[i+1][1]);\\n        }\\n\\n        if (i == numStops-1){ // last index\\n            break;\\n        }\\n    }\\n\\n    // mix colors from stops\\n    vec4 colorFrom = vec4(from.color * from.alpha, from.alpha);\\n    vec4 colorTo = vec4(to.color * to.alpha, to.alpha);\\n\\n    float segmentHeight = to.offset - from.offset;\\n    float relativePos = y - from.offset;// position from 0 to [segmentHeight]\\n    float relativePercent = relativePos / segmentHeight;// position in percent between [from.offset] and [to.offset].\\n\\n    float gradientAlpha = uAlpha * currentColor.a;\\n    vec4 gradientColor = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\\n\\n    if (uReplace < 0.5) {\\n        // mix resulting color with current color\\n        finalColor = gradientColor + currentColor*(1.-gradientColor.a);\\n    } else {\\n        // replace with gradient color\\n        finalColor = gradientColor;\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=color-gradient2.mjs.map\n", "var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\nout vec2 vFilterCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n    vFilterCoord = vTextureCoord * uInputSize.xy / uOutputFrame.zw;\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=color-gradient.mjs.map\n", "var source = \"struct BaseUniforms {\\n  uOptions: vec4<f32>,\\n  uCounts: vec2<f32>,\\n};\\n\\nstruct StopsUniforms {\\n  uColors: array<vec3<f32>, MAX_STOPS>,\\n  uStops: array<vec4<f32>, MAX_STOPS>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> baseUniforms : BaseUniforms;\\n@group(1) @binding(1) var<uniform> stopsUniforms : StopsUniforms;\\n\\nstruct VSOutput {\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>,\\n  @location(1) coord : vec2<f32>\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn filterCoord( vTextureCoord:vec2<f32> ) -> vec2<f32>\\n{\\n    return vTextureCoord * gfu.uInputSize.xy / gfu.uOutputFrame.zw;\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  let vTextureCoord: vec2<f32> = filterTextureCoord(aPosition);\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   vTextureCoord,\\n   filterCoord(vTextureCoord),\\n  );\\n}\\n\\nstruct ColorStop {\\n  offset: f32,\\n  color: vec3<f32>,\\n  alpha: f32,\\n};\\n\\nfn rotate2d(angle: f32) -> mat2x2<f32>{\\n  return mat2x2(cos(angle), -sin(angle),\\n  sin(angle), cos(angle));\\n}\\n\\nfn projectLinearPosition(pos: vec2<f32>, angle: f32) -> f32 {\\n  var center: vec2<f32> = vec2<f32>(0.5);\\n  var result: vec2<f32> = pos - center;\\n  result = rotate2d(angle) * result;\\n  result = result + center;\\n  return clamp(result.x, 0.0, 1.0);\\n}\\n\\nfn projectRadialPosition(pos: vec2<f32>) -> f32 {\\n  var r: f32 = distance(pos, vec2<f32>(0.5));\\n  return clamp(2.0 * r, 0.0, 1.0);\\n}\\n\\nfn projectAnglePosition(pos: vec2<f32>, angle: f32) -> f32 {\\n  var center: vec2<f32> = pos - vec2<f32>(0.5, 0.5);\\n  var polarAngle: f32 = atan2(-center.y, center.x);\\n  return ((polarAngle + angle) % PI_2) / PI_2;\\n}\\n\\nfn projectPosition(pos: vec2<f32>, gradientType: i32, angle: f32) -> f32 {\\n  if (gradientType == TYPE_LINEAR) {\\n      return projectLinearPosition(pos, angle);\\n  } else if (gradientType == TYPE_RADIAL) {\\n      return projectRadialPosition(pos);\\n  } else if (gradientType == TYPE_CONIC) {\\n      return projectAnglePosition(pos, angle);\\n  }\\n\\n  return pos.y;\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>,\\n  @location(1) coord : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uType: i32 = i32(baseUniforms.uOptions[0]);\\n  let uAngle: f32 = baseUniforms.uOptions[1];\\n  let uAlpha: f32 = baseUniforms.uOptions[2];\\n  let uReplace: f32 = baseUniforms.uOptions[3];\\n\\n  let uNumStops: i32 = i32(baseUniforms.uCounts[0]);\\n  let uMaxColors: f32 = baseUniforms.uCounts[1];\\n\\n  // current/original color\\n  var currentColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  // skip calculations if gradient alpha is 0\\n  if (uAlpha == 0.0) { return currentColor; }\\n\\n  // project position\\n  var y: f32 = projectPosition(coord, uType, radians(uAngle));\\n\\n  // check gradient bounds\\n  var offsetMin: f32 = stopsUniforms.uStops[0][0];\\n  var offsetMax: f32 = 0.0;\\n\\n  let numStops: i32 = uNumStops;\\n\\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\\n      if (i == numStops - 1) { // last index\\n          offsetMax = stopsUniforms.uStops[i][0];\\n      }\\n  }\\n\\n  if (y  < offsetMin || y > offsetMax) { return currentColor; }\\n\\n  // limit colors\\n  if (uMaxColors > 0.0) {\\n      var stepSize: f32 = 1.0 / uMaxColors;\\n      var stepNumber: f32 = floor(y / stepSize);\\n      y = stepSize * (stepNumber + 0.5); // offset by 0.5 to use color from middle of segment\\n  }\\n\\n  // find color stops\\n  var stopFrom: ColorStop;\\n  var stopTo: ColorStop;\\n\\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\\n      if (y >= stopsUniforms.uStops[i][0]) {\\n          stopFrom = ColorStop(stopsUniforms.uStops[i][0], stopsUniforms.uColors[i], stopsUniforms.uStops[i][1]);\\n          stopTo = ColorStop(stopsUniforms.uStops[i + 1][0], stopsUniforms.uColors[i + 1], stopsUniforms.uStops[i + 1][1]);\\n      }\\n\\n      if (i == numStops - 1) { // last index\\n          break;\\n      }\\n  }\\n\\n  // mix colors from stops\\n  var colorFrom: vec4<f32> = vec4<f32>(stopFrom.color * stopFrom.alpha, stopFrom.alpha);\\n  var colorTo: vec4<f32> = vec4<f32>(stopTo.color * stopTo.alpha, stopTo.alpha);\\n\\n  var segmentHeight: f32 = stopTo.offset - stopFrom.offset;\\n  var relativePos: f32 = y - stopFrom.offset; // position from 0 to [segmentHeight]\\n  var relativePercent: f32 = relativePos / segmentHeight; // position in percent between [from.offset] and [to.offset].\\n\\n  var gradientAlpha: f32 = uAlpha * currentColor.a;\\n  var gradientColor: vec4<f32> = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\\n\\n  if (uReplace < 0.5) {\\n      // mix resulting color with current color\\n      return gradientColor + currentColor * (1.0 - gradientColor.a);\\n  } else {\\n      // replace with gradient color\\n      return gradientColor;\\n  }\\n}\\n\\nconst PI: f32 = 3.14159265358979323846264;\\nconst PI_2: f32 = PI * 2.0;\\n\\nconst TYPE_LINEAR: i32 = 0;\\nconst TYPE_RADIAL: i32 = 1;\\nconst TYPE_CONIC: i32 = 2;\\nconst MAX_STOPS: i32 = 32;\";\n\nexport { source as default };\n//# sourceMappingURL=color-gradient3.mjs.map\n", "// Copyright (c) 2014 Rafael Caricio. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nvar GradientParser = (GradientParser || {});\n\nGradientParser.stringify = (function() {\n\n  var visitor = {\n\n    'visit_linear-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_repeating-linear-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_radial-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_repeating-radial-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_gradient': function(node) {\n      var orientation = visitor.visit(node.orientation);\n      if (orientation) {\n        orientation += ', ';\n      }\n\n      return node.type + '(' + orientation + visitor.visit(node.colorStops) + ')';\n    },\n\n    'visit_shape': function(node) {\n      var result = node.value,\n          at = visitor.visit(node.at),\n          style = visitor.visit(node.style);\n\n      if (style) {\n        result += ' ' + style;\n      }\n\n      if (at) {\n        result += ' at ' + at;\n      }\n\n      return result;\n    },\n\n    'visit_default-radial': function(node) {\n      var result = '',\n          at = visitor.visit(node.at);\n\n      if (at) {\n        result += at;\n      }\n      return result;\n    },\n\n    'visit_extent-keyword': function(node) {\n      var result = node.value,\n          at = visitor.visit(node.at);\n\n      if (at) {\n        result += ' at ' + at;\n      }\n\n      return result;\n    },\n\n    'visit_position-keyword': function(node) {\n      return node.value;\n    },\n\n    'visit_position': function(node) {\n      return visitor.visit(node.value.x) + ' ' + visitor.visit(node.value.y);\n    },\n\n    'visit_%': function(node) {\n      return node.value + '%';\n    },\n\n    'visit_em': function(node) {\n      return node.value + 'em';\n    },\n\n    'visit_px': function(node) {\n      return node.value + 'px';\n    },\n\n    'visit_literal': function(node) {\n      return visitor.visit_color(node.value, node);\n    },\n\n    'visit_hex': function(node) {\n      return visitor.visit_color('#' + node.value, node);\n    },\n\n    'visit_rgb': function(node) {\n      return visitor.visit_color('rgb(' + node.value.join(', ') + ')', node);\n    },\n\n    'visit_rgba': function(node) {\n      return visitor.visit_color('rgba(' + node.value.join(', ') + ')', node);\n    },\n\n    'visit_color': function(resultColor, node) {\n      var result = resultColor,\n          length = visitor.visit(node.length);\n\n      if (length) {\n        result += ' ' + length;\n      }\n      return result;\n    },\n\n    'visit_angular': function(node) {\n      return node.value + 'deg';\n    },\n\n    'visit_directional': function(node) {\n      return 'to ' + node.value;\n    },\n\n    'visit_array': function(elements) {\n      var result = '',\n          size = elements.length;\n\n      elements.forEach(function(element, i) {\n        result += visitor.visit(element);\n        if (i < size - 1) {\n          result += ', ';\n        }\n      });\n\n      return result;\n    },\n\n    'visit': function(element) {\n      if (!element) {\n        return '';\n      }\n      var result = '';\n\n      if (element instanceof Array) {\n        return visitor.visit_array(element, result);\n      } else if (element.type) {\n        var nodeVisitor = visitor['visit_' + element.type];\n        if (nodeVisitor) {\n          return nodeVisitor(element);\n        } else {\n          throw Error('Missing visitor visit_' + element.type);\n        }\n      } else {\n        throw Error('Invalid node.');\n      }\n    }\n\n  };\n\n  return function(root) {\n    return visitor.visit(root);\n  };\n})();\n\n// Copyright (c) 2014 Rafael Caricio. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nvar GradientParser = (GradientParser || {});\n\nGradientParser.parse = (function() {\n\n  var tokens = {\n    linearGradient: /^(\\-(webkit|o|ms|moz)\\-)?(linear\\-gradient)/i,\n    repeatingLinearGradient: /^(\\-(webkit|o|ms|moz)\\-)?(repeating\\-linear\\-gradient)/i,\n    radialGradient: /^(\\-(webkit|o|ms|moz)\\-)?(radial\\-gradient)/i,\n    repeatingRadialGradient: /^(\\-(webkit|o|ms|moz)\\-)?(repeating\\-radial\\-gradient)/i,\n    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,\n    extentKeywords: /^(closest\\-side|closest\\-corner|farthest\\-side|farthest\\-corner|contain|cover)/,\n    positionKeywords: /^(left|center|right|top|bottom)/i,\n    pixelValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))px/,\n    percentageValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))\\%/,\n    emValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))em/,\n    angleValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))deg/,\n    startCall: /^\\(/,\n    endCall: /^\\)/,\n    comma: /^,/,\n    hexColor: /^\\#([0-9a-fA-F]+)/,\n    literalColor: /^([a-zA-Z]+)/,\n    rgbColor: /^rgb/i,\n    rgbaColor: /^rgba/i,\n    number: /^(([0-9]*\\.[0-9]+)|([0-9]+\\.?))/\n  };\n\n  var input = '';\n\n  function error(msg) {\n    var err = new Error(input + ': ' + msg);\n    err.source = input;\n    throw err;\n  }\n\n  function getAST() {\n    var ast = matchListDefinitions();\n\n    if (input.length > 0) {\n      error('Invalid input not EOF');\n    }\n\n    return ast;\n  }\n\n  function matchListDefinitions() {\n    return matchListing(matchDefinition);\n  }\n\n  function matchDefinition() {\n    return matchGradient(\n            'linear-gradient',\n            tokens.linearGradient,\n            matchLinearOrientation) ||\n\n          matchGradient(\n            'repeating-linear-gradient',\n            tokens.repeatingLinearGradient,\n            matchLinearOrientation) ||\n\n          matchGradient(\n            'radial-gradient',\n            tokens.radialGradient,\n            matchListRadialOrientations) ||\n\n          matchGradient(\n            'repeating-radial-gradient',\n            tokens.repeatingRadialGradient,\n            matchListRadialOrientations);\n  }\n\n  function matchGradient(gradientType, pattern, orientationMatcher) {\n    return matchCall(pattern, function(captures) {\n\n      var orientation = orientationMatcher();\n      if (orientation) {\n        if (!scan(tokens.comma)) {\n          error('Missing comma before color stops');\n        }\n      }\n\n      return {\n        type: gradientType,\n        orientation: orientation,\n        colorStops: matchListing(matchColorStop)\n      };\n    });\n  }\n\n  function matchCall(pattern, callback) {\n    var captures = scan(pattern);\n\n    if (captures) {\n      if (!scan(tokens.startCall)) {\n        error('Missing (');\n      }\n\n      var result = callback(captures);\n\n      if (!scan(tokens.endCall)) {\n        error('Missing )');\n      }\n\n      return result;\n    }\n  }\n\n  function matchLinearOrientation() {\n    return matchSideOrCorner() ||\n      matchAngle();\n  }\n\n  function matchSideOrCorner() {\n    return match('directional', tokens.sideOrCorner, 1);\n  }\n\n  function matchAngle() {\n    return match('angular', tokens.angleValue, 1);\n  }\n\n  function matchListRadialOrientations() {\n    var radialOrientations,\n        radialOrientation = matchRadialOrientation(),\n        lookaheadCache;\n\n    if (radialOrientation) {\n      radialOrientations = [];\n      radialOrientations.push(radialOrientation);\n\n      lookaheadCache = input;\n      if (scan(tokens.comma)) {\n        radialOrientation = matchRadialOrientation();\n        if (radialOrientation) {\n          radialOrientations.push(radialOrientation);\n        } else {\n          input = lookaheadCache;\n        }\n      }\n    }\n\n    return radialOrientations;\n  }\n\n  function matchRadialOrientation() {\n    var radialType = matchCircle() ||\n      matchEllipse();\n\n    if (radialType) {\n      radialType.at = matchAtPosition();\n    } else {\n      var extent = matchExtentKeyword();\n      if (extent) {\n        radialType = extent;\n        var positionAt = matchAtPosition();\n        if (positionAt) {\n          radialType.at = positionAt;\n        }\n      } else {\n        var defaultPosition = matchPositioning();\n        if (defaultPosition) {\n          radialType = {\n            type: 'default-radial',\n            at: defaultPosition\n          };\n        }\n      }\n    }\n\n    return radialType;\n  }\n\n  function matchCircle() {\n    var circle = match('shape', /^(circle)/i, 0);\n\n    if (circle) {\n      circle.style = matchLength() || matchExtentKeyword();\n    }\n\n    return circle;\n  }\n\n  function matchEllipse() {\n    var ellipse = match('shape', /^(ellipse)/i, 0);\n\n    if (ellipse) {\n      ellipse.style =  matchDistance() || matchExtentKeyword();\n    }\n\n    return ellipse;\n  }\n\n  function matchExtentKeyword() {\n    return match('extent-keyword', tokens.extentKeywords, 1);\n  }\n\n  function matchAtPosition() {\n    if (match('position', /^at/, 0)) {\n      var positioning = matchPositioning();\n\n      if (!positioning) {\n        error('Missing positioning value');\n      }\n\n      return positioning;\n    }\n  }\n\n  function matchPositioning() {\n    var location = matchCoordinates();\n\n    if (location.x || location.y) {\n      return {\n        type: 'position',\n        value: location\n      };\n    }\n  }\n\n  function matchCoordinates() {\n    return {\n      x: matchDistance(),\n      y: matchDistance()\n    };\n  }\n\n  function matchListing(matcher) {\n    var captures = matcher(),\n      result = [];\n\n    if (captures) {\n      result.push(captures);\n      while (scan(tokens.comma)) {\n        captures = matcher();\n        if (captures) {\n          result.push(captures);\n        } else {\n          error('One extra comma');\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function matchColorStop() {\n    var color = matchColor();\n\n    if (!color) {\n      error('Expected color definition');\n    }\n\n    color.length = matchDistance();\n    return color;\n  }\n\n  function matchColor() {\n    return matchHexColor() ||\n      matchRGBAColor() ||\n      matchRGBColor() ||\n      matchLiteralColor();\n  }\n\n  function matchLiteralColor() {\n    return match('literal', tokens.literalColor, 0);\n  }\n\n  function matchHexColor() {\n    return match('hex', tokens.hexColor, 1);\n  }\n\n  function matchRGBColor() {\n    return matchCall(tokens.rgbColor, function() {\n      return  {\n        type: 'rgb',\n        value: matchListing(matchNumber)\n      };\n    });\n  }\n\n  function matchRGBAColor() {\n    return matchCall(tokens.rgbaColor, function() {\n      return  {\n        type: 'rgba',\n        value: matchListing(matchNumber)\n      };\n    });\n  }\n\n  function matchNumber() {\n    return scan(tokens.number)[1];\n  }\n\n  function matchDistance() {\n    return match('%', tokens.percentageValue, 1) ||\n      matchPositionKeyword() ||\n      matchLength();\n  }\n\n  function matchPositionKeyword() {\n    return match('position-keyword', tokens.positionKeywords, 1);\n  }\n\n  function matchLength() {\n    return match('px', tokens.pixelValue, 1) ||\n      match('em', tokens.emValue, 1);\n  }\n\n  function match(type, pattern, captureIndex) {\n    var captures = scan(pattern);\n    if (captures) {\n      return {\n        type: type,\n        value: captures[captureIndex]\n      };\n    }\n  }\n\n  function scan(regexp) {\n    var captures,\n        blankCaptures;\n\n    blankCaptures = /^[\\n\\r\\t\\s]+/.exec(input);\n    if (blankCaptures) {\n        consume(blankCaptures[0].length);\n    }\n\n    captures = regexp.exec(input);\n    if (captures) {\n        consume(captures[0].length);\n    }\n\n    return captures;\n  }\n\n  function consume(size) {\n    input = input.substr(size);\n  }\n\n  return function(code) {\n    input = code.toString();\n    return getAST();\n  };\n})();\n\nexports.parse = GradientParser.parse;\nexports.stringify = GradientParser.stringify;\n", null, "import { Color, ColorSource, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport fragment from './color-gradient.frag';\nimport vertex from './color-gradient.vert';\nimport source from './color-gradient.wgsl';\nimport { parseCssGradient } from './CssGradientParser';\n\n/** Color stop object. */\nexport interface ColorStop\n{\n    offset: number;\n    color: ColorSource;\n    alpha: number;\n}\n\n/** Options for ColorGradientFilter constructor. */\nexport interface ColorGradientFilterOptions\n{\n    /**\n     * Linear = 0, Radial = 1, Conic = 2\n     * @default ColorGradientFilter.LINEAR\n     */\n    type: number;\n    /** Collection of stops, must be 2+ */\n    stops: ColorStop[];\n    /**\n     * Angle for linear gradients, in degrees.\n     * @default 90\n     */\n    angle?: number;\n    /**\n     * Alpha value for the gradient.\n     * @default 1\n     */\n    alpha?: number;\n    /**\n     * Maximum number of colors to render (0 = no limit)\n     * @default 0\n     */\n    maxColors?: number;\n    /**\n     * If true, the gradient will replace the existing color, otherwise it will be multiplied with it\n     * @default false\n     */\n    replace?: boolean;\n}\n\n/** Options for CSS-style gradient for use with constructor. */\nexport interface ColorGradientFilterCSSOptions\n{\n    /** CSS-style gradient string */\n    css: string;\n    /**\n     * Alpha value for the gradient.\n     * @default 1\n     */\n    alpha?: number;\n    /**\n     * Maximum number of colors to render (0 = no limit)\n     * @default 0\n     */\n    maxColors?: number;\n}\n\nconst ANGLE_OFFSET = 90; // align degrees with CSS\n\nfunction sortColorStops(stops: ColorStop[]): ColorStop[]\n{\n    return [...stops].sort((a, b) => a.offset - b.offset);\n}\n\n/**\n * Render a colored gradient.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/color-gradient.png)\n *\n * @class\n * @extends Filter\n */\nexport class ColorGradientFilter extends Filter\n{\n    /** Gradient types */\n    static readonly LINEAR = 0;\n    static readonly RADIAL = 1;\n    static readonly CONIC = 2;\n\n    /** Default constructor options */\n    public static readonly defaults: ColorGradientFilterOptions = {\n        type: ColorGradientFilter.LINEAR,\n        stops: [\n            { offset: 0.0, color: 0xff0000, alpha: 1.0 },\n            { offset: 1.0, color: 0x0000ff, alpha: 1.0 },\n        ],\n        alpha: 1.0,\n        angle: 90.0,\n        maxColors: 0,\n        replace: false,\n    };\n\n    public baseUniforms: {\n        uOptions: Float32Array;\n        uCounts: Float32Array;\n    };\n\n    public stopsUniforms: {\n        uColors: Float32Array;\n        uStops: Float32Array;\n    };\n\n    private _stops: ColorStop[] = [];\n\n    /**\n     * @param options - Options for the ColorGradientFilter constructor.\n     */\n    constructor(options?: ColorGradientFilterOptions | ColorGradientFilterCSSOptions)\n    {\n        if (options && 'css' in options)\n        {\n            options = {\n                ...parseCssGradient(options.css || ''),\n                alpha: options.alpha ?? ColorGradientFilter.defaults.alpha,\n                maxColors: options.maxColors ?? ColorGradientFilter.defaults.maxColors,\n            };\n        }\n        else\n        {\n            options = { ...ColorGradientFilter.defaults, ...options };\n        }\n\n        if (!options.stops || options.stops.length < 2)\n        {\n            throw new Error('ColorGradientFilter requires at least 2 color stops.');\n        }\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'color-gradient-filter',\n        });\n\n        const maxStops = 32;\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                baseUniforms: {\n                    uOptions: {\n                        value: [\n                            // Gradient Type\n                            options.type,\n                            // Gradient Angle\n                            options.angle ?? ANGLE_OFFSET,\n                            // Master Alpha\n                            options.alpha,\n                            // Replace Base Color\n                            options.replace ? 1 : 0,\n                        ],\n                        type: 'vec4<f32>',\n                    },\n                    uCounts: {\n                        value: [\n                            // Number of Stops\n                            options.stops.length,\n                            // Max Gradient Colors\n                            options.maxColors,\n                        ],\n                        type: 'vec2<f32>',\n                    },\n                },\n                stopsUniforms: {\n                    uColors: { value: new Float32Array(maxStops * 3), type: 'vec3<f32>', size: maxStops },\n\n                    // We only need vec2, but we need to pad to eliminate the WGSL warning, TODO: @Mat ?\n                    uStops: { value: new Float32Array(maxStops * 4), type: 'vec4<f32>', size: maxStops },\n                }\n            },\n        });\n\n        this.baseUniforms = this.resources.baseUniforms.uniforms;\n        this.stopsUniforms = this.resources.stopsUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    get stops(): ColorStop[]\n    {\n        return this._stops;\n    }\n\n    set stops(stops: ColorStop[])\n    {\n        const sortedStops = sortColorStops(stops);\n        const color = new Color();\n        let r;\n        let g;\n        let b;\n\n        for (let i = 0; i < sortedStops.length; i++)\n        {\n            color.setValue(sortedStops[i].color);\n            const indexStart = i * 3;\n\n            [r, g, b] = color.toArray();\n            this.stopsUniforms.uColors[indexStart] = r;\n            this.stopsUniforms.uColors[indexStart + 1] = g;\n            this.stopsUniforms.uColors[indexStart + 2] = b;\n\n            this.stopsUniforms.uStops[i * 4] = sortedStops[i].offset;\n            this.stopsUniforms.uStops[(i * 4) + 1] = sortedStops[i].alpha;\n        }\n\n        this.baseUniforms.uCounts[0] = sortedStops.length;\n        this._stops = sortedStops;\n    }\n\n    /**\n   * The type of gradient\n   * @default ColorGradientFilter.LINEAR\n   */\n    get type(): number { return this.baseUniforms.uOptions[0]; }\n    set type(value: number) { this.baseUniforms.uOptions[0] = value; }\n\n    /**\n   * The angle of the gradient in degrees\n   * @default 90\n   */\n    get angle(): number { return this.baseUniforms.uOptions[1] + ANGLE_OFFSET; }\n    set angle(value: number) { this.baseUniforms.uOptions[1] = value - ANGLE_OFFSET; }\n\n    /**\n   * The alpha value of the gradient (0-1)\n   * @default 1\n   */\n    get alpha(): number { return this.baseUniforms.uOptions[2]; }\n    set alpha(value: number) { this.baseUniforms.uOptions[2] = value; }\n\n    /**\n   * The maximum number of colors to render (0 = no limit)\n   * @default 0\n   */\n    get maxColors(): number { return this.baseUniforms.uCounts[1]; }\n    set maxColors(value: number) { this.baseUniforms.uCounts[1] = value; }\n\n    /**\n     * If true, the gradient will replace the existing color, otherwise it\n     * will be multiplied with it\n     * @default false\n     */\n    get replace(): boolean { return this.baseUniforms.uOptions[3] > 0.5; }\n    set replace(value: boolean) { this.baseUniforms.uOptions[3] = value ? 1 : 0; }\n}\n\n", "var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\nuniform float uMix;\\nuniform float uSize;\\nuniform float uSliceSize;\\nuniform float uSlicePixelSize;\\nuniform float uSliceInnerSize;\\n\\nvoid main() {\\n    vec4 color = texture(uTexture, vTextureCoord.xy);\\n    vec4 adjusted;\\n\\n    if (color.a > 0.0) {\\n        color.rgb /= color.a;\\n        float innerWidth = uSize - 1.0;\\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\\n        float xOffset = uSlicePixelSize * 0.5 + color.r * uSliceInnerSize;\\n        float s0 = xOffset + (zSlice0 * uSliceSize);\\n        float s1 = xOffset + (zSlice1 * uSliceSize);\\n        float yOffset = uSliceSize * 0.5 + color.g * (1.0 - uSliceSize);\\n        vec4 slice0Color = texture(uMapTexture, vec2(s0,yOffset));\\n        vec4 slice1Color = texture(uMapTexture, vec2(s1,yOffset));\\n        float zOffset = fract(color.b * innerWidth);\\n        adjusted = mix(slice0Color, slice1Color, zOffset);\\n\\n        color.rgb *= color.a;\\n    }\\n\\n    finalColor = vec4(mix(color, adjusted, uMix).rgb, color.a);\\n\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=color-map2.mjs.map\n", "var source = \"struct ColorMapUniforms {\\n  uMix: f32,\\n  uSize: f32,\\n  uSliceSize: f32,\\n  uSlicePixelSize: f32,\\n  uSliceInnerSize: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> colorMapUniforms : ColorMapUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n@group(1) @binding(2) var uMapSampler: sampler;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  var color:vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  var adjusted: vec4<f32>;\\n\\n  var altColor: vec4<f32> = vec4<f32>(color.rgb / color.a, color.a);\\n  let innerWidth: f32 = colorMapUniforms.uSize - 1.0;\\n  let zSlice0: f32 = min(floor(color.b * innerWidth), innerWidth);\\n  let zSlice1: f32 = min(zSlice0 + 1.0, innerWidth);\\n  let xOffset: f32 = colorMapUniforms.uSlicePixelSize * 0.5 + color.r * colorMapUniforms.uSliceInnerSize;\\n  let s0: f32 = xOffset + (zSlice0 * colorMapUniforms.uSliceSize);\\n  let s1: f32 = xOffset + (zSlice1 * colorMapUniforms.uSliceSize);\\n  let yOffset: f32 = colorMapUniforms.uSliceSize * 0.5 + color.g * (1.0 - colorMapUniforms.uSliceSize);\\n  let slice0Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s0,yOffset));\\n  let slice1Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s1,yOffset));\\n  let zOffset: f32 = fract(color.b * innerWidth);\\n  adjusted = mix(slice0Color, slice1Color, zOffset);\\n  altColor = vec4<f32>(color.rgb * color.a, color.a);\\n\\n  let realColor: vec4<f32> = select(color, altColor, color.a > 0.0);\\n\\n  return vec4<f32>(mix(realColor, adjusted, colorMapUniforms.uMix).rgb, realColor.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=color-map.mjs.map\n", "import { deprecation, Filter, GlProgram, GpuProgram, SCALE_MODE, Texture, TextureSource } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './color-map.frag';\nimport source from './color-map.wgsl';\n\ntype ColorMapTexture = TextureSource | Texture;\n\n/** Options for the ColorMapFilter constructor. */\nexport interface ColorMapFilterOptions\n{\n    /** The colorMap texture of the filter. */\n    colorMap: ColorMapTexture;\n    /**\n     *  The mix from 0 to 1, where 0 is the original image and 1 is the color mapped image.\n     * @default 1\n     */\n    mix?: number;\n    /**\n     * Whether use NEAREST scale mode for `colorMap` texture.\n     * @default false\n     */\n    nearest?: boolean;\n}\n\n/**\n * The ColorMapFilter applies a color-map effect to an object.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/color-map.png)\n *\n * @class\n * @extends Filter\n */\nexport class ColorMapFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: ColorMapFilterOptions = {\n        colorMap: Texture.WHITE,\n        nearest: false,\n        mix: 1\n    };\n\n    public uniforms: {\n        uMix: number;\n        uSize: number;\n        uSliceSize: number;\n        uSlicePixelSize: number;\n        uSliceInnerSize: number;\n    };\n\n    private _size = 0;\n    private _sliceSize = 0;\n    private _slicePixelSize = 0;\n    private _sliceInnerSize = 0;\n    private _nearest = false;\n    private _scaleMode: SCALE_MODE = 'linear';\n    private _colorMap!: ColorMapTexture;\n\n    /**\n     * @param options - Options for the ColorMapFilter constructor.\n     */\n    constructor(options: ColorMapFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {HTMLImageElement|HTMLCanvasElement|PIXI.BaseTexture|PIXI.Texture} [colorMap] - The\n     *        colorMap texture of the filter.\n     * @param {boolean} [nearest=false] - Whether use NEAREST for colorMap texture.\n     * @param {number} [mix=1] - The mix from 0 to 1, where 0 is the original image and 1 is the color mapped image.\n     */\n    constructor(colorMap: ColorMapTexture, nearest?: boolean, mix?: number);\n    /** @ignore */\n    constructor(...args: [ColorMapFilterOptions] | [ColorMapTexture, boolean?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Texture || options instanceof TextureSource)\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'ColorMapFilter constructor params are now options object. See params: { colorMap, nearest, mix }');\n\n            options = { colorMap: options };\n\n            if (args[1] !== undefined) options.nearest = args[1];\n            if (args[2] !== undefined) options.mix = args[2];\n        }\n\n        options = { ...ColorMapFilter.DEFAULT_OPTIONS, ...options };\n\n        if (!options.colorMap) throw Error('No color map texture source was provided to ColorMapFilter');\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'color-map-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                colorMapUniforms: {\n                    uMix: { value: options.mix, type: 'f32' },\n                    uSize: { value: 0, type: 'f32' },\n                    uSliceSize: { value: 0, type: 'f32' },\n                    uSlicePixelSize: { value: 0, type: 'f32' },\n                    uSliceInnerSize: { value: 0, type: 'f32' },\n                },\n                uMapTexture: options.colorMap.source,\n                uMapSampler: options.colorMap.source.style,\n            },\n        });\n\n        this.uniforms = this.resources.colorMapUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /** The mix from 0 to 1, where 0 is the original image and 1 is the color mapped image. */\n    get mix(): number { return this.uniforms.uMix; }\n    set mix(value: number) { this.uniforms.uMix = value; }\n\n    /**\n     * The size of one color slice.\n     * @readonly\n     */\n    get colorSize(): number { return this._size; }\n\n    /** The colorMap texture. */\n    get colorMap(): ColorMapTexture { return this._colorMap; }\n    set colorMap(value: ColorMapTexture)\n    {\n        if (!value || value === this.colorMap) return;\n\n        const source = value instanceof Texture ? value.source : value;\n\n        source.style.scaleMode = this._scaleMode;\n        source.autoGenerateMipmaps = false;\n\n        this._size = source.height;\n        this._sliceSize = 1 / this._size;\n        this._slicePixelSize = this._sliceSize / this._size;\n        this._sliceInnerSize = this._slicePixelSize * (this._size - 1);\n\n        this.uniforms.uSize = this._size;\n        this.uniforms.uSliceSize = this._sliceSize;\n        this.uniforms.uSlicePixelSize = this._slicePixelSize;\n        this.uniforms.uSliceInnerSize = this._sliceInnerSize;\n\n        this.resources.uMapTexture = source;\n        this._colorMap = value;\n    }\n\n    /** Whether use NEAREST for colorMap texture. */\n    get nearest(): boolean { return this._nearest; }\n    set nearest(nearest: boolean)\n    {\n        this._nearest = nearest;\n        this._scaleMode = nearest ? 'nearest' : 'linear';\n\n        const texture = this._colorMap;\n\n        if (texture && texture.source)\n        {\n            texture.source.scaleMode = this._scaleMode;\n            texture.source.autoGenerateMipmaps = false;\n            texture.source.style.update();\n            texture.source.update();\n        }\n    }\n\n    /**\n     * If the colorMap is based on canvas,\n     * and the content of canvas has changed, then call `updateColorMap` for update texture.\n     */\n    updateColorMap(): void\n    {\n        const texture = this._colorMap;\n\n        if (texture?.source)\n        {\n            texture.source.update();\n            this.colorMap = texture;\n        }\n    }\n\n    /**\n     * Destroys this filter\n     * @default false\n     */\n    destroy(): void\n    {\n        this._colorMap?.destroy(/** true | TODO: Should base texture be destroyed? **/);\n        super.destroy();\n    }\n}\n", "var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec3 uColor;\\nuniform float uAlpha;\\n\\nvoid main(void) {\\n    vec4 c = texture(uTexture, vTextureCoord);\\n    finalColor = vec4(mix(c.rgb, uColor * c.a, uAlpha), c.a);\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=color-overlay2.mjs.map\n", "var source = \"struct ColorOverlayUniforms {\\n    uColor: vec3<f32>,\\n    uAlpha: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> colorOverlayUniforms : ColorOverlayUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n    let c = textureSample(uTexture, uSampler, uv);\\n    return vec4<f32>(mix(c.rgb, colorOverlayUniforms.uColor.rgb * c.a, colorOverlayUniforms.uAlpha), c.a);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=color-overlay.mjs.map\n", "import { Color, ColorSource, deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './color-overlay.frag';\nimport source from './color-overlay.wgsl';\n\ntype DeprecatedColor = number | number[] | Float32Array;\n\n/** Options for the ColorOverlayFilter constructor. */\nexport interface ColorOverlayFilterOptions\n{\n    /**\n     * The color of the overlay\n     * @default 0x000000\n     */\n    color?: ColorSource;\n    /**\n     * The alpha of the overlay\n     * @default 1\n     */\n    alpha?: number;\n}\n\n/**\n * Overlay a source graphic with a color.<br>\n *\n * @class\n * @extends Filter\n */\nexport class ColorOverlayFilter extends Filter\n{\n    /** Default shockwave filter options */\n    public static readonly DEFAULT_OPTIONS: ColorOverlayFilterOptions = {\n        /** The color of the overlay */\n        color: 0x000000,\n        /** The alpha of the overlay */\n        alpha: 1,\n    };\n\n    public uniforms: {\n        uColor: Float32Array;\n        uAlpha: number;\n    };\n\n    private _color: Color;\n\n    /**\n     * @param options - Options for the ColorOverlayFilter constructor.\n     */\n    constructor(options?: ColorOverlayFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number|Array<number>} [color=0x000000] - The resulting color, as a 3 component RGB e.g. [1.0, 0.5, 1.0]\n     * @param {number} [alpha=1] - The alpha value of the color\n     */\n    constructor(color?: DeprecatedColor, alpha?: number);\n    /** @ignore */\n    constructor(...args: [ColorOverlayFilterOptions?] | [DeprecatedColor?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number' || Array.isArray(options) || options instanceof Float32Array)\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'ColorOverlayFilter constructor params are now options object. See params: { color, alpha }');\n\n            options = { color: options };\n\n            if (args[1] !== undefined) options.alpha = args[1];\n        }\n\n        options = { ...ColorOverlayFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'color-overlay-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                colorOverlayUniforms: {\n                    uColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uAlpha: { value: options.alpha, type: 'f32' },\n                },\n            },\n        });\n\n        this.uniforms = this.resources.colorOverlayUniforms.uniforms;\n\n        this._color = new Color();\n        this.color = options.color ?? 0x000000;\n    }\n\n    /**\n     * The over color source\n     * @member {number|Array<number>|Float32Array}\n     * @default 0x000000\n     */\n    get color(): ColorSource { return this._color.value as ColorSource; }\n    set color(value: ColorSource)\n    {\n        this._color.setValue(value);\n        const [r, g, b] = this._color.toArray();\n\n        this.uniforms.uColor[0] = r;\n        this.uniforms.uColor[1] = g;\n        this.uniforms.uColor[2] = b;\n    }\n\n    /**\n     * The alpha value of the color\n     * @default 1\n     */\n    get alpha(): number { return this.uniforms.uAlpha; }\n    set alpha(value: number) { this.uniforms.uAlpha = value; }\n}\n", "var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec3 uOriginalColor;\\nuniform vec3 uTargetColor;\\nuniform float uTolerance;\\n\\nvoid main(void) {\\n    vec4 c = texture(uTexture, vTextureCoord);\\n    vec3 colorDiff = uOriginalColor - (c.rgb / max(c.a, 0.0000000001));\\n    float colorDistance = length(colorDiff);\\n    float doReplace = step(colorDistance, uTolerance);\\n    finalColor = vec4(mix(c.rgb, (uTargetColor + colorDiff) * c.a, doReplace), c.a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=color-replace.mjs.map\n", "var source = \"struct ColorReplaceUniforms {\\n  uOriginalColor: vec3<f32>,\\n  uTargetColor: vec3<f32>,\\n  uTolerance: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> colorReplaceUniforms : ColorReplaceUniforms;\\n\\n@fragment\\nfn mainFragment(\\n   @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let sample: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  let colorDiff: vec3<f32> = colorReplaceUniforms.uOriginalColor - (sample.rgb / max(sample.a, 0.0000000001));\\n  let colorDistance: f32 = length(colorDiff);\\n  let doReplace: f32 = step(colorDistance, colorReplaceUniforms.uTolerance);\\n\\n  return vec4<f32>(mix(sample.rgb, (colorReplaceUniforms.uTargetColor + colorDiff) * sample.a, doReplace), sample.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=color-replace2.mjs.map\n", "import { Color, ColorSource, deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './color-replace.frag';\nimport source from './color-replace.wgsl';\n\n/**\n * This WebGPU filter has been ported from the WebGL renderer that was originally created by mishaa, updated by timetocode\n * http://www.html5gamedevs.com/topic/10640-outline-a-sprite-change-certain-colors/?p=69966\n */\n\ntype DeprecatedColor = number | number[] | Float32Array;\n\n/** Options for the ColorReplaceFilter constructor. */\nexport interface ColorReplaceFilterOptions\n{\n    /**\n     * The color that will be changed.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0xff0000\n     */\n    originalColor?: ColorSource;\n    /**\n     * The resulting color.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0x000000\n     */\n    targetColor?: ColorSource;\n    /**\n     * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n     * @default 0.4\n     */\n    tolerance?: number;\n}\n\n/**\n * ColorReplaceFilter, originally by mishaa, updated by timetocode\n * http://www.html5gamedevs.com/topic/10640-outline-a-sprite-change-certain-colors/?p=69966<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/color-replace.png)\n *\n * @class\n * @extends Filter\n *\n * @example\n *  // replaces true red with true blue\n *  someSprite.filters = [new ColorReplaceFilter({\n *   originalColor: [1, 0, 0],\n *   targetColor: [0, 0, 1],\n *   tolerance: 0.001\n *   })];\n *  // replaces the RGB color 220, 220, 220 with the RGB color 225, 200, 215\n *  someOtherSprite.filters = [new ColorReplaceFilter({\n *   originalColor: [220/255.0, 220/255.0, 220/255.0],\n *   targetColor: [225/255.0, 200/255.0, 215/255.0],\n *   tolerance: 0.001\n *   })];\n *  // replaces the RGB color 220, 220, 220 with the RGB color 225, 200, 215\n *  someOtherSprite.filters = [new ColorReplaceFilter({ originalColor: 0xdcdcdc, targetColor: 0xe1c8d7, tolerance: 0.001 })];\n *\n */\nexport class ColorReplaceFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: ColorReplaceFilterOptions = {\n        originalColor: 0xff0000,\n        targetColor: 0x000000,\n        tolerance: 0.4\n    };\n\n    public uniforms: {\n        uOriginalColor: Float32Array,\n        uTargetColor: Float32Array,\n        uTolerance: number,\n    };\n\n    private _originalColor: Color;\n    private _targetColor: Color;\n\n    /**\n     * @param options - Options for the ColorReplaceFilter constructor.\n     */\n    constructor(options?: ColorReplaceFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number|Array<number>|Float32Array} [originalColor=0xFF0000] - The color that will be changed,\n     *        as a 3 component RGB e.g. `[1.0, 1.0, 1.0]`\n     * @param {number|Array<number>|Float32Array} [newColor=0x000000] - The resulting color, as a 3 component\n     *        RGB e.g. `[1.0, 0.5, 1.0]`\n     * @param {number} [epsilon=0.4] - Tolerance/sensitivity of the floating-point comparison between colors\n     *        (lower = more exact, higher = more inclusive)\n     */\n    constructor(originalColor?: number, newColor?: number, epsilon?: number);\n    /** @ignore */\n    constructor(...args: [ColorReplaceFilterOptions?] | [DeprecatedColor?, DeprecatedColor?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number' || Array.isArray(options) || options instanceof Float32Array)\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'ColorReplaceFilter constructor params are now options object. See params: { originalColor, targetColor, tolerance }');\n\n            options = { originalColor: options };\n\n            if (args[1] !== undefined) options.targetColor = args[1];\n            if (args[2] !== undefined) options.tolerance = args[2];\n        }\n\n        options = { ...ColorReplaceFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'color-replace-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                colorReplaceUniforms: {\n                    uOriginalColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uTargetColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uTolerance: { value: options.tolerance, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.colorReplaceUniforms.uniforms;\n\n        this._originalColor = new Color();\n        this._targetColor = new Color();\n        this.originalColor = options.originalColor ?? 0xff0000;\n        this.targetColor = options.targetColor ?? 0x000000;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * The color that will be changed.\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0xff0000\n     */\n    get originalColor(): ColorSource { return this._originalColor.value as ColorSource; }\n    set originalColor(value: ColorSource)\n    {\n        this._originalColor.setValue(value);\n        const [r, g, b] = this._originalColor.toArray();\n\n        this.uniforms.uOriginalColor[0] = r;\n        this.uniforms.uOriginalColor[1] = g;\n        this.uniforms.uOriginalColor[2] = b;\n    }\n\n    /**\n      * The resulting color.\n      * @example [1.0, 1.0, 1.0] = 0xffffff\n      * @default 0x000000\n      */\n    get targetColor(): ColorSource { return this._targetColor.value as ColorSource; }\n    set targetColor(value: ColorSource)\n    {\n        this._targetColor.setValue(value);\n        const [r, g, b] = this._targetColor.toArray();\n\n        this.uniforms.uTargetColor[0] = r;\n        this.uniforms.uTargetColor[1] = g;\n        this.uniforms.uTargetColor[2] = b;\n    }\n\n    /**\n      * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n      * @default 0.4\n      */\n    get tolerance(): number { return this.uniforms.uTolerance; }\n    set tolerance(value: number) { this.uniforms.uTolerance = value; }\n\n    /**\n     * @deprecated since 6.0.0\n     *\n     * The resulting color, as a 3 component RGB e.g. [1.0, 0.5, 1.0]\n     * @member {number|Array<number>|Float32Array}\n     * @default 0x000000\n     * @see ColorReplaceFilter#targetColor\n     */\n    set newColor(value: DeprecatedColor)\n    {\n        deprecation('6.0.0', 'ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead');\n\n        this.targetColor = value;\n    }\n    get newColor(): DeprecatedColor\n    {\n        deprecation('6.0.0', 'ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead');\n\n        return this.targetColor as DeprecatedColor;\n    }\n\n    /**\n     * @deprecated since 6.0.0\n     *\n     * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n     * @default 0.4\n     * @see ColorReplaceFilter#tolerance\n     */\n    set epsilon(value: number)\n    {\n        deprecation('6.0.0', 'ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead');\n\n        this.tolerance = value;\n    }\n    get epsilon(): number\n    {\n        deprecation('6.0.0', 'ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead');\n\n        return this.tolerance;\n    }\n}\n", "var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uTexelSize;\\nuniform mat3 uMatrix;\\n\\nvoid main(void)\\n{\\n    vec4 c11 = texture(uTexture, vTextureCoord - uTexelSize); // top left\\n    vec4 c12 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y - uTexelSize.y)); // top center\\n    vec4 c13 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y - uTexelSize.y)); // top right\\n\\n    vec4 c21 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y)); // mid left\\n    vec4 c22 = texture(uTexture, vTextureCoord); // mid center\\n    vec4 c23 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y)); // mid right\\n\\n    vec4 c31 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y + uTexelSize.y)); // bottom left\\n    vec4 c32 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y + uTexelSize.y)); // bottom center\\n    vec4 c33 = texture(uTexture, vTextureCoord + uTexelSize); // bottom right\\n\\n    finalColor =\\n        c11 * uMatrix[0][0] + c12 * uMatrix[0][1] + c13 * uMatrix[0][2] +\\n        c21 * uMatrix[1][0] + c22 * uMatrix[1][1] + c23 * uMatrix[1][2] +\\n        c31 * uMatrix[2][0] + c32 * uMatrix[2][1] + c33 * uMatrix[2][2];\\n\\n    finalColor.a = c22.a;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=convolution.mjs.map\n", "var source = \"struct ConvolutionUniforms {\\n    uMatrix: mat3x3<f32>,\\n    uTexelSize: vec2<f32>,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> convolutionUniforms : ConvolutionUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @location(0) uv: vec2<f32>,\\n    @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n    let texelSize = convolutionUniforms.uTexelSize;\\n    let matrix = convolutionUniforms.uMatrix;\\n\\n    let c11: vec4<f32> = textureSample(uTexture, uSampler, uv - texelSize); // top left\\n    let c12: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y - texelSize.y)); // top center\\n    let c13: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y - texelSize.y)); // top right\\n\\n    let c21: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y)); // mid left\\n    let c22: vec4<f32> = textureSample(uTexture, uSampler, uv); // mid center\\n    let c23: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y)); // mid right\\n\\n    let c31: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y + texelSize.y)); // bottom left\\n    let c32: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y + texelSize.y)); // bottom center\\n    let c33: vec4<f32> = textureSample(uTexture, uSampler, uv + texelSize); // bottom right\\n\\n    var finalColor: vec4<f32> = vec4<f32>(\\n        c11 * matrix[0][0] + c12 * matrix[0][1] + c13 * matrix[0][2] +\\n        c21 * matrix[1][0] + c22 * matrix[1][1] + c23 * matrix[1][2] +\\n        c31 * matrix[2][0] + c32 * matrix[2][1] + c33 * matrix[2][2]\\n    );\\n\\n    finalColor.a = c22.a;\\n\\n    return finalColor;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=convolution2.mjs.map\n", "import { deprecation, Filter, GlProgram, GpuProgram, PointData } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './convolution.frag';\nimport source from './convolution.wgsl';\n\ntype FixedArray<T, L extends number> = [ T, ...Array<T> ] & { length: L };\n\nexport type ConvolutionMatrix = Float32Array | FixedArray<number, 9>;\n\n/** Options for the ConvolutionFilter constructor. */\nexport interface ConvolutionFilterOptions\n{\n    /**\n     * An array of values used for matrix transformation, specified as a 9 point Array\n     * @example\n     * const matrix = new Float32Array(9); // 9 elements of value 0\n     * const matrix = [0,0.5,0,0.5,1,0.5,0,0.5,0];\n     * @default [0,0,0,0,0,0,0,0,0]\n     */\n    matrix?: ConvolutionMatrix;\n    /**\n     * Width of the object you are transforming\n     * @default 200\n     */\n    width?: number;\n    /**\n     * Height of the object you are transforming\n     * @default 200\n     */\n    height?: number;\n}\n\n/**\n * The ConvolutionFilter class applies a matrix convolution filter effect.\n * A convolution combines pixels in the input image with neighboring pixels to produce a new image.\n * A wide variety of image effects can be achieved through convolutions, including blurring, edge\n * detection, sharpening, embossing, and beveling. The matrix should be specified as a 9 point Array.\n * See https://docs.gimp.org/2.10/en/gimp-filter-convolution-matrix.html for more info.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/convolution.png)\n *\n * @class\n * @extends Filter\n */\nexport class ConvolutionFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: ConvolutionFilterOptions = {\n        matrix: new Float32Array(9),\n        width: 200,\n        height: 200,\n    };\n\n    public uniforms: {\n        uMatrix: ConvolutionMatrix;\n        uTexelSize: PointData;\n    };\n\n    /**\n     * @param options - Options for the ConvolutionFilter constructor.\n     */\n    constructor(options?: ConvolutionFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number[]} [matrix=[0,0,0,0,0,0,0,0,0]] - An array of values used for matrix transformation.\n     *        Specified as a 9 point Array.\n     * @param {number} [width=200] - Width of the object you are transforming\n     * @param {number} [height=200] - Height of the object you are transforming\n     */\n    constructor(matrix: number[], width?: number, height?: number);\n    /** @ignore */\n    constructor(...args: [ConvolutionFilterOptions?] | [number[], number?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (Array.isArray(options))\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'ConvolutionFilter constructor params are now options object. See params: { matrix, width, height }');\n\n            options = { matrix: options as ConvolutionMatrix };\n\n            if (args[1] !== undefined) options.width = args[1];\n            if (args[2] !== undefined) options.height = args[2];\n        }\n\n        options = { ...ConvolutionFilter.DEFAULT_OPTIONS, ...options };\n\n        const width = options.width ?? 200;\n        const height = options.height ?? 200;\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'convolution-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                convolutionUniforms: {\n                    uMatrix: { value: options.matrix, type: 'mat3x3<f32>' },\n                    uTexelSize: { value: { x: 1 / width, y: 1 / height }, type: 'vec2<f32>' },\n                },\n            },\n        });\n\n        this.uniforms = this.resources.convolutionUniforms.uniforms;\n\n        this.width = width;\n        this.height = height;\n    }\n\n    /**\n     * An array of values used for matrix transformation, specified as a 9 point Array\n     * @example\n     * const matrix = new Float32Array(9); // 9 elements of value 0\n     * const matrix = [0,0.5,0,0.5,1,0.5,0,0.5,0];\n     * @default [0,0,0,0,0,0,0,0,0]\n     */\n    get matrix(): ConvolutionMatrix { return this.uniforms.uMatrix; }\n    set matrix(matrix: ConvolutionMatrix)\n    {\n        matrix.forEach((v, i) =>\n        {\n            this.uniforms.uMatrix[i] = v;\n        });\n    }\n\n    /**\n     * Width of the object you are transforming\n     * @default 200\n     */\n    get width(): number { return 1 / this.uniforms.uTexelSize.x; }\n    set width(value: number) { this.uniforms.uTexelSize.x = 1 / value; }\n\n    /**\n     * Height of the object you are transforming\n     * @default 200\n     */\n    get height(): number { return 1 / this.uniforms.uTexelSize.y; }\n    set height(value: number) { this.uniforms.uTexelSize.y = 1 / value; }\n}\n", "var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\n\\nvoid main(void)\\n{\\n    float lum = length(texture(uTexture, vTextureCoord.xy).rgb);\\n\\n    finalColor = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n    if (lum < 1.00)\\n    {\\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\\n        {\\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.75)\\n    {\\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\\n        {\\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.50)\\n    {\\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\\n        {\\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.3)\\n    {\\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\\n        {\\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=crosshatch.mjs.map\n", "var source = \"@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n\\n@fragment\\nfn mainFragment(\\n    @location(0) uv: vec2<f32>,\\n    @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n    let lum: f32 = length(textureSample(uTexture, uSampler, uv).rgb);\\n\\n    if (lum < 1.00)\\n    {\\n        if (modulo(position.x + position.y, 10.0) == 0.0)\\n        {\\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.75)\\n    {\\n        if (modulo(position.x - position.y, 10.0) == 0.0)\\n        {\\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.50)\\n    {\\n        if (modulo(position.x + position.y - 5.0, 10.0) == 0.0)\\n        {\\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.3)\\n    {\\n        if (modulo(position.x - position.y - 5.0, 10.0) == 0.0)\\n        {\\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    return vec4<f32>(1.0);\\n}\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=crosshatch2.mjs.map\n", "import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './crosshatch.frag';\nimport source from './crosshatch.wgsl';\n\n/**\n * A Cross Hatch effect filter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/cross-hatch.png)\n *\n * @class\n * @extends Filter\n */\nexport class CrossHatchFilter extends Filter\n{\n    constructor()\n    {\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'cross-hatch-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {},\n        });\n    }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec4 uLine;\\nuniform vec2 uNoise;\\nuniform vec3 uVignette;\\nuniform float uSeed;\\nuniform float uTime;\\nuniform vec2 uDimensions;\\n\\nuniform vec4 uInputSize;\\n\\nconst float SQRT_2 = 1.414213;\\n\\nfloat rand(vec2 co) {\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nfloat vignette(vec3 co, vec2 coord)\\n{\\n    float outter = SQRT_2 - uVignette[0] * SQRT_2;\\n    vec2 dir = vec2(0.5) - coord;\\n    dir.y *= uDimensions.y / uDimensions.x;\\n    float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);\\n    return darker + (1.0 - darker) * (1.0 - uVignette[1]);\\n}\\n\\nfloat noise(vec2 coord)\\n{\\n    vec2 pixelCoord = coord * uInputSize.xy;\\n    pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\\n    pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\\n    return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\\n}\\n\\nvec3 interlaceLines(vec3 co, vec2 coord)\\n{\\n    vec3 color = co;\\n\\n    float curvature = uLine[0];\\n    float lineWidth = uLine[1];\\n    float lineContrast = uLine[2];\\n    float verticalLine = uLine[3];\\n\\n    vec2 dir = vec2(coord * uInputSize.xy / uDimensions - 0.5);\\n\\n    float _c = curvature > 0. ? curvature : 1.;\\n    float k = curvature > 0. ? (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\\n    vec2 uv = dir * k;\\n    float v = verticalLine > 0.5 ? uv.x * uDimensions.x : uv.y * uDimensions.y;\\n    v *= min(1.0, 2.0 / lineWidth ) / _c;\\n    float j = 1. + cos(v * 1.2 - uTime) * 0.5 * lineContrast;\\n    color *= j;\\n\\n    float segment = verticalLine > 0.5 ? mod((dir.x + .5) * uDimensions.x, 4.) : mod((dir.y + .5) * uDimensions.y, 4.);\\n    color *= 0.99 + ceil(segment) * 0.015;\\n\\n    return color;\\n}\\n\\nvoid main(void)\\n{\\n    finalColor = texture(uTexture, vTextureCoord);\\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;\\n\\n    if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\\n    {\\n        float n = noise(vTextureCoord);\\n        finalColor += vec4(n, n, n, finalColor.a);\\n    }\\n\\n    if (uVignette[0] > 0.)\\n    {\\n        float v = vignette(finalColor.rgb, coord);\\n        finalColor *= vec4(v, v, v, finalColor.a);\\n    }\\n\\n    if (uLine[1] > 0.0)\\n    {\\n        finalColor = vec4(interlaceLines(finalColor.rgb, vTextureCoord), finalColor.a);  \\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=crt2.mjs.map\n", "var source = \"struct CRTUniforms {\\n    uLine: vec4<f32>,\\n    uNoise: vec2<f32>,\\n    uVignette: vec3<f32>,\\n    uSeed: f32,\\n    uTime: f32,\\n    uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> crtUniforms : CRTUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n    \\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / crtUniforms.uDimensions;\\n\\n  let uNoise = crtUniforms.uNoise;\\n\\n  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\\n  {\\n    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);\\n  }\\n\\n  if (crtUniforms.uVignette[0] > 0.)\\n  {\\n    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);\\n  }\\n\\n  if (crtUniforms.uLine[1] > 0.0)\\n  {\\n    color = vec4<f32>(vec3<f32>(interlaceLines(color.rgb, uv)), color.a);  \\n  }\\n\\n  return color;\\n}\\n\\nconst SQRT_2: f32 = 1.414213;\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\\n\\nfn rand(co: vec2<f32>) -> f32\\n{\\n  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nfn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32\\n{\\n  let uVignette = crtUniforms.uVignette;\\n  let uDimensions = crtUniforms.uDimensions;\\n  \\n  let outter: f32 = SQRT_2 - uVignette[0] * SQRT_2;\\n  var dir: vec2<f32> = vec2<f32>(0.5) - coord;\\n  dir.y *= uDimensions.y / uDimensions.x;\\n  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);\\n  return darker + (1.0 - darker) * (1.0 - uVignette[1]);\\n}\\n\\nfn noise(coord: vec2<f32>) -> f32\\n{\\n  let uNoise = crtUniforms.uNoise;\\n  let uSeed = crtUniforms.uSeed;\\n\\n  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;\\n  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\\n  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\\n  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\\n}\\n\\nfn interlaceLines(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>\\n{\\n  var color = co;\\n\\n  let uDimensions = crtUniforms.uDimensions;\\n\\n  let curvature: f32 = crtUniforms.uLine[0];\\n  let lineWidth: f32 = crtUniforms.uLine[1];\\n  let lineContrast: f32 = crtUniforms.uLine[2];\\n  let verticalLine: f32 = crtUniforms.uLine[3];\\n\\n  let dir: vec2<f32> = vec2<f32>(coord * gfu.uInputSize.xy / uDimensions - 0.5);\\n\\n  let _c: f32 = select(1., curvature, curvature > 0.);\\n  let k: f32 = select(1., (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c), curvature > 0.);\\n  let uv: vec2<f32> = dir * k;\\n  let v: f32 = select(uv.y * uDimensions.y, uv.x * uDimensions.x, verticalLine > 0.5) * min(1.0, 2.0 / lineWidth ) / _c;\\n  let j: f32 = 1. + cos(v * 1.2 - crtUniforms.uTime) * 0.5 * lineContrast;\\n  color *= j;\\n\\n  let segment: f32 = select(modulo((dir.y + .5) * uDimensions.y, 4.), modulo((dir.x + .5) * uDimensions.x, 4.), verticalLine > 0.5);\\n  color *= 0.99 + ceil(segment) * 0.015;\\n\\n  return color;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=crt.mjs.map\n", "import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './crt.frag';\nimport source from './crt.wgsl';\n\nimport type { FilterSystem, RenderSurface, Texture } from 'pixi.js';\n\n/** Options for the CRTFilter constructor. */\nexport interface CRTFilterOptions\n{\n    /**\n     * Bend of interlaced lines, higher value means more bend\n     * @default 1\n     */\n    curvature?: number,\n    /**\n     * Width of the interlaced lines\n     * @default 1\n     */\n    lineWidth?: number,\n    /**\n     * Contrast of interlaced lines\n     * @default 0.25\n     */\n    lineContrast?: number,\n    /**\n     * The orientation of the line:\n     *\n     * `true` create vertical lines, `false` creates horizontal lines\n     * @default false\n     */\n    verticalLine?: boolean,\n    /**\n     * For animating interlaced lines\n     * @default 0\n     */\n    time?: number,\n    /**\n     * Opacity/intensity of the noise effect between `0` and `1`\n     * @default 0.3\n     */\n    noise?: number,\n    /**\n     * The size of the noise particles\n     * @default 1\n     */\n    noiseSize?: number,\n    /**\n     * A seed value to apply to the random noise generation\n     * @default 0\n     */\n    seed?: number,\n    /**\n     * The radius of the vignette effect, smaller values produces a smaller vignette\n     * @default 0.3\n     */\n    vignetting?: number,\n    /**\n     * Amount of opacity on the vignette\n     * @default 1\n     */\n    vignettingAlpha?: number,\n    /**\n     * Blur intensity of the vignette\n     * @default 0.3\n     */\n    vignettingBlur?: number,\n}\n\n/**\n * The CRTFilter applies a CRT effect to an object.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/crt.png)\n *\n * @class\n * @extends Filter\n */\nexport class CRTFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: CRTFilterOptions = {\n        curvature: 1.0,\n        lineWidth: 1.0,\n        lineContrast: 0.25,\n        verticalLine: false,\n        noise: 0.0,\n        noiseSize: 1.0,\n        vignetting: 0.3,\n        vignettingAlpha: 1.0,\n        vignettingBlur: 0.3,\n        time: 0.0,\n        seed: 0.0,\n    };\n\n    public uniforms: {\n        uLine: Float32Array;\n        uNoise: Float32Array;\n        uVignette: Float32Array;\n        uSeed: number;\n        uTime: number;\n        uDimensions: Float32Array;\n    };\n\n    /**\n     * A seed value to apply to the random noise generation\n     * @default 0\n     */\n    public seed!: number;\n\n    /**\n     * Opacity/intensity of the noise effect between `0` and `1`\n     * @default 0.3\n     */\n    public time!: number;\n\n    /**\n     * @param options - Options for the CRTFilter constructor.\n     */\n    constructor(options?: CRTFilterOptions)\n    {\n        options = { ...CRTFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'crt-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                crtUniforms: {\n                    uLine: { value: new Float32Array(4), type: 'vec4<f32>' },\n                    uNoise: { value: new Float32Array(2), type: 'vec2<f32>' },\n                    uVignette: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uSeed: { value: options.seed, type: 'f32' },\n                    uTime: { value: options.time, type: 'f32' },\n                    uDimensions: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.crtUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        this.uniforms.uDimensions[0] = input.frame.width;\n        this.uniforms.uDimensions[1] = input.frame.height;\n\n        this.uniforms.uSeed = this.seed;\n        this.uniforms.uTime = this.time;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Bend of interlaced lines, higher value means more bend\n     * @default 1\n     */\n    get curvature(): number { return this.uniforms.uLine[0]; }\n    set curvature(value: number) { this.uniforms.uLine[0] = value; }\n\n    /**\n     * Width of interlaced lines\n     * @default 1\n     */\n    get lineWidth(): number { return this.uniforms.uLine[1]; }\n    set lineWidth(value: number) { this.uniforms.uLine[1] = value; }\n\n    /**\n     * Contrast of interlaced lines\n     * @default 0.25\n     */\n    get lineContrast(): number { return this.uniforms.uLine[2]; }\n    set lineContrast(value: number) { this.uniforms.uLine[2] = value; }\n\n    /**\n     * The orientation of the line:\n     *\n     * `true` create vertical lines, `false` creates horizontal lines\n     * @default false\n     */\n    get verticalLine(): boolean { return this.uniforms.uLine[3] > 0.5; }\n    set verticalLine(value: boolean) { this.uniforms.uLine[3] = value ? 1 : 0; }\n\n    /**\n     * Opacity/intensity of the noise effect between `0` and `1`\n     * @default 0.3\n     */\n    get noise(): number { return this.uniforms.uNoise[0]; }\n    set noise(value: number) { this.uniforms.uNoise[0] = value; }\n\n    /**\n     * The size of the noise particles\n     * @default 0\n     */\n    get noiseSize(): number { return this.uniforms.uNoise[1]; }\n    set noiseSize(value: number) { this.uniforms.uNoise[1] = value; }\n\n    /**\n     * The radius of the vignette effect, smaller values produces a smaller vignette\n     * @default 0.3\n     */\n    get vignetting(): number { return this.uniforms.uVignette[0]; }\n    set vignetting(value: number) { this.uniforms.uVignette[0] = value; }\n\n    /**\n     * Amount of opacity of vignette\n     * @default 1\n     */\n    get vignettingAlpha(): number { return this.uniforms.uVignette[1]; }\n    set vignettingAlpha(value: number) { this.uniforms.uVignette[1] = value; }\n\n    /**\n     * Blur intensity of the vignette\n     * @default 0.3\n     */\n    get vignettingBlur(): number { return this.uniforms.uVignette[2]; }\n    set vignettingBlur(value: number) { this.uniforms.uVignette[2] = value; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uAngle;\\nuniform float uScale;\\nuniform bool uGrayScale;\\n\\nuniform vec4 uInputSize;\\n\\nfloat pattern()\\n{\\n    float s = sin(uAngle), c = cos(uAngle);\\n    vec2 tex = vTextureCoord * uInputSize.xy;\\n    vec2 point = vec2(\\n        c * tex.x - s * tex.y,\\n        s * tex.x + c * tex.y\\n    ) * uScale;\\n    return (sin(point.x) * sin(point.y)) * 4.0;\\n    }\\n\\n    void main()\\n    {\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    vec3 colorRGB = vec3(color);\\n\\n    if (uGrayScale)\\n    {\\n        colorRGB = vec3(color.r + color.g + color.b) / 3.0;\\n    }\\n\\n    finalColor = vec4(colorRGB * 10.0 - 5.0 + pattern(), color.a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=dot.mjs.map\n", "var source = \"struct DotUniforms {\\n  uScale:f32,\\n  uAngle:f32,\\n  uGrayScale:f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> dotUniforms : DotUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let gray: vec3<f32> = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)));\\n  // dotUniforms.uGrayScale == 1 doesn't ever pass so it is converted to a float and compared to 0.5 instead \\n  let finalColor: vec3<f32> = select(color.rgb, gray, f32(dotUniforms.uGrayScale) >= 0.5);\\n\\n  return vec4<f32>(finalColor * 10.0 - 5.0 + pattern(uv), color.a);\\n}\\n\\nfn pattern(uv: vec2<f32>) -> f32\\n{\\n  let s: f32 = sin(dotUniforms.uAngle);\\n  let c: f32 = cos(dotUniforms.uAngle);\\n  \\n  let tex: vec2<f32> = uv * gfu.uInputSize.xy;\\n  \\n  let p: vec2<f32> = vec2<f32>(\\n      c * tex.x - s * tex.y,\\n      s * tex.x + c * tex.y\\n  ) * dotUniforms.uScale;\\n\\n  return (sin(p.x) * sin(p.y)) * 4.0;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=dot2.mjs.map\n", "import { deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './dot.frag';\nimport source from './dot.wgsl';\n\n/** Options for the DotFilter constructor. */\nexport interface DotFilterOptions\n{\n    /**\n     * The scale of the effect\n     * @default 1\n     */\n    scale?: number;\n    /**\n     * The angle of the effect\n     * @default 5\n     */\n    angle?: number;\n    /**\n     * Whether to rendering it in gray scale\n     * @default true\n     */\n    grayscale?: boolean;\n}\n\n/**\n * This filter applies a dotscreen effect making display objects appear to be made out of\n * black and white halftone dots like an old printer.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/dot.png)\n *\n * {@link https://github.com/evanw/glfx.js/blob/master/src/filters/fun/dotscreen.js Original filter}\n *\n * @class\n * @extends Filter\n */\nexport class DotFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: DotFilterOptions = {\n        scale: 1,\n        angle: 5,\n        grayscale: true\n    };\n\n    /**\n     * @param options - Options for the DotFilter constructor.\n     */\n    constructor(options?: DotFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number} [scale=1] - The scale of the effect.\n     * @param {number} [angle=5] - The radius of the effect.\n     * @param {boolean} [grayscale=true] - Render as grayscale.\n     */\n    constructor(scale?: number, angle?: number, grayscale?: boolean);\n    /** @ignore */\n    constructor(...args: [DotFilterOptions?] | [number?, number?, boolean?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'DotFilter constructor params are now options object. See params: { scale, angle, grayscale }');\n\n            options = { scale: options };\n\n            if (args[1] !== undefined) options.angle = args[1];\n            if (args[2] !== undefined) options.grayscale = args[2];\n        }\n\n        options = { ...DotFilter.DEFAULT_OPTIONS, ...options };\n\n        const dotUniforms = {\n            uScale: { value: options.scale, type: 'f32' },\n            uAngle: { value: options.angle, type: 'f32' },\n            uGrayScale: { value: options.grayscale ? 1 : 0, type: 'f32' },\n        };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'dot-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                dotUniforms,\n            },\n        });\n    }\n\n    /**\n     * The scale of the effect.\n     * @default 1\n     */\n    get scale(): number { return this.resources.dotUniforms.uniforms.uScale; }\n    set scale(value: number) { this.resources.dotUniforms.uniforms.uScale = value; }\n\n    /**\n    * The radius of the effect.\n    * @default 5\n    */\n    get angle(): number { return this.resources.dotUniforms.uniforms.uAngle; }\n    set angle(value: number) { this.resources.dotUniforms.uniforms.uAngle = value; }\n\n    /**\n    * Whether to rendering it in gray scale.\n    * @default true\n    */\n    get grayscale(): boolean { return this.resources.dotUniforms.uniforms.uGrayScale === 1; }\n    set grayscale(value: boolean) { this.resources.dotUniforms.uniforms.uGrayScale = value ? 1 : 0; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uAlpha;\\nuniform vec3 uColor;\\nuniform vec2 uOffset;\\n\\nuniform vec4 uInputSize;\\n\\nvoid main(void){\\n    vec4 sample = texture(uTexture, vTextureCoord - uOffset * uInputSize.zw);\\n\\n    // Premultiply alpha\\n    sample.rgb = uColor.rgb * sample.a;\\n\\n    // alpha user alpha\\n    sample *= uAlpha;\\n\\n    finalColor = sample;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=drop-shadow.mjs.map\n", "var source = \"struct DropShadowUniforms {\\n  uAlpha: f32,\\n  uColor: vec3<f32>,\\n  uOffset: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> dropShadowUniforms : DropShadowUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv - dropShadowUniforms.uOffset * gfu.uInputSize.zw);\\n\\n  // Premultiply alpha\\n  color = vec4<f32>(vec3<f32>(dropShadowUniforms.uColor.rgb * color.a), color.a);\\n  // alpha user alpha\\n  color *= dropShadowUniforms.uAlpha;\\n\\n  return color;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=drop-shadow2.mjs.map\n", "import {\n    Color,\n    ColorSource,\n    Filter,\n    FilterSystem,\n    GlProgram,\n    GpuProgram,\n    PointData,\n    RenderSurface,\n    Texture,\n    TexturePool,\n} from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport { KawaseBlurFilter } from '../kawase-blur/KawaseBlurFilter';\nimport fragment from './drop-shadow.frag';\nimport source from './drop-shadow.wgsl';\n\n/** Options for the DropShadowFilter constructor. */\nexport interface DropShadowFilterOptions\n{\n    /**\n     * The offset position of the drop-shadow relative to the original image.\n     * @default {x:4,y:4}\n     */\n    offset?: PointData;\n    /**\n     * The color value of shadow.\n     * @example [0.0, 0.0, 0.0] = 0x000000\n     * @default 0x000000\n     */\n    color?: ColorSource;\n    /**\n     * Coefficient for alpha multiplication.\n     * @default 1\n     */\n    alpha?: number;\n    /**\n     * Hide the contents, only show the shadow.\n     * @default false\n     */\n    shadowOnly?: boolean;\n    /**\n     * The strength of the shadow's blur.\n     * @default 2\n     */\n    blur?: number;\n    /**\n     * The quality of the Blur Filter.\n     * @default 4\n     */\n    quality?: number;\n    /**\n     * The kernel size of the blur filter.\n     * @default null\n     */\n    kernels?: number[];\n    /**\n     * The pixelSize of the Kawase Blur filter\n     * @default {x:1,y:1}\n     */\n    pixelSize?: PointData | number[] | number;\n    /**\n     * The resolution of the Kawase Blur filter\n     * @default 1\n     */\n    resolution?: number;\n}\n\n/**\n * Drop shadow filter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/drop-shadow.png)\n * @class\n * @extends Filter\n */\nexport class DropShadowFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: DropShadowFilterOptions = {\n        offset: { x: 4, y: 4 },\n        color: 0x000000,\n        alpha: 0.5,\n        shadowOnly: false,\n        kernels: undefined,\n        blur: 2,\n        quality: 3,\n        pixelSize: { x: 1, y: 1 },\n        resolution: 1,\n    };\n\n    public uniforms: {\n        uAlpha: number;\n        uColor: Float32Array;\n        uOffset: PointData;\n    };\n\n    /**\n     * Hide the contents, only show the shadow.\n     * @default false\n     */\n    public shadowOnly = false;\n\n    private _color!: Color;\n    private _blurFilter: KawaseBlurFilter;\n    private _basePass: Filter;\n\n    /**\n     * @param options - Options for the DropShadowFilter constructor.\n     */\n    constructor(options?: DropShadowFilterOptions)\n    {\n        options = { ...DropShadowFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'drop-shadow-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                dropShadowUniforms: {\n                    uAlpha: { value: options.alpha, type: 'f32' },\n                    uColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uOffset: { value: options.offset, type: 'vec2<f32>' },\n                }\n            },\n            resolution: options.resolution,\n        });\n\n        this.uniforms = this.resources.dropShadowUniforms.uniforms;\n        this._color = new Color();\n        this.color = options.color ?? 0x000000;\n\n        this._blurFilter = new KawaseBlurFilter({\n            strength: options.kernels as [number, number] ?? options.blur,\n            quality: options.kernels ? undefined : options.quality,\n        });\n\n        this._basePass = new Filter({\n            gpuProgram: GpuProgram.from({\n                vertex: {\n                    source: wgslVertex,\n                    entryPoint: 'mainVertex',\n                },\n                fragment: {\n                    source: `\n                    @group(0) @binding(1) var uTexture: texture_2d<f32>; \n                    @group(0) @binding(2) var uSampler: sampler;\n                    @fragment\n                    fn mainFragment(\n                        @builtin(position) position: vec4<f32>,\n                        @location(0) uv : vec2<f32>\n                    ) -> @location(0) vec4<f32> {\n                        return textureSample(uTexture, uSampler, uv);\n                    }\n                    `,\n                    entryPoint: 'mainFragment',\n                },\n            }),\n            glProgram: GlProgram.from({\n                vertex,\n                fragment: `\n                in vec2 vTextureCoord;\n                out vec4 finalColor;\n                uniform sampler2D uTexture;\n\n                void main(void){\n                    finalColor = texture(uTexture, vTextureCoord);\n                }\n                `,\n                name: 'drop-shadow-filter',\n            }),\n            resources: {},\n        });\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean,\n    ): void\n    {\n        const renderTarget = TexturePool.getSameSizeTexture(input);\n\n        filterManager.applyFilter(this, input, renderTarget, true);\n        this._blurFilter.apply(filterManager, renderTarget, output, clearMode);\n\n        if (!this.shadowOnly)\n        {\n            filterManager.applyFilter(this._basePass, input, output, false);\n        }\n\n        TexturePool.returnTexture(renderTarget);\n    }\n\n    /**\n     * Set the offset position of the drop-shadow relative to the original image.\n     * @default [4,4]\n     */\n    public get offset(): PointData { return this.uniforms.uOffset; }\n    public set offset(value: PointData)\n    {\n        this.uniforms.uOffset = value;\n        this._updatePadding();\n    }\n\n    /**\n     * Set the offset position of the drop-shadow relative to the original image on the `x` axis\n     * @default 4\n     */\n    get offsetX(): number { return this.offset.x; }\n    set offsetX(value: number)\n    {\n        this.offset.x = value;\n        this._updatePadding();\n    }\n\n    /**\n     * Set the offset position of the drop-shadow relative to the original image on the `y` axis\n     * @default 4\n     */\n    get offsetY(): number { return this.offset.y; }\n    set offsetY(value: number)\n    {\n        this.offset.y = value;\n        this._updatePadding();\n    }\n\n    /**\n     * The color value of shadow.\n     * @example [0.0, 0.0, 0.0] = 0x000000\n     * @default 0x000000\n     */\n    get color(): ColorSource { return this._color.value as ColorSource; }\n    set color(value: ColorSource)\n    {\n        this._color.setValue(value);\n        const [r, g, b] = this._color.toArray();\n\n        this.uniforms.uColor[0] = r;\n        this.uniforms.uColor[1] = g;\n        this.uniforms.uColor[2] = b;\n    }\n\n    /**\n     * Coefficient for alpha multiplication\n     * @default 1\n     */\n    get alpha(): number { return this.uniforms.uAlpha; }\n    set alpha(value: number) { this.uniforms.uAlpha = value; }\n\n    /**\n     * The strength of the shadow's blur.\n     * @default 2\n     */\n    get blur(): number { return this._blurFilter.strength; }\n    set blur(value: number)\n    {\n        this._blurFilter.strength = value;\n        this._updatePadding();\n    }\n\n    /**\n     * Sets the quality of the Blur Filter\n     * @default 4\n     */\n    get quality(): number { return this._blurFilter.quality; }\n    set quality(value: number)\n    {\n        this._blurFilter.quality = value;\n        this._updatePadding();\n    }\n\n    /** Sets the kernels of the Blur Filter */\n    get kernels(): number[] { return this._blurFilter.kernels; }\n    set kernels(value: number[]) { this._blurFilter.kernels = value; }\n\n    /**\n     * Sets the pixelSize of the Kawase Blur filter\n     * @default [1,1]\n     */\n    get pixelSize(): PointData\n    {\n        return this._blurFilter.pixelSize as PointData;\n    }\n    set pixelSize(value: PointData | number[] | number)\n    {\n        if (typeof value === 'number')\n        {\n            value = { x: value, y: value };\n        }\n\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this._blurFilter.pixelSize = value;\n    }\n\n    /**\n     * Sets the pixelSize of the Kawase Blur filter on the `x` axis\n     * @default 1\n     */\n    get pixelSizeX(): number { return this._blurFilter.pixelSizeX; }\n    set pixelSizeX(value: number) { this._blurFilter.pixelSizeX = value; }\n\n    /**\n     * Sets the pixelSize of the Kawase Blur filter on the `y` axis\n     * @default 1\n     */\n    get pixelSizeY(): number { return this._blurFilter.pixelSizeY; }\n    set pixelSizeY(value: number) { this._blurFilter.pixelSizeY = value; }\n\n    /**\n     * Recalculate the proper padding amount.\n     * @private\n     */\n    private _updatePadding()\n    {\n        const offsetPadding = Math.max(\n            Math.abs(this.offsetX),\n            Math.abs(this.offsetY),\n        );\n\n        this.padding = offsetPadding + (this.blur * 2) + (this.quality * 4);\n    }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uStrength;\\n\\nuniform vec4 uInputSize;\\n\\nvoid main(void)\\n{\\n\\tvec2 onePixel = vec2(1.0 / uInputSize);\\n\\n\\tvec4 color;\\n\\n\\tcolor.rgb = vec3(0.5);\\n\\n\\tcolor -= texture(uTexture, vTextureCoord - onePixel) * uStrength;\\n\\tcolor += texture(uTexture, vTextureCoord + onePixel) * uStrength;\\n\\n\\tcolor.rgb = vec3((color.r + color.g + color.b) / 3.0);\\n\\n\\tfloat alpha = texture(uTexture, vTextureCoord).a;\\n\\n\\tfinalColor = vec4(color.rgb * alpha, alpha);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=emboss2.mjs.map\n", "var source = \"struct EmbossUniforms {\\n  uStrength:f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> embossUniforms : EmbossUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let onePixel: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\\n\\tvar color: vec3<f32> = vec3<f32>(0.5);\\n\\n\\tcolor -= (textureSample(uTexture, uSampler, uv - onePixel) * embossUniforms.uStrength).rgb;\\n\\tcolor += (textureSample(uTexture, uSampler, uv + onePixel) * embossUniforms.uStrength).rgb;\\n\\n\\tcolor = vec3<f32>((color.r + color.g + color.b) / 3.0);\\n\\n\\tlet blendColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n\\treturn vec4<f32>(color.rgb * blendColor.a, blendColor.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=emboss.mjs.map\n", "import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './emboss.frag';\nimport source from './emboss.wgsl';\n\n/**\n * An RGB Split Filter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/emboss.png)\n *\n * @class\n * @extends Filter\n */\nexport class EmbossFilter extends Filter\n{\n    public uniforms: {\n        uStrength: number;\n    };\n\n    /**\n     * @param {number} [strength=5] - Strength of the emboss.\n     */\n    constructor(strength = 5)\n    {\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'emboss-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                embossUniforms: {\n                    uStrength: { value: strength, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.embossUniforms.uniforms;\n    }\n\n    /**\n     * Strength of the emboss\n     * @default 5\n     */\n    get strength(): number { return this.uniforms.uStrength; }\n    set strength(value: number) { this.uniforms.uStrength = value; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uDisplacementMap;\\nuniform float uSeed;\\nuniform vec2 uDimensions;\\nuniform float uAspect;\\nuniform float uFillMode;\\nuniform float uOffset;\\nuniform float uDirection;\\nuniform vec2 uRed;\\nuniform vec2 uGreen;\\nuniform vec2 uBlue;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nconst int TRANSPARENT = 0;\\nconst int ORIGINAL = 1;\\nconst int LOOP = 2;\\nconst int CLAMP = 3;\\nconst int MIRROR = 4;\\n\\nvoid main(void)\\n{\\n    vec2 coord = (vTextureCoord * uInputSize.xy) / uDimensions;\\n\\n    if (coord.x > 1.0 || coord.y > 1.0) {\\n        return;\\n    }\\n\\n    float sinDir = sin(uDirection);\\n    float cosDir = cos(uDirection);\\n\\n    float cx = coord.x - 0.5;\\n    float cy = (coord.y - 0.5) * uAspect;\\n    float ny = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;\\n\\n    // displacementMap: repeat\\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\\n\\n    // displacementMap: mirror\\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\\n\\n    vec4 dc = texture(uDisplacementMap, vec2(0.5, ny));\\n\\n    float displacement = (dc.r - dc.g) * (uOffset / uInputSize.x);\\n\\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * uAspect);\\n\\n    int fillMode = int(uFillMode);\\n\\n    if (fillMode == CLAMP) {\\n        coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\\n    } else {\\n        if( coord.x > uInputClamp.z ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.x -= uInputClamp.z;\\n            } else if (fillMode == MIRROR) {\\n                coord.x = uInputClamp.z * 2.0 - coord.x;\\n            }\\n        } else if( coord.x < uInputClamp.x ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.x += uInputClamp.z;\\n            } else if (fillMode == MIRROR) {\\n                coord.x *= -uInputClamp.z;\\n            }\\n        }\\n\\n        if( coord.y > uInputClamp.w ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.y -= uInputClamp.w;\\n            } else if (fillMode == MIRROR) {\\n                coord.y = uInputClamp.w * 2.0 - coord.y;\\n            }\\n        } else if( coord.y < uInputClamp.y ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.y += uInputClamp.w;\\n            } else if (fillMode == MIRROR) {\\n                coord.y *= -uInputClamp.w;\\n            }\\n        }\\n    }\\n\\n    finalColor.r = texture(uTexture, coord + uRed * (1.0 - uSeed * 0.4) / uInputSize.xy).r;\\n    finalColor.g = texture(uTexture, coord + uGreen * (1.0 - uSeed * 0.3) / uInputSize.xy).g;\\n    finalColor.b = texture(uTexture, coord + uBlue * (1.0 - uSeed * 0.2) / uInputSize.xy).b;\\n    finalColor.a = texture(uTexture, coord).a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=glitch2.mjs.map\n", "var source = \"struct GlitchUniforms {\\n  uSeed: f32,\\n  uDimensions: vec2<f32>,\\n  uAspect: f32,\\n  uFillMode: f32,\\n  uOffset: f32,\\n  uDirection: f32,\\n  uRed: vec2<f32>,\\n  uGreen: vec2<f32>,\\n  uBlue: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> glitchUniforms : GlitchUniforms;\\n@group(1) @binding(1) var uDisplacementMap: texture_2d<f32>; \\n@group(1) @binding(2) var uDisplacementSampler: sampler; \\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uSeed: f32 = glitchUniforms.uSeed;\\n  let uDimensions: vec2<f32> = glitchUniforms.uDimensions;\\n  let uAspect: f32 = glitchUniforms.uAspect;\\n  let uOffset: f32 = glitchUniforms.uOffset;\\n  let uDirection: f32 = glitchUniforms.uDirection;\\n  let uRed: vec2<f32> = glitchUniforms.uRed;\\n  let uGreen: vec2<f32> = glitchUniforms.uGreen;\\n  let uBlue: vec2<f32> = glitchUniforms.uBlue;\\n\\n  let uInputSize: vec4<f32> = gfu.uInputSize;\\n  let uInputClamp: vec4<f32> = gfu.uInputClamp;\\n\\n  var discarded: bool = false;\\n  var coord: vec2<f32> = (uv * uInputSize.xy) / uDimensions;\\n\\n    if (coord.x > 1.0 || coord.y > 1.0) {\\n      discarded = true;\\n    }\\n\\n    let sinDir: f32 = sin(uDirection);\\n    let cosDir: f32 = cos(uDirection);\\n\\n    let cx: f32 = coord.x - 0.5;\\n    let cy: f32 = (coord.y - 0.5) * uAspect;\\n    var ny: f32 = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;\\n\\n    ny = select(select(ny, -ny, ny < 0.0), 2.0 - ny, ny > 1.0);\\n\\n    let dc: vec4<f32> = textureSample(uDisplacementMap, uDisplacementSampler, vec2<f32>(0.5, ny));\\n\\n    let displacement: f32 = (dc.r - dc.g) * (uOffset / uInputSize.x);\\n\\n    coord = uv + vec2<f32>(cosDir * displacement, sinDir * displacement * uAspect);\\n\\n    let fillMode: i32 = i32(glitchUniforms.uFillMode);\\n\\n    if (fillMode == CLAMP) {\\n      coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\\n    } else {\\n      if (coord.x > uInputClamp.z) {\\n        if (fillMode == TRANSPARENT) {\\n          discarded = true;\\n        } else if (fillMode == LOOP) {\\n          coord.x = coord.x - uInputClamp.z;\\n        } else if (fillMode == MIRROR) {\\n          coord.x = uInputClamp.z * 2.0 - coord.x;\\n        }\\n      } else if (coord.x < uInputClamp.x) {\\n        if (fillMode == TRANSPARENT) {\\n          discarded = true;\\n        } else if (fillMode == LOOP) {\\n          coord.x = coord.x + uInputClamp.z;\\n        } else if (fillMode == MIRROR) {\\n          coord.x = coord.x * -uInputClamp.z;\\n        }\\n      }\\n\\n      if (coord.y > uInputClamp.w) {\\n        if (fillMode == TRANSPARENT) {\\n          discarded = true;\\n        } else if (fillMode == LOOP) {\\n          coord.y = coord.y - uInputClamp.w;\\n        } else if (fillMode == MIRROR) {\\n          coord.y = uInputClamp.w * 2.0 - coord.y;\\n        }\\n      } else if (coord.y < uInputClamp.y) {\\n        if (fillMode == TRANSPARENT) {\\n          discarded = true;\\n        } else if (fillMode == LOOP) {\\n          coord.y = coord.y + uInputClamp.w;\\n        } else if (fillMode == MIRROR) {\\n          coord.y = coord.y * -uInputClamp.w;\\n        }\\n      }\\n    }\\n\\n    let seedR: f32 = 1.0 - uSeed * 0.4;\\n    let seedG: f32 = 1.0 - uSeed * 0.3;\\n    let seedB: f32 = 1.0 - uSeed * 0.2;\\n\\n    let offsetR: vec2<f32> = vec2(uRed.x * seedR / uInputSize.x, uRed.y * seedR / uInputSize.y);\\n    let offsetG: vec2<f32> = vec2(uGreen.x * seedG / uInputSize.x, uGreen.y * seedG / uInputSize.y);\\n    let offsetB: vec2<f32> = vec2(uBlue.x * seedB / uInputSize.x, uBlue.y * seedB / uInputSize.y);\\n\\n    let r = textureSample(uTexture, uSampler, coord + offsetR).r;\\n    let g = textureSample(uTexture, uSampler, coord + offsetG).g;\\n    let b = textureSample(uTexture, uSampler, coord + offsetB).b;\\n    let a = textureSample(uTexture, uSampler, coord).a;\\n\\n    return select(vec4<f32>(r, g, b, a), vec4<f32>(0.0,0.0,0.0,0.0), discarded);\\n}\\n\\nconst TRANSPARENT: i32 = 0;\\nconst ORIGINAL: i32 = 1;\\nconst LOOP: i32 = 2;\\nconst CLAMP: i32 = 3;\\nconst MIRROR: i32 = 4;\";\n\nexport { source as default };\n//# sourceMappingURL=glitch.mjs.map\n", "import { DEG_TO_RAD, Filter, GlProgram, GpuProgram, ImageSource, Texture } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './glitch.frag';\nimport source from './glitch.wgsl';\n\nimport type { FilterSystem, PointData, RenderSurface } from 'pixi.js';\n\nenum FILL_MODES\n    {\n    TRANSPARENT = 0,\n    ORIGINAL = 1,\n    LOOP = 2,\n    CLAMP = 3,\n    MIRROR = 4,\n}\n\n/** Options for the GlitchFilter constructor. */\nexport interface GlitchFilterOptions\n{\n    /**\n     * The count of glitch slices.\n     * @default 5\n     */\n    slices?: number;\n    /**\n     * The maximum offset amount of slices.\n     * @default 100\n     */\n    offset?: number;\n    /**\n     * The angle in degree of the offset of slices.\n     * @default 0\n     */\n    direction?: number;\n    /**\n     * The fill mode of the space after the offset.\n     * @default FILL_MODES.TRANSPARENT\n     */\n    fillMode?: number;\n    /**\n     * A seed value for randomizing glitch effect.\n     * @default 0\n     */\n    seed?: number;\n    /**\n     * `true` will divide the bands roughly based on equal amounts\n     * where as setting to `false` will vary the band sizes dramatically (more random looking).\n     * @default false\n     */\n    average?: boolean;\n    /**\n     * Minimum size of slices as a portion of the `sampleSize`\n     * @default 8\n     */\n    minSize?: number;\n    /**\n     * Height of the displacement map canvas.\n     * @default 512\n     */\n    sampleSize?: number;\n    /**\n     * Red channel offset.\n     * @default {x:0,y:0}\n     */\n    red?: PointData | number[];\n    /**\n     * Green channel offset.\n     * @default {x:0,y:0}\n     */\n    green?: PointData | number[];\n    /**\n     * Blue offset.\n     * @default {x:0,y:0}\n     */\n    blue?: PointData | number[];\n}\n\n/**\n * The GlitchFilter applies a glitch effect to an object.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/glitch.png)\n *\n * @class\n * @extends Filter\n */\nexport class GlitchFilter extends Filter\n{\n    /** Default constructor options. */\n    public static readonly defaults: GlitchFilterOptions = {\n        slices: 5,\n        offset: 100,\n        direction: 0,\n        fillMode: 0,\n        average: false,\n        seed: 0,\n        red: { x: 0, y: 0 },\n        green: { x: 0, y: 0 },\n        blue: { x: 0, y: 0 },\n        minSize: 8,\n        sampleSize: 512,\n    };\n\n    public uniforms: {\n        uSeed: number\n        uDimensions: Float32Array,\n        uAspect: number,\n        uFillMode: number,\n        uOffset: number,\n        uDirection: number,\n        uRed: PointData,\n        uGreen: PointData,\n        uBlue: PointData,\n    };\n\n    /**\n     * `true` will divide the bands roughly based on equal amounts\n     * where as setting to `false` will vary the band sizes dramatically (more random looking).\n     */\n    public average = false;\n\n    /** Minimum size of slices as a portion of the `sampleSize` */\n    public minSize = 8;\n\n    /** Height of the displacement map canvas. */\n    public sampleSize = 512;\n\n    /** Internally generated canvas. */\n    private _canvas: HTMLCanvasElement;\n\n    /**\n     * The displacement map is used to generate the bands.\n     * If using your own texture, `slices` will be ignored.\n     *\n     * @member {Texture}\n     * @readonly\n     */\n    public texture: Texture;\n\n    /** Internal number of slices */\n    private _slices = 0;\n\n    private _sizes: Float32Array = new Float32Array(1);\n    private _offsets: Float32Array = new Float32Array(1);\n\n    /**\n     * @param options - Options for the GlitchFilter constructor.\n     */\n    constructor(options?: GlitchFilterOptions)\n    {\n        options = { ...GlitchFilter.defaults, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'glitch-filter',\n        });\n\n        const canvas = document.createElement('canvas');\n\n        canvas.width = 4;\n        canvas.height = options.sampleSize ?? 512;\n\n        const texture = new Texture({\n            source: new ImageSource({ resource: canvas })\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                glitchUniforms: {\n                    uSeed: { value: options?.seed ?? 0, type: 'f32' },\n                    uDimensions: { value: new Float32Array(2), type: 'vec2<f32>' },\n                    uAspect: { value: 1, type: 'f32' },\n                    uFillMode: { value: options?.fillMode ?? 0, type: 'f32' },\n                    uOffset: { value: options?.offset ?? 100, type: 'f32' },\n                    uDirection: { value: options?.direction ?? 0, type: 'f32' },\n                    uRed: { value: options.red, type: 'vec2<f32>' },\n                    uGreen: { value: options.green, type: 'vec2<f32>' },\n                    uBlue: { value: options.blue, type: 'vec2<f32>' },\n                },\n                uDisplacementMap: texture.source,\n                uDisplacementSampler: texture.source.style,\n            },\n        });\n\n        this.uniforms = this.resources.glitchUniforms.uniforms;\n\n        this._canvas = canvas;\n        this.texture = texture;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in Filter\n     * @private\n     */\n    apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        const { width, height } = input.frame;\n\n        this.uniforms.uDimensions[0] = width;\n        this.uniforms.uDimensions[1] = height;\n        this.uniforms.uAspect = height / width;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Randomize the slices size (heights).\n     *\n     * @private\n     */\n    private _randomizeSizes()\n    {\n        const arr = this._sizes;\n        const last = this._slices - 1;\n        const size = this.sampleSize;\n        const min = Math.min(this.minSize / size, 0.9 / this._slices);\n\n        if (this.average)\n        {\n            const count = this._slices;\n            let rest = 1;\n\n            for (let i = 0; i < last; i++)\n            {\n                const averageWidth = rest / (count - i);\n                const w = Math.max(averageWidth * (1 - (Math.random() * 0.6)), min);\n\n                arr[i] = w;\n                rest -= w;\n            }\n            arr[last] = rest;\n        }\n        else\n        {\n            let rest = 1;\n            const ratio = Math.sqrt(1 / this._slices);\n\n            for (let i = 0; i < last; i++)\n            {\n                const w = Math.max(ratio * rest * Math.random(), min);\n\n                arr[i] = w;\n                rest -= w;\n            }\n            arr[last] = rest;\n        }\n\n        this.shuffle();\n    }\n\n    /**\n     * Shuffle the sizes of the slices, advanced usage.\n     */\n    shuffle(): void\n    {\n        const arr = this._sizes;\n        const last = this._slices - 1;\n\n        // shuffle\n        for (let i = last; i > 0; i--)\n        {\n            const rand = (Math.random() * i) >> 0;\n            const temp = arr[i];\n\n            arr[i] = arr[rand];\n            arr[rand] = temp;\n        }\n    }\n\n    /**\n     * Randomize the values for offset from -1 to 1\n     *\n     * @private\n     */\n    private _randomizeOffsets(): void\n    {\n        for (let i = 0; i < this._slices; i++)\n        {\n            this._offsets[i] = Math.random() * (Math.random() < 0.5 ? -1 : 1);\n        }\n    }\n\n    /**\n     * Regenerating random size, offsets for slices.\n     */\n    refresh(): void\n    {\n        this._randomizeSizes();\n        this._randomizeOffsets();\n        this.redraw();\n    }\n\n    /**\n     * Redraw displacement bitmap texture, advanced usage.\n     */\n    redraw(): void\n    {\n        const size = this.sampleSize;\n        const texture = this.texture;\n        const ctx = this._canvas.getContext('2d') as CanvasRenderingContext2D;\n\n        ctx.clearRect(0, 0, 8, size);\n\n        let offset;\n        let y = 0;\n\n        for (let i = 0; i < this._slices; i++)\n        {\n            offset = Math.floor(this._offsets[i] * 256);\n            const height = this._sizes[i] * size;\n            const red = offset > 0 ? offset : 0;\n            const green = offset < 0 ? -offset : 0;\n\n            ctx.fillStyle = `rgba(${red}, ${green}, 0, 1)`;\n            ctx.fillRect(0, y >> 0, size, height + 1 >> 0);\n            y += height;\n        }\n\n        texture.source.update();\n    }\n\n    /**\n     * Manually custom slices size (height) of displacement bitmap\n     *\n     * @member {number[]|Float32Array}\n     */\n    set sizes(sizes: Float32Array)\n    {\n        const len = Math.min(this._slices, sizes.length);\n\n        for (let i = 0; i < len; i++)\n        {\n            this._sizes[i] = sizes[i];\n        }\n    }\n    get sizes(): Float32Array\n    {\n        return this._sizes;\n    }\n\n    /**\n     * Manually set custom slices offset of displacement bitmap, this is\n     * a collection of values from -1 to 1. To change the max offset value\n     * set `offset`.\n     *\n     * @member {number[]|Float32Array}\n     */\n    set offsets(offsets: Float32Array)\n    {\n        const len = Math.min(this._slices, offsets.length);\n\n        for (let i = 0; i < len; i++)\n        {\n            this._offsets[i] = offsets[i];\n        }\n    }\n    get offsets(): Float32Array { return this._offsets; }\n\n    /**\n     * The count of slices.\n     * @default 5\n     */\n    get slices(): number { return this._slices; }\n    set slices(value: number)\n    {\n        if (this._slices === value) return;\n        this._slices = value;\n        this._sizes = new Float32Array(value);\n        this._offsets = new Float32Array(value);\n        this.refresh();\n    }\n\n    /**\n     * The maximum offset amount of slices.\n     * @default 100\n     */\n    get offset(): number { return this.uniforms.uOffset; }\n    set offset(value: number) { this.uniforms.uOffset = value; }\n\n    /**\n     * A seed value for randomizing glitch effect.\n     * @default 0\n     */\n    get seed(): number { return this.uniforms.uSeed; }\n    set seed(value: number) { this.uniforms.uSeed = value; }\n\n    /**\n     * The fill mode of the space after the offset.\n     * @default FILL_MODES.TRANSPARENT\n     */\n    get fillMode(): FILL_MODES { return this.uniforms.uFillMode; }\n    set fillMode(value: FILL_MODES) { this.uniforms.uFillMode = value; }\n\n    /**\n     * The angle in degree of the offset of slices.\n     * @default 0\n     */\n    get direction(): number { return this.uniforms.uDirection / DEG_TO_RAD; }\n    set direction(value: number) { this.uniforms.uDirection = value * DEG_TO_RAD; }\n\n    /**\n     * Red channel offset.\n     * @default {x:0,y:0}\n     */\n    get red(): PointData { return this.uniforms.uRed; }\n    set red(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uRed = value;\n    }\n\n    /**\n     * Green channel offset.\n     * @default {x:0,y:0}\n     */\n    get green(): PointData { return this.uniforms.uGreen; }\n    set green(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uGreen = value;\n    }\n\n    /**\n     * Blue offset.\n     * @default {x:0,y:0}\n     */\n    get blue(): PointData { return this.uniforms.uBlue; }\n    set blue(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uBlue = value;\n    }\n\n    /**\n     * Removes all references\n     */\n    destroy(): void\n    {\n        this.texture?.destroy(true);\n        this.texture\n        = this._canvas\n        = this.red\n        = this.green\n        = this.blue\n        = this._sizes\n        = this._offsets = null as any;\n    }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uStrength;\\nuniform vec3 uColor;\\nuniform float uKnockout;\\nuniform float uAlpha;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nconst float PI = 3.14159265358979323846264;\\n\\n// Hard-assignment of DIST and ANGLE_STEP_SIZE instead of using uDistance and uQuality to allow them to be use on GLSL loop conditions\\nconst float DIST = __DIST__;\\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.);\\nconst float ANGLE_STEP_NUM = ceil(PI * 2. / ANGLE_STEP_SIZE);\\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.) / 2.;\\n\\nvoid main(void) {\\n    vec2 px = vec2(1.) / uInputSize.xy;\\n\\n    float totalAlpha = 0.;\\n\\n    vec2 direction;\\n    vec2 displaced;\\n    vec4 curColor;\\n\\n    for (float angle = 0.; angle < PI * 2.; angle += ANGLE_STEP_SIZE) {\\n      direction = vec2(cos(angle), sin(angle)) * px;\\n\\n      for (float curDistance = 0.; curDistance < DIST; curDistance++) {\\n          displaced = clamp(vTextureCoord + direction * (curDistance + 1.), uInputClamp.xy, uInputClamp.zw);\\n          curColor = texture(uTexture, displaced);\\n          totalAlpha += (DIST - curDistance) * curColor.a;\\n      }\\n    }\\n    \\n    curColor = texture(uTexture, vTextureCoord);\\n\\n    vec4 glowColor = vec4(uColor, uAlpha);\\n    bool knockout = uKnockout > .5;\\n    float innerStrength = uStrength[0];\\n    float outerStrength = uStrength[1];\\n\\n    float alphaRatio = totalAlpha / MAX_TOTAL_ALPHA;\\n    float innerGlowAlpha = (1. - alphaRatio) * innerStrength * curColor.a * uAlpha;\\n    float innerGlowStrength = min(1., innerGlowAlpha);\\n    \\n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a) * uAlpha;\\n    float outerGlowStrength = min(1. - innerColor.a, outerGlowAlpha);\\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\\n\\n    if (knockout) {\\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\\n      finalColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\\n    }\\n    else {\\n      finalColor = innerColor + outerGlowColor;\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=glow.mjs.map\n", "var source = \"struct GlowUniforms {\\n  uDistance: f32,\\n  uStrength: vec2<f32>,\\n  uColor: vec3<f32>,\\n  uAlpha: f32,\\n  uQuality: f32,\\n  uKnockout: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> glowUniforms : GlowUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let quality = glowUniforms.uQuality;\\n  let distance = glowUniforms.uDistance;\\n\\n  let dist: f32 = glowUniforms.uDistance;\\n  let angleStepSize: f32 = min(1. / quality / distance, PI * 2.0);\\n  let angleStepNum: f32 = ceil(PI * 2.0 / angleStepSize);\\n\\n  let px: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\\n\\n  var totalAlpha: f32 = 0.0;\\n\\n  var direction: vec2<f32>;\\n  var displaced: vec2<f32>;\\n  var curColor: vec4<f32>;\\n\\n  for (var angle = 0.0; angle < PI * 2.0; angle += angleStepSize) {\\n    direction = vec2<f32>(cos(angle), sin(angle)) * px;\\n    for (var curDistance = 0.0; curDistance < dist; curDistance+=1) {\\n      displaced = vec2<f32>(clamp(uv + direction * (curDistance + 1.0), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n      curColor = textureSample(uTexture, uSampler, displaced);\\n      totalAlpha += (dist - curDistance) * curColor.a;\\n    }\\n  }\\n    \\n  curColor = textureSample(uTexture, uSampler, uv);\\n\\n  let glowColorRGB = glowUniforms.uColor;\\n  let glowAlpha = glowUniforms.uAlpha;\\n  let glowColor = vec4<f32>(glowColorRGB, glowAlpha);\\n  let knockout: bool = glowUniforms.uKnockout > 0.5;\\n  let innerStrength = glowUniforms.uStrength[0];\\n  let outerStrength = glowUniforms.uStrength[1];\\n\\n  let alphaRatio: f32 = (totalAlpha / (angleStepNum * dist * (dist + 1.0) / 2.0));\\n  let innerGlowAlpha: f32 = (1.0 - alphaRatio) * innerStrength * curColor.a * glowAlpha;\\n  let innerGlowStrength: f32 = min(1.0, innerGlowAlpha);\\n  \\n  let innerColor: vec4<f32> = mix(curColor, glowColor, innerGlowStrength);\\n  let outerGlowAlpha: f32 = alphaRatio * outerStrength * (1. - curColor.a) * glowAlpha;\\n  let outerGlowStrength: f32 = min(1.0 - innerColor.a, outerGlowAlpha);\\n  let outerGlowColor: vec4<f32> = outerGlowStrength * glowColor.rgba;\\n  \\n  if (knockout) {\\n    let resultAlpha: f32 = outerGlowAlpha + innerGlowAlpha;\\n    return vec4<f32>(glowColor.rgb * resultAlpha, resultAlpha);\\n  }\\n  else {\\n    return innerColor + outerGlowColor;\\n  }\\n}\\n\\nconst PI: f32 = 3.14159265358979323846264;\";\n\nexport { source as default };\n//# sourceMappingURL=glow2.mjs.map\n", "import { Color, ColorSource, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './glow.frag';\nimport source from './glow.wgsl';\n\n/**\n * Options for the GlowFilter constructor.\n */\nexport interface GlowFilterOptions\n{\n    /**\n     * The distance of the glow\n     * @default 10\n     */\n    distance?: number;\n    /**\n     * The strength of the glow outward from the edge of the sprite\n     * @default 4\n     */\n    outerStrength?: number;\n    /**\n     * The strength of the glow inward from the edge of the sprite\n     * @default 0\n     */\n    innerStrength?: number;\n    /**\n     * The color of the glow\n     * @default 0xffffff\n     */\n    color?: ColorSource;\n    /**\n     * The alpha of the glow\n     * @default 1\n     */\n    alpha?: number;\n    /**\n     * A number between 0 and 1 that describes the quality of the glow. The higher the number the less performant\n     * @default 0.1\n     */\n    quality?: number;\n    /**\n     * Toggle to hide the contents and only show glow\n     * @default false\n     */\n    knockout?: boolean;\n}\n\n/**\n * GlowFilter, originally by mishaa\n * [codepen]{@link http://codepen.io/mishaa/pen/raKzrm}.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/glow.png)\n * @class\n *\n * @extends Filter\n *\n * @example\n *  someSprite.filters = [\n *      new GlowFilter({ distance: 15, outerStrength: 2 })\n *  ];\n */\nexport class GlowFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: GlowFilterOptions = {\n        distance: 10,\n        outerStrength: 4,\n        innerStrength: 0,\n        color: 0xffffff,\n        alpha: 1,\n        quality: 0.1,\n        knockout: false,\n    };\n\n    public uniforms: {\n        uDistance: number;\n        uStrength: Float32Array;\n        uColor: Float32Array;\n        uAlpha: number;\n        uQuality: number;\n        uKnockout: number;\n    };\n\n    private _color!: Color;\n\n    /**\n     * @param options - Options for the GlowFilter constructor.\n     */\n    constructor(options?: GlowFilterOptions)\n    {\n        options = { ...GlowFilter.DEFAULT_OPTIONS, ...options };\n\n        const distance = options.distance ?? 10;\n        const quality = options.quality ?? 0.1;\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        // Altering uDistance and uQuality won't have any affect on WebGL\n        // since we hard-assign them during creation to allow\n        // for the values to be used in GLSL loops\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment: fragment\n                .replace(/__ANGLE_STEP_SIZE__/gi, `${(1 / quality / distance).toFixed(7)}`)\n                .replace(/__DIST__/gi, `${distance.toFixed(0)}.0`),\n            name: 'glow-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                glowUniforms: {\n                    uDistance: { value: distance, type: 'f32' },\n                    uStrength: { value: [options.innerStrength, options.outerStrength], type: 'vec2<f32>' },\n                    uColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uAlpha: { value: options.alpha, type: 'f32' },\n                    uQuality: { value: quality, type: 'f32' },\n                    uKnockout: { value: (options?.knockout ?? false) ? 1 : 0, type: 'f32' },\n                }\n            },\n            padding: distance,\n        });\n\n        this.uniforms = this.resources.glowUniforms.uniforms;\n        this._color = new Color();\n        this.color = options.color ?? 0xffffff;\n    }\n\n    /**\n     * Only draw the glow, not the texture itself\n     * @default false\n     */\n    get distance(): number { return this.uniforms.uDistance; }\n    set distance(value: number) { this.uniforms.uDistance = this.padding = value; }\n\n    /**\n    * The strength of the glow inward from the edge of the sprite.\n    * @default 0\n    */\n    get innerStrength(): number { return this.uniforms.uStrength[0]; }\n    set innerStrength(value: number) { this.uniforms.uStrength[0] = value; }\n\n    /**\n    * The strength of the glow outward from the edge of the sprite.\n    * @default 4\n    */\n    get outerStrength(): number { return this.uniforms.uStrength[1]; }\n    set outerStrength(value: number) { this.uniforms.uStrength[1] = value; }\n\n    /**\n    * The color of the glow.\n    * @default 0xFFFFFF\n    */\n    get color(): ColorSource { return this._color.value as ColorSource; }\n    set color(value: ColorSource)\n    {\n        this._color.setValue(value);\n        const [r, g, b] = this._color.toArray();\n\n        this.uniforms.uColor[0] = r;\n        this.uniforms.uColor[1] = g;\n        this.uniforms.uColor[2] = b;\n    }\n\n    /**\n    * The alpha of the glow\n    * @default 1\n    */\n    get alpha(): number { return this.uniforms.uAlpha; }\n    set alpha(value: number) { this.uniforms.uAlpha = value; }\n\n    /**\n    * A number between 0 and 1 that describes the quality of the glow. The higher the number the less performant\n    * @default 0.1\n    */\n    get quality(): number { return this.uniforms.uQuality; }\n    set quality(value: number) { this.uniforms.uQuality = value; }\n\n    /**\n    * Only draw the glow, not the texture itself\n    * @default false\n    */\n    get knockout(): boolean { return this.uniforms.uKnockout === 1; }\n    set knockout(value: boolean) { this.uniforms.uKnockout = value ? 1 : 0; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uDimensions;\\nuniform float uParallel;\\nuniform vec2 uLight;\\nuniform float uAspect;\\nuniform float uTime;\\nuniform vec3 uRay;\\n\\nuniform vec4 uInputSize;\\n\\n${PERLIN}\\n\\nvoid main(void) {\\n    vec2 uDimensions = uDimensions;\\n    bool uParallel = uParallel > 0.5;\\n    vec2 uLight = uLight;\\n    float uAspect = uAspect;\\n\\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;\\n\\n    float d;\\n\\n    if (uParallel) {\\n        float _cos = uLight.x;\\n        float _sin = uLight.y;\\n        d = (_cos * coord.x) + (_sin * coord.y * uAspect);\\n    } else {\\n        float dx = coord.x - uLight.x / uDimensions.x;\\n        float dy = (coord.y - uLight.y / uDimensions.y) * uAspect;\\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\\n        d = dy / dis;\\n    }\\n\\n    float uTime = uTime;\\n    vec3 uRay = uRay;\\n\\n    float gain = uRay[0];\\n    float lacunarity = uRay[1];\\n    float alpha = uRay[2];\\n\\n    vec3 dir = vec3(d, d, 0.0);\\n    float noise = turb(dir + vec3(uTime, 0.0, 62.1 + uTime) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\\n    noise = mix(noise, 0.0, 0.3);\\n    //fade vertically.\\n    vec4 mist = vec4(vec3(noise), 1.0) * (1.0 - coord.y);\\n    mist.a = 1.0;\\n    // apply user alpha\\n    mist *= alpha;\\n\\n    finalColor = texture(uTexture, vTextureCoord) + mist;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=god-ray2.mjs.map\n", "var source = \"struct GodrayUniforms {\\n  uLight: vec2<f32>,\\n  uParallel: f32,\\n  uAspect: f32,\\n  uTime: f32,\\n  uRay: vec3<f32>,\\n  uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> godrayUniforms : GodrayUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uDimensions: vec2<f32> = godrayUniforms.uDimensions;\\n  let uParallel: bool = godrayUniforms.uParallel > 0.5;\\n  let uLight: vec2<f32> = godrayUniforms.uLight;\\n  let uAspect: f32 = godrayUniforms.uAspect;\\n\\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / uDimensions;\\n\\n  var d: f32;\\n\\n  if (uParallel) {\\n    let _cos: f32 = uLight.x;\\n    let _sin: f32 = uLight.y;\\n    d = (_cos * coord.x) + (_sin * coord.y * uAspect);\\n  } else {\\n    let dx: f32 = coord.x - uLight.x / uDimensions.x;\\n    let dy: f32 = (coord.y - uLight.y / uDimensions.y) * uAspect;\\n    let dis: f32 = sqrt(dx * dx + dy * dy) + 0.00001;\\n    d = dy / dis;\\n  }\\n\\n  let uTime: f32 = godrayUniforms.uTime;\\n  let uRay: vec3<f32> = godrayUniforms.uRay;\\n  \\n  let gain = uRay[0];\\n  let lacunarity = uRay[1];\\n  let alpha = uRay[2];\\n\\n  let dir: vec3<f32> = vec3<f32>(d, d, 0.0);\\n  var noise: f32 = turb(dir + vec3<f32>(uTime, 0.0, 62.1 + uTime) * 0.05, vec3<f32>(480.0, 320.0, 480.0), lacunarity, gain);\\n  noise = mix(noise, 0.0, 0.3);\\n  //fade vertically.\\n  var mist: vec4<f32> = vec4<f32>(vec3<f32>(noise), 1.0) * (1.0 - coord.y);\\n  mist.a = 1.0;\\n  // apply user alpha\\n  mist *= alpha;\\n  return textureSample(uTexture, uSampler, uv) + mist;\\n}\\n\\n${PERLIN}\";\n\nexport { source as default };\n//# sourceMappingURL=god-ray.mjs.map\n", "var perlin = \"vec3 mod289(vec3 x)\\n{\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nvec4 mod289(vec4 x)\\n{\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nvec4 permute(vec4 x)\\n{\\n    return mod289(((x * 34.0) + 1.0) * x);\\n}\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n    return 1.79284291400159 - 0.85373472095314 * r;\\n}\\nvec3 fade(vec3 t)\\n{\\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\\n}\\n// Classic Perlin noise, periodic variant\\nfloat pnoise(vec3 P, vec3 rep)\\n{\\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\\n    Pi0 = mod289(Pi0);\\n    Pi1 = mod289(Pi1);\\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n    vec4 iz0 = Pi0.zzzz;\\n    vec4 iz1 = Pi1.zzzz;\\n    vec4 ixy = permute(permute(ix) + iy);\\n    vec4 ixy0 = permute(ixy + iz0);\\n    vec4 ixy1 = permute(ixy + iz1);\\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n    gx0 = fract(gx0);\\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n    vec4 sz0 = step(gz0, vec4(0.0));\\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n    gx1 = fract(gx1);\\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n    vec4 sz1 = step(gz1, vec4(0.0));\\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n    g000 *= norm0.x;\\n    g010 *= norm0.y;\\n    g100 *= norm0.z;\\n    g110 *= norm0.w;\\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n    g001 *= norm1.x;\\n    g011 *= norm1.y;\\n    g101 *= norm1.z;\\n    g111 *= norm1.w;\\n    float n000 = dot(g000, Pf0);\\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n    float n111 = dot(g111, Pf1);\\n    vec3 fade_xyz = fade(Pf0);\\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\\n    return 2.2 * n_xyz;\\n}\\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\\n{\\n    float sum = 0.0;\\n    float sc = 1.0;\\n    float totalgain = 1.0;\\n    for (float i = 0.0; i < 6.0; i++)\\n    {\\n        sum += totalgain * pnoise(P * sc, rep);\\n        sc *= lacunarity;\\n        totalgain *= gain;\\n    }\\n    return abs(sum);\\n}\\n\";\n\nexport { perlin as default };\n//# sourceMappingURL=perlin.mjs.map\n", "var sourcePerlin = \"// Taken from https://gist.github.com/munrocket/236ed5ba7e409b8bdf1ff6eca5dcdc39\\n\\nfn moduloVec3(x: vec3<f32>, y: vec3<f32>) -> vec3<f32>\\n{\\n  return x - y * floor(x/y);\\n}\\nfn mod289Vec3(x: vec3<f32>) -> vec3<f32>\\n{\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nfn mod289Vec4(x: vec4<f32>) -> vec4<f32>\\n{\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nfn permute4(x: vec4<f32>) -> vec4<f32>\\n{\\n    return mod289Vec4(((x * 34.0) + 1.0) * x);\\n}\\nfn taylorInvSqrt(r: vec4<f32>) -> vec4<f32>\\n{\\n    return 1.79284291400159 - 0.85373472095314 * r;\\n}\\nfn fade3(t: vec3<f32>) -> vec3<f32>\\n{\\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\\n}\\nfn fade2(t: vec2<f32>) -> vec2<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }\\n\\nfn perlinNoise2(P: vec2<f32>) -> f32 {\\n  var Pi: vec4<f32> = floor(P.xyxy) + vec4<f32>(0., 0., 1., 1.);\\n  let Pf = fract(P.xyxy) - vec4<f32>(0., 0., 1., 1.);\\n  Pi = Pi % vec4<f32>(289.); // To avoid truncation effects in permutation\\n  let ix = Pi.xzxz;\\n  let iy = Pi.yyww;\\n  let fx = Pf.xzxz;\\n  let fy = Pf.yyww;\\n  let i = permute4(permute4(ix) + iy);\\n  var gx: vec4<f32> = 2. * fract(i * 0.0243902439) - 1.; // 1/41 = 0.024...\\n  let gy = abs(gx) - 0.5;\\n  let tx = floor(gx + 0.5);\\n  gx = gx - tx;\\n  var g00: vec2<f32> = vec2<f32>(gx.x, gy.x);\\n  var g10: vec2<f32> = vec2<f32>(gx.y, gy.y);\\n  var g01: vec2<f32> = vec2<f32>(gx.z, gy.z);\\n  var g11: vec2<f32> = vec2<f32>(gx.w, gy.w);\\n  let norm = 1.79284291400159 - 0.85373472095314 *\\n      vec4<f32>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\\n  g00 = g00 * norm.x;\\n  g01 = g01 * norm.y;\\n  g10 = g10 * norm.z;\\n  g11 = g11 * norm.w;\\n  let n00 = dot(g00, vec2<f32>(fx.x, fy.x));\\n  let n10 = dot(g10, vec2<f32>(fx.y, fy.y));\\n  let n01 = dot(g01, vec2<f32>(fx.z, fy.z));\\n  let n11 = dot(g11, vec2<f32>(fx.w, fy.w));\\n  let fade_xy = fade2(Pf.xy);\\n  let n_x = mix(vec2<f32>(n00, n01), vec2<f32>(n10, n11), vec2<f32>(fade_xy.x));\\n  let n_xy = mix(n_x.x, n_x.y, fade_xy.y);\\n  return 2.3 * n_xy;\\n}\\n\\n// Classic Perlin noise, periodic variant\\nfn perlinNoise3(P: vec3<f32>, rep: vec3<f32>) -> f32\\n{\\n    var Pi0: vec3<f32> = moduloVec3(floor(P), rep); // Integer part, modulo period\\n    var Pi1: vec3<f32> = moduloVec3(Pi0 + vec3<f32>(1.0), rep); // Integer part + 1, mod period\\n    Pi0 = mod289Vec3(Pi0);\\n    Pi1 = mod289Vec3(Pi1);\\n    let Pf0: vec3<f32> = fract(P); // Fractional part for interpolation\\n    let Pf1: vec3<f32> = Pf0 - vec3<f32>(1.0); // Fractional part - 1.0\\n    let ix: vec4<f32> = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n    let iy: vec4<f32> = vec4<f32>(Pi0.yy, Pi1.yy);\\n    let iz0: vec4<f32> = Pi0.zzzz;\\n    let iz1: vec4<f32> = Pi1.zzzz;\\n    let ixy: vec4<f32> = permute4(permute4(ix) + iy);\\n    let ixy0: vec4<f32> = permute4(ixy + iz0);\\n    let ixy1: vec4<f32> = permute4(ixy + iz1);\\n    var gx0: vec4<f32> = ixy0 * (1.0 / 7.0);\\n    var gy0: vec4<f32> = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n    gx0 = fract(gx0);\\n    let gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);\\n    let sz0: vec4<f32> = step(gz0, vec4<f32>(0.0));\\n    gx0 -= sz0 * (step(vec4<f32>(0.0), gx0) - 0.5);\\n    gy0 -= sz0 * (step(vec4<f32>(0.0), gy0) - 0.5);\\n    var gx1: vec4<f32> = ixy1 * (1.0 / 7.0);\\n    var gy1: vec4<f32> = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n    gx1 = fract(gx1);\\n    let gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);\\n    let sz1: vec4<f32> = step(gz1, vec4<f32>(0.0));\\n    gx1 -= sz1 * (step(vec4<f32>(0.0), gx1) - 0.5);\\n    gy1 -= sz1 * (step(vec4<f32>(0.0), gy1) - 0.5);\\n    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);\\n    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);\\n    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);\\n    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);\\n    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);\\n    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);\\n    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);\\n    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);\\n    let norm0: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n    g000 *= norm0.x;\\n    g010 *= norm0.y;\\n    g100 *= norm0.z;\\n    g110 *= norm0.w;\\n    let norm1: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n    g001 *= norm1.x;\\n    g011 *= norm1.y;\\n    g101 *= norm1.z;\\n    g111 *= norm1.w;\\n    let n000: f32 = dot(g000, Pf0);\\n    let n100: f32 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));\\n    let n010: f32 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));\\n    let n110: f32 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));\\n    let n001: f32 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));\\n    let n101: f32 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));\\n    let n011: f32 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));\\n    let n111: f32 = dot(g111, Pf1);\\n    let fade_xyz: vec3<f32> = fade3(Pf0);\\n    let n_z: vec4<f32> = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), fade_xyz.z);\\n    let n_yz: vec2<f32> = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n    let n_xyz: f32 = mix(n_yz.x, n_yz.y, fade_xyz.x);\\n    return 2.2 * n_xyz;\\n}\\nfn turb(P: vec3<f32>, rep: vec3<f32>, lacunarity: f32, gain: f32) -> f32\\n{\\n    var sum: f32 = 0.0;\\n    var sc: f32 = 1.0;\\n    var totalgain: f32 = 1.0;\\n    for (var i = 0.0; i < 6.0; i += 1)\\n    {\\n        sum += totalgain * perlinNoise3(P * sc, rep);\\n        sc *= lacunarity;\\n        totalgain *= gain;\\n    }\\n    return abs(sum);\\n}\";\n\nexport { sourcePerlin as default };\n//# sourceMappingURL=perlin2.mjs.map\n", "import { DEG_TO_RAD, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './god-ray.frag';\nimport source from './god-ray.wgsl';\nimport perlin from './perlin.frag';\nimport sourcePerlin from './perlin.wgsl';\n\nimport type { FilterSystem, PointData, RenderSurface, Texture } from 'pixi.js';\n\n/** Options for the GodrayFilter constructor. */\nexport interface GodrayFilterOptions\n{\n    /**\n     * The angle/light-source of the rays in degrees. For instance,\n     * a value of 0 is vertical rays, values of 90 or -90 produce horizontal rays.\n     * @default 30\n     */\n    angle?: number;\n    /**\n     * `true` if light rays are parallel (uses angle), `false` to use the focal `center` point\n     * @default true\n     */\n    parallel?: boolean;\n    /**\n     * Focal point for non-parallel rays, to use this `parallel` must be set to `false`.\n     * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n     * once defined in the constructor\n     * @default {x:0,y:0}\n     */\n    center?: PointData | number[];\n    /**\n     * General intensity of the effect. A value closer to 1 will produce a more intense effect,\n     * where a value closer to 0 will produce a subtler effect.\n     * @default 0.5\n     */\n    gain?: number;\n    /**\n     * The density of the fractal noise\n     * @default 2.5\n     */\n    lacunarity?: number;\n    /**\n     * The current time position\n     * @default 0\n     */\n    time?: number;\n    /**\n     * The alpha (opacity) of the rays.  0 is fully transparent, 1 is fully opaque.\n     * @default 1\n     */\n    alpha?: number;\n}\n\n/**\n * GordayFilter, {@link https://codepen.io/alaingalvan originally} by Alain Galvan\n *\n *\n *\n * ![original](../screenshots/original.png)![filter](../screenshots/godray.gif)\n * @class\n * @extends Filter\n *\n * @example\n *  displayObject.filters = [new GodrayFilter()];\n */\nexport class GodrayFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: GodrayFilterOptions = {\n        angle: 30,\n        gain: 0.5,\n        lacunarity: 2.5,\n        parallel: true,\n        time: 0,\n        center: { x: 0, y: 0 },\n        alpha: 1,\n    };\n\n    public uniforms: {\n        uLight: Float32Array;\n        uParallel: number;\n        uAspect: number;\n        uTime: number;\n        uRay: Float32Array;\n        uDimensions: Float32Array;\n    };\n\n    /**\n     * The current time position\n     * @default 0\n     */\n    public time = 0;\n\n    private _angleLight: [number, number] = [0, 0];\n    private _angle = 0;\n    private _center!: PointData;\n\n    /**\n     * @param options - Options for the GodrayFilter constructor.\n     */\n    constructor(options?: GodrayFilterOptions)\n    {\n        options = { ...GodrayFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source: source.replace('${PERLIN}', sourcePerlin),\n                entryPoint: 'mainFragment',\n            },\n        });\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment: fragment.replace('${PERLIN}', perlin),\n            name: 'god-ray-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                godrayUniforms: {\n                    uLight: { value: new Float32Array(2), type: 'vec2<f32>' },\n                    uParallel: { value: 0, type: 'f32' },\n                    uAspect: { value: 0, type: 'f32' },\n                    uTime: { value: options.time, type: 'f32' },\n                    uRay: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uDimensions: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.godrayUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in Filter\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        const width = input.frame.width;\n        const height = input.frame.height;\n\n        this.uniforms.uLight[0] = this.parallel ? this._angleLight[0] : this._center.x;\n        this.uniforms.uLight[1] = this.parallel ? this._angleLight[1] : this._center.y;\n        this.uniforms.uDimensions[0] = width;\n        this.uniforms.uDimensions[1] = height;\n        this.uniforms.uAspect = height / width;\n        this.uniforms.uTime = this.time;\n\n        // draw the filter...\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * The angle/light-source of the rays in degrees. For instance,\n     * a value of 0 is vertical rays, values of 90 or -90 produce horizontal rays\n     * @default 30\n     */\n    get angle(): number { return this._angle; }\n    set angle(value: number)\n    {\n        this._angle = value;\n\n        const radians = value * DEG_TO_RAD;\n\n        this._angleLight[0] = Math.cos(radians);\n        this._angleLight[1] = Math.sin(radians);\n    }\n\n    /**\n     * `true` if light rays are parallel (uses angle), `false` to use the focal `center` point\n     * @default true\n     */\n    get parallel(): boolean { return this.uniforms.uParallel > 0.5; }\n    set parallel(value: boolean) { this.uniforms.uParallel = value ? 1 : 0; }\n\n    /**\n     * Focal point for non-parallel rays, to use this `parallel` must be set to `false`.\n     * @default {x:0,y:0}\n     */\n    get center(): PointData { return this._center; }\n    set center(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this._center = value;\n    }\n\n    /**\n     * Focal point for non-parallel rays on the `x` axis, to use this `parallel` must be set to `false`.\n     * @default 0\n     */\n    get centerX(): number { return this.center.x; }\n    set centerX(value: number) { this.center.x = value; }\n\n    /**\n     * Focal point for non-parallel rays on the `y` axis, to use this `parallel` must be set to `false`.\n     * @default 0\n     */\n    get centerY(): number { return this.center.y; }\n    set centerY(value: number) { this.center.y = value; }\n\n    /**\n     * General intensity of the effect. A value closer to 1 will produce a more intense effect,\n     * where a value closer to 0 will produce a subtler effect\n     * @default 0.5\n     */\n    get gain(): number { return this.uniforms.uRay[0]; }\n    set gain(value: number) { this.uniforms.uRay[0] = value; }\n\n    /**\n     * The density of the fractal noise.\n     * A higher amount produces more rays and a smaller amount produces fewer waves\n     * @default 2.5\n     */\n    get lacunarity(): number { return this.uniforms.uRay[1]; }\n    set lacunarity(value: number) { this.uniforms.uRay[1] = value; }\n\n    /**\n     * The alpha (opacity) of the rays.  0 is fully transparent, 1 is fully opaque.\n     * @default 1\n     */\n    get alpha(): number { return this.uniforms.uRay[2]; }\n    set alpha(value: number) { this.uniforms.uRay[2] = value; }\n}\n", "var fragment = \"in vec2 vTextureCoord;\\n\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\n\\n// https://en.wikipedia.org/wiki/Luma_(video)\\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\\n\\nvoid main()\\n{\\n    vec4 c = texture(uTexture, vTextureCoord);\\n    finalColor = vec4(\\n        vec3(c.r * weight.r + c.g * weight.g  + c.b * weight.b),\\n        c.a\\n    );\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=grayscale2.mjs.map\n", "var source = \"@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  let g: f32 = dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114));\\n  return vec4<f32>(vec3<f32>(g), 1.);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=grayscale.mjs.map\n", "import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './grayscale.frag';\nimport source from './grayscale.wgsl';\n\n/**\n * This filter applies a grayscale effect.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/grayscale.png)\n *\n * @class\n * @extends Filter\n */\nexport class GrayscaleFilter extends Filter\n{\n    constructor()\n    {\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'grayscale-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {},\n        });\n    }\n}\n", "var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec3 uHsl;\\nuniform float uAlpha;\\nuniform float uColorize;\\n\\n// https://en.wikipedia.org/wiki/Luma_(video)\\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\\n\\nfloat getWeightedAverage(vec3 rgb) {\\n    return rgb.r * weight.r + rgb.g * weight.g + rgb.b * weight.b;\\n}\\n\\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\\nconst vec3 k = vec3(0.57735, 0.57735, 0.57735);\\n\\nvec3 hueShift(vec3 color, float angle) {\\n    float cosAngle = cos(angle);\\n    return vec3(\\n    color * cosAngle +\\n    cross(k, color) * sin(angle) +\\n    k * dot(k, color) * (1.0 - cosAngle)\\n    );\\n}\\n\\nvoid main()\\n{\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    vec3 resultRGB = color.rgb;\\n\\n    float hue = uHsl[0];\\n    float saturation = uHsl[1];\\n    float lightness = uHsl[2];\\n\\n    // colorize\\n    if (uColorize > 0.5) {\\n        resultRGB = vec3(getWeightedAverage(resultRGB), 0., 0.);\\n    }\\n\\n    // hue\\n    resultRGB = hueShift(resultRGB, hue);\\n\\n    // saturation\\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\\n    float average = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;\\n\\n    if (saturation > 0.) {\\n        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));\\n    } else {\\n        resultRGB -= (average - resultRGB) * saturation;\\n    }\\n\\n    // lightness\\n    resultRGB = mix(resultRGB, vec3(ceil(lightness)) * color.a, abs(lightness));\\n\\n    // alpha\\n    finalColor = mix(color, vec4(resultRGB, color.a), uAlpha);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=hsladjustment.mjs.map\n", "var source = \"struct HslUniforms {\\n  uHsl:vec3<f32>,\\n  uColorize:f32,\\n  uAlpha:f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> hslUniforms : HslUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n    let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n    var resultRGB: vec3<f32> = color.rgb;\\n\\n    let hue: f32 = hslUniforms.uHsl[0];\\n    let saturation: f32 = hslUniforms.uHsl[1];\\n    let lightness: f32 = hslUniforms.uHsl[2];\\n\\n    // colorize\\n    if (hslUniforms.uColorize > 0.5) {\\n        resultRGB = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)), 0., 0.);\\n    }\\n\\n    // hue\\n    resultRGB = hueShift(resultRGB, hue);\\n\\n    // saturation\\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\\n    let average: f32 = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;\\n\\n    if (saturation > 0.) {\\n        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));\\n    } else {\\n        resultRGB -= (average - resultRGB) * saturation;\\n    }\\n\\n    // lightness\\n    resultRGB = mix(resultRGB, vec3<f32>(ceil(lightness)) * color.a, abs(lightness));\\n\\n    // alpha\\n    return mix(color, vec4<f32>(resultRGB, color.a), hslUniforms.uAlpha);\\n}\\n\\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\\nconst k: vec3<f32> = vec3(0.57735, 0.57735, 0.57735);\\n\\nfn hueShift(color: vec3<f32>, angle: f32) -> vec3<f32> \\n{\\n    let cosAngle: f32 = cos(angle);\\n    return vec3<f32>(\\n    color * cosAngle +\\n    cross(k, color) * sin(angle) +\\n    k * dot(k, color) * (1.0 - cosAngle)\\n    );\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=hsladjustment2.mjs.map\n", "import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './hsladjustment.frag';\nimport source from './hsladjustment.wgsl';\n\n/**\n * Options for the HslAdjustmentFilter constructor.\n */\nexport interface HslAdjustmentFilterOptions\n{\n    /**\n     * The amount of hue in degrees (-180 to 180)\n     * @default 0\n     */\n    hue: number;\n    /**\n     * The amount of color saturation (-1 to 1)\n     * @default 0\n     */\n    saturation: number;\n    /**\n     * The amount of lightness (-1 to 1)\n     * @default 0\n     */\n    lightness: number;\n    /**\n     * Whether to colorize the image\n     * @default false\n     */\n    colorize: boolean;\n    /**\n     * The amount of alpha (0 to 1)\n     * @default 1\n     */\n    alpha: number;\n}\n\n/**\n * ![original](../screenshots/original.png)![filter](../screenshots/hsl-adjustment.png)\n *\n * This WebGPU filter has been ported from the WebGL renderer that was originally created by Viktor Persson (@vikpe)\n *\n * @class\n * @extends Filter\n */\nexport class HslAdjustmentFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: HslAdjustmentFilterOptions = {\n        hue: 0,\n        saturation: 0,\n        lightness: 0,\n        colorize: false,\n        alpha: 1,\n    };\n\n    public uniforms: {\n        uHsl: Float32Array;\n        uColorize: number;\n        uAlpha: number;\n    };\n\n    private _hue!: number;\n\n    /**\n     * @param options - Options for the HslAdjustmentFilter constructor.\n     */\n    constructor(options?: HslAdjustmentFilterOptions)\n    {\n        options = { ...HslAdjustmentFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'hsl-adjustment-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                hslUniforms: {\n                    uHsl: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uColorize: { value: options.colorize ? 1 : 0, type: 'f32' },\n                    uAlpha: { value: options.alpha, type: 'f32' },\n                },\n            },\n        });\n\n        this.uniforms = this.resources.hslUniforms.uniforms;\n        Object.assign(this, options);\n    }\n\n    /**\n     * The amount of hue in degrees (-180 to 180)\n     * @default 0\n     */\n    get hue(): number { return this._hue; }\n    set hue(value: number)\n    {\n        this._hue = value;\n        this.uniforms.uHsl[0] = value * (Math.PI / 180);\n    }\n\n    /**\n     * The amount of lightness (-1 to 1)\n     * @default 0\n     */\n    get saturation(): number { return this.uniforms.uHsl[1]; }\n    set saturation(value: number) { this.uniforms.uHsl[1] = value; }\n\n    /**\n     * The amount of lightness (-1 to 1)\n     * @default 0\n     */\n    get lightness(): number { return this.uniforms.uHsl[2]; }\n    set lightness(value: number) { this.uniforms.uHsl[2] = value; }\n\n    /**\n     * Whether to colorize the image\n     * @default false\n     */\n    get colorize(): boolean { return this.uniforms.uColorize === 1; }\n    set colorize(value: boolean) { this.uniforms.uColorize = value ? 1 : 0; }\n\n    /**\n     * The amount of alpha (0 to 1)\n     * @default 1\n     */\n    get alpha(): number { return this.uniforms.uAlpha; }\n    set alpha(value: number) { this.uniforms.uAlpha = value; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uVelocity;\\nuniform int uKernelSize;\\nuniform float uOffset;\\n\\nuniform vec4 uInputSize;\\n\\nconst int MAX_KERNEL_SIZE = 2048;\\n\\n// Notice:\\n// the perfect way:\\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\\n// So use uKernelSize directly.\\n\\nvoid main(void)\\n{\\n    vec4 color = texture(uTexture, vTextureCoord);\\n\\n    if (uKernelSize == 0)\\n    {\\n        finalColor = color;\\n        return;\\n    }\\n\\n    vec2 velocity = uVelocity / uInputSize.xy;\\n    float offset = -uOffset / length(uVelocity) - 0.5;\\n    int k = uKernelSize - 1;\\n\\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\\n        if (i == k) {\\n            break;\\n        }\\n        vec2 bias = velocity * (float(i) / float(k) + offset);\\n        color += texture(uTexture, vTextureCoord + bias);\\n    }\\n    finalColor = color / float(uKernelSize);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=motion-blur2.mjs.map\n", "var source = \"struct MotionBlurUniforms {\\n  uVelocity: vec2<f32>,\\n  uKernelSize: i32,\\n  uOffset: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> motionBlurUniforms : MotionBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uVelocity = motionBlurUniforms.uVelocity;\\n  let uKernelSize = motionBlurUniforms.uKernelSize;\\n  let uOffset = motionBlurUniforms.uOffset;\\n\\n  let velocity: vec2<f32> = uVelocity / gfu.uInputSize.xy;\\n  let offset: f32 = -uOffset / length(uVelocity) - 0.5;\\n  let k: i32 = min(uKernelSize - 1, MAX_KERNEL_SIZE - 1);\\n\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  for(var i: i32 = 0; i < k; i += 1) {\\n    let bias: vec2<f32> = velocity * (f32(i) / f32(k) + offset);\\n    color += textureSample(uTexture, uSampler, uv + bias);\\n  }\\n  \\n  return select(color / f32(uKernelSize), textureSample(uTexture, uSampler, uv), uKernelSize == 0);\\n}\\n\\nconst MAX_KERNEL_SIZE: i32 = 2048;\";\n\nexport { source as default };\n//# sourceMappingURL=motion-blur.mjs.map\n", "/* eslint-disable max-len */\nimport { deprecation, Filter, GlProgram, GpuProgram, ObservablePoint, PointData } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './motion-blur.frag';\nimport source from './motion-blur.wgsl';\n\n/** Options for the MotionBlurFilter constructor. */\nexport interface MotionBlurFilterOptions\n{\n    /**\n     * Sets the velocity of the motion for blur effect\n     * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n     * once defined in the constructor\n     * @default {x:0,y:0}\n     */\n    velocity?: PointData | number[];\n    /**\n     * The kernelSize of the blur filter. Must be odd number >= 5\n     * @default 5\n     */\n    kernelSize?: number;\n    /**\n     * The offset of the blur filter\n     * @default 0\n     */\n    offset?: number;\n}\n\n/**\n * The MotionBlurFilter applies a Motion blur to an object.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/motion-blur.png)\n *\n * @class\n * @extends Filter\n */\nexport class MotionBlurFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: MotionBlurFilterOptions = {\n        velocity: { x: 0, y: 0 },\n        kernelSize: 5,\n        offset: 0,\n    };\n\n    public uniforms: {\n        uVelocity: PointData;\n        uKernelSize: number;\n        uOffset: number;\n    };\n\n    private _kernelSize!: number;\n\n    /**\n     * @param options - Options for the MotionBlurFilter constructor.\n     */\n    constructor(options?: MotionBlurFilterOptions);\n    /**\n     * @deprecated since 8.0.0\n     *\n     * @param {PIXI.ObservablePoint|PIXI.PointData|number[]} [velocity=[0, 0]] - Sets the velocity of the motion for blur effect.\n     * @param {number} [kernelSize=5] - The kernelSize of the blur filter. Must be odd number >= 5\n     * @param {number} [offset=0] - The offset of the blur filter.\n     */\n    constructor(velocity?: number[] | PointData | ObservablePoint, kernelSize?: number, offset?: number);\n    /** @ignore */\n    constructor(...args: [MotionBlurFilterOptions?] | [(number[] | PointData | ObservablePoint)?, number?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (Array.isArray(options) || ('x' in options && 'y' in options) || options instanceof ObservablePoint)\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'MotionBlurFilter constructor params are now options object. See params: { velocity, kernelSize, offset }');\n\n            const x = 'x' in options ? options.x : options[0];\n            const y = 'y' in options ? options.y : options[1];\n\n            options = { velocity: { x, y } };\n\n            if (args[1] !== undefined) options.kernelSize = args[1];\n            if (args[2] !== undefined) options.offset = args[2];\n        }\n\n        options = { ...MotionBlurFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'motion-blur-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                motionBlurUniforms: {\n                    uVelocity: { value: options.velocity, type: 'vec2<f32>' },\n                    uKernelSize: { value: Math.trunc(options.kernelSize ?? 5), type: 'i32' },\n                    uOffset: { value: options.offset, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.motionBlurUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Sets the velocity of the motion for blur effect\n     * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n     * once defined in the constructor\n     * @default {x:0,y:0}\n     */\n    get velocity(): PointData { return this.uniforms.uVelocity; }\n    set velocity(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uVelocity = value;\n        this._updateDirty();\n    }\n\n    /**\n     * Sets the velocity of the motion for blur effect on the `x` axis\n     * @default 0\n     */\n    get velocityX(): number { return this.velocity.x; }\n    set velocityX(value: number)\n    {\n        this.velocity.x = value;\n        this._updateDirty();\n    }\n\n    /**\n     * Sets the velocity of the motion for blur effect on the `x` axis\n     * @default 0\n     */\n    get velocityY(): number { return this.velocity.y; }\n    set velocityY(value: number)\n    {\n        this.velocity.y = value;\n        this._updateDirty();\n    }\n\n    /**\n     * The kernelSize of the blur filter. Must be odd number >= 5\n     * @default 5\n     */\n    get kernelSize(): number { return this._kernelSize; }\n    set kernelSize(value: number)\n    {\n        this._kernelSize = value;\n        this._updateDirty();\n    }\n\n    /**\n     * The offset of the blur filter\n     * @default 0\n     */\n    get offset(): number { return this.uniforms.uOffset; }\n    set offset(value: number) { this.uniforms.uOffset = value; }\n\n    private _updateDirty()\n    {\n        // The padding will be increased as the velocity and intern the blur size is changed\n        this.padding = (Math.max(Math.abs(this.velocityX), Math.abs(this.velocityY)) >> 0) + 1;\n        this.uniforms.uKernelSize = (this.velocityX !== 0 || this.velocityY !== 0) ? this._kernelSize : 0;\n    }\n}\n", "var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nconst int MAX_COLORS = ${MAX_COLORS};\\n\\nuniform sampler2D uTexture;\\nuniform vec3 uOriginalColors[MAX_COLORS];\\nuniform vec3 uTargetColors[MAX_COLORS];\\nuniform float uTolerance;\\n\\nvoid main(void)\\n{\\n    finalColor = texture(uTexture, vTextureCoord);\\n\\n    float alpha = finalColor.a;\\n    if (alpha < 0.0001)\\n    {\\n      return;\\n    }\\n\\n    vec3 color = finalColor.rgb / alpha;\\n\\n    for(int i = 0; i < MAX_COLORS; i++)\\n    {\\n      vec3 origColor = uOriginalColors[i];\\n      if (origColor.r < 0.0)\\n      {\\n        break;\\n      }\\n      vec3 colorDiff = origColor - color;\\n      if (length(colorDiff) < uTolerance)\\n      {\\n        vec3 targetColor = uTargetColors[i];\\n        finalColor = vec4((targetColor + colorDiff) * alpha, alpha);\\n        return;\\n      }\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=multi-color-replace.mjs.map\n", "var source = \"struct MultiColorReplaceUniforms {\\n  uOriginalColors: array<vec3<f32>, MAX_COLORS>,\\n  uTargetColors: array<vec3<f32>, MAX_COLORS>,\\n  uTolerance:f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> multiColorReplaceUniforms : MultiColorReplaceUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uOriginalColors = multiColorReplaceUniforms.uOriginalColors;\\n  let uTargetColors = multiColorReplaceUniforms.uTargetColors;\\n  let uTolerance = multiColorReplaceUniforms.uTolerance;\\n\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  let alpha: f32 = color.a;\\n\\n  if (alpha > 0.0001)\\n  {\\n    var modColor: vec3<f32> = vec3<f32>(color.rgb) / alpha;\\n\\n    for(var i: i32 = 0; i < MAX_COLORS; i += 1)\\n    {\\n      let origColor: vec3<f32> = uOriginalColors[i];\\n      if (origColor.r < 0.0)\\n      {\\n        break;\\n      }\\n      let colorDiff: vec3<f32> = origColor - modColor;\\n      \\n      if (length(colorDiff) < uTolerance)\\n      {\\n        let targetColor: vec3<f32> = uTargetColors[i];\\n        color = vec4((targetColor + colorDiff) * alpha, alpha);\\n        return color;\\n      }\\n    }\\n  }\\n\\n  return color;\\n}\\n\\nconst MAX_COLORS: i32 = ${MAX_COLORS};\";\n\nexport { source as default };\n//# sourceMappingURL=multi-color-replace2.mjs.map\n", "import { Color, ColorSource, deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './multi-color-replace.frag';\nimport source from './multi-color-replace.wgsl';\n\ntype DeprecatedColor = number | number[] | Float32Array;\n\n/** Options for the MultiColorReplaceFilter constructor. */\nexport interface MultiColorReplaceFilterOptions\n{\n    /**\n     * The collection of replacement items. Each item is color-pair\n     * (an array length is 2). In the pair, the first value is original color , the second value is target color\n     *\n     * _If you wish to change individual elements on the replacement array after instantiation,\n     * use the `refresh` function to update the uniforms once you've made the changes_\n     */\n    replacements: Array<[ColorSource, ColorSource]>;\n    /**\n     * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n     * @default 0.05\n     */\n    tolerance?: number\n    /**\n     * The maximum number of replacements filter is able to use.\n     * Because the fragment is only compiled once, this cannot be changed after construction.\n     * If omitted, the default value is the length of `replacements`\n     */\n    maxColors?: number;\n}\n\n/**\n * Filter for replacing a color with another color. Similar to ColorReplaceFilter, but support multiple\n * colors.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/multi-color-replace.png)\n * @class\n * @extends Filter\n *\n * @example\n *  // replaces pure red with pure blue, and replaces pure green with pure white\n *  someSprite.filters = [new MultiColorReplaceFilter({\n *    replacements: [\n *      [0xFF0000, 0x0000FF],\n *      [0x00FF00, 0xFFFFFF]\n *    ],\n *    tolerance: 0.001\n *  })];\n *\n *  You also could use [R, G, B] as the color\n *  someOtherSprite.filters = [new MultiColorReplaceFilter({\n *    replacements: [\n *      [ [1,0,0], [0,0,1] ],\n *      [ [0,1,0], [1,1,1] ]\n *    ],\n *    tolerance: 0.001\n *  })];\n *\n */\nexport class MultiColorReplaceFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: MultiColorReplaceFilterOptions = {\n        replacements: [[0xff0000, 0x0000ff]],\n        tolerance: 0.05,\n        maxColors: undefined,\n    };\n\n    public uniforms: {\n        uOriginalColors: Float32Array;\n        uTargetColors: Float32Array;\n        uTolerance: number;\n    };\n\n    private _replacements: Array<[ColorSource, ColorSource]> = [];\n    private _maxColors: number;\n\n    /**\n     * @param options - Options for the MultiColorReplaceFilter constructor.\n     */\n    constructor(options?: MultiColorReplaceFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {Array<Array>} replacements - The collection of replacement items. Each item is color-pair\n     *        (an array length is 2). In the pair, the first value is original color , the second value\n     *        is target color.\n     * @param {number} [epsilon=0.05] - Tolerance of the floating-point comparison between colors\n     *        (lower = more exact, higher = more inclusive)\n     * @param {number} [maxColors] - The maximum number of replacements filter is able to use. Because the\n     *        fragment is only compiled once, this cannot be changed after construction.\n     *        If omitted, the default value is the length of `replacements`.\n     */\n    constructor(replacements: Array<[DeprecatedColor, DeprecatedColor]>, epsilon?: number, maxColors?: number);\n    /** @ignore */\n    constructor(...args: [MultiColorReplaceFilterOptions?] | [Array<[DeprecatedColor, DeprecatedColor]>, number?, number?])\n    {\n        let options = args[0] ?? {} as MultiColorReplaceFilterOptions;\n\n        if (Array.isArray(options))\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'MultiColorReplaceFilter constructor params are now options object. See params: { replacements, tolerance, maxColors }');\n\n            options = { replacements: options };\n\n            if (args[1]) options.tolerance = args[1];\n            if (args[2]) options.maxColors = args[2];\n        }\n\n        options = { ...MultiColorReplaceFilter.DEFAULT_OPTIONS, ...options };\n\n        const maxColors = options.maxColors ?? options.replacements.length;\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source: source.replace(/\\$\\{MAX_COLORS\\}/g, (maxColors).toFixed(0)),\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment: fragment.replace(/\\$\\{MAX_COLORS\\}/g, (maxColors).toFixed(0)),\n            name: 'multi-color-replace-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                multiColorReplaceUniforms: {\n                    uOriginalColors: {\n                        value: new Float32Array(3 * maxColors),\n                        type: 'vec3<f32>',\n                        size: maxColors\n                    },\n                    uTargetColors: {\n                        value: new Float32Array(3 * maxColors),\n                        type: 'vec3<f32>',\n                        size: maxColors\n                    },\n                    uTolerance: { value: options.tolerance, type: 'f32' },\n                }\n            },\n        });\n\n        this._maxColors = maxColors;\n\n        this.uniforms = this.resources.multiColorReplaceUniforms.uniforms;\n\n        this.replacements = options.replacements;\n    }\n\n    /**\n     * The collection of replacement items. Each item is color-pair\n     * (an array length is 2). In the pair, the first value is original color , the second value is target color\n     */\n    set replacements(replacements: Array<[ColorSource, ColorSource]>)\n    {\n        const originals = this.uniforms.uOriginalColors;\n        const targets = this.uniforms.uTargetColors;\n        const colorCount = replacements.length;\n        const color = new Color();\n\n        if (colorCount > this._maxColors)\n        {\n            throw new Error(`Length of replacements (${colorCount}) exceeds the maximum colors length (${this._maxColors})`);\n        }\n\n        // Fill with negative values\n        originals[colorCount * 3] = -1;\n\n        let r;\n        let g;\n        let b;\n\n        for (let i = 0; i < colorCount; i++)\n        {\n            const pair = replacements[i];\n\n            // for original colors\n            color.setValue(pair[0]);\n\n            [r, g, b] = color.toArray();\n\n            originals[i * 3] = r;\n            originals[(i * 3) + 1] = g;\n            originals[(i * 3) + 2] = b;\n\n            // for target colors\n            color.setValue(pair[1]);\n\n            [r, g, b] = color.toArray();\n\n            targets[i * 3] = r;\n            targets[(i * 3) + 1] = g;\n            targets[(i * 3) + 2] = b;\n        }\n\n        this._replacements = replacements;\n    }\n\n    get replacements(): Array<[ColorSource, ColorSource]>\n    {\n        return this._replacements;\n    }\n\n    /**\n      * Should be called after changing any of the contents of the replacements.\n      * This is a convenience method for resetting the `replacements`.\n      * @todo implement nested proxy to remove the need for this function\n      */\n    refresh(): void\n    {\n        this.replacements = this._replacements;\n    }\n\n    /**\n      * The maximum number of color replacements supported by this filter. Can be changed\n      * _only_ during construction.\n      * @readonly\n      */\n    get maxColors(): number { return this._maxColors; }\n\n    /**\n      * Tolerance of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n      * @default 0.05\n      */\n    get tolerance(): number { return this.uniforms.uTolerance; }\n    set tolerance(value: number) { this.uniforms.uTolerance = value; }\n\n    /**\n     * @deprecated since 6.0.0\n     *\n     * Tolerance of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n     * @default 0.05\n     */\n    set epsilon(value: number)\n    {\n        // eslint-disable-next-line max-len\n        deprecation('6.0.0', 'MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead');\n        this.tolerance = value;\n    }\n    get epsilon(): number\n    {\n        // eslint-disable-next-line max-len\n        deprecation('6.0.0', 'MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead');\n\n        return this.tolerance;\n    }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uSepia;\\nuniform vec2 uNoise;\\nuniform vec3 uScratch;\\nuniform vec3 uVignetting;\\nuniform float uSeed;\\nuniform vec2 uDimensions;\\n\\nuniform vec4 uInputSize;\\n\\nconst float SQRT_2 = 1.414213;\\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\\n\\nfloat rand(vec2 co) {\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvec3 Overlay(vec3 src, vec3 dst)\\n{\\n    // if (dst <= 0.5) then: 2 * src * dst\\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\\n}\\n\\n\\nvoid main()\\n{\\n    finalColor = texture(uTexture, vTextureCoord);\\n    vec3 color = finalColor.rgb;\\n\\n    if (uSepia > 0.0)\\n    {\\n        float gray = (color.x + color.y + color.z) / 3.0;\\n        vec3 grayscale = vec3(gray);\\n\\n        color = Overlay(SEPIA_RGB, grayscale);\\n\\n        color = grayscale + uSepia * (color - grayscale);\\n    }\\n\\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions.xy;\\n\\n    float vignette = uVignetting[0];\\n    float vignetteAlpha = uVignetting[1];\\n    float vignetteBlur = uVignetting[2];\\n\\n    if (vignette > 0.0)\\n    {\\n        float outter = SQRT_2 - vignette * SQRT_2;\\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\\n        dir.y *= uDimensions.y / uDimensions.x;\\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignetteBlur * SQRT_2), 0.0, 1.0);\\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignetteAlpha);\\n    }\\n\\n    float scratch = uScratch[0];\\n    float scratchDensity = uScratch[1];\\n    float scratchWidth = uScratch[2];\\n\\n    if (scratchDensity > uSeed && scratch != 0.0)\\n    {\\n        float phase = uSeed * 256.0;\\n        float s = mod(floor(phase), 2.0);\\n        float dist = 1.0 / scratchDensity;\\n        float d = distance(coord, vec2(uSeed * dist, abs(s - uSeed * dist)));\\n        if (d < uSeed * 0.6 + 0.4)\\n        {\\n            highp float period = scratchDensity * 10.0;\\n\\n            float xx = coord.x * period + phase;\\n            float aa = abs(mod(xx, 0.5) * 4.0);\\n            float bb = mod(floor(xx / 0.5), 2.0);\\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\\n\\n            float kk = 2.0 * period;\\n            float dw = scratchWidth / uDimensions.x * (0.75 + uSeed);\\n            float dh = dw * kk;\\n\\n            float tine = (yy - (2.0 - dh));\\n\\n            if (tine > 0.0) {\\n                float _sign = sign(scratch);\\n\\n                tine = s * tine / period + scratch + 0.1;\\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\\n\\n                color.rgb *= tine;\\n            }\\n        }\\n    }\\n\\n    float noise = uNoise[0];\\n    float noiseSize = uNoise[1];\\n\\n    if (noise > 0.0 && noiseSize > 0.0)\\n    {\\n        vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;\\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + uSeed * 512.0, 1024.0 - uSeed * 512.0);\\n        // float _noise = snoise(d) * 0.5;\\n        float _noise = rand(pixelCoord * noiseSize * uSeed) - 0.5;\\n        color += _noise * noise;\\n    }\\n\\n    finalColor.rgb = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=old-film.mjs.map\n", "var source = \"struct OldFilmUniforms {\\n    uSepia: f32,\\n    uNoise: vec2<f32>,\\n    uScratch: vec3<f32>,\\n    uVignetting: vec3<f32>,\\n    uSeed: f32,\\n    uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> oldFilmUniforms : OldFilmUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  if (oldFilmUniforms.uSepia > 0.)\\n  {\\n    color = vec4<f32>(sepia(color.rgb), color.a);\\n  }\\n\\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / oldFilmUniforms.uDimensions;\\n\\n  if (oldFilmUniforms.uVignetting[0] > 0.)\\n  {\\n    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);\\n  }\\n\\n  let uScratch = oldFilmUniforms.uScratch; \\n\\n  if (uScratch[1] > oldFilmUniforms.uSeed && uScratch[0] != 0.)\\n  {\\n    color = vec4<f32>(scratch(color.rgb, coord), color.a);\\n  }\\n\\n  let uNoise = oldFilmUniforms.uNoise;\\n\\n  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\\n  {\\n    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);\\n  }\\n\\n  return color;\\n}\\n\\nconst SQRT_2: f32 = 1.414213;\\nconst SEPIA_RGB: vec3<f32> = vec3<f32>(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\\n\\nfn rand(co: vec2<f32>) -> f32\\n{\\n  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nfn overlay(src: vec3<f32>, dst: vec3<f32>) -> vec3<f32>\\n{\\n    // if (dst <= 0.5) then: 2 * src * dst\\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\\n\\n    return vec3<f32>(\\n      select((1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (2.0 * src.x * dst.x), (dst.x <= 0.5)), \\n      select((1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (2.0 * src.y * dst.y), (dst.y <= 0.5)),\\n      select((1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)), (2.0 * src.z * dst.z), (dst.z <= 0.5))\\n    );\\n}\\n\\nfn sepia(co: vec3<f32>) -> vec3<f32>\\n{\\n  let gray: f32 = (co.x + co.y + co.z) / 3.0;\\n  let grayscale: vec3<f32> = vec3<f32>(gray);\\n  let color = overlay(SEPIA_RGB, grayscale);\\n  return grayscale + oldFilmUniforms.uSepia * (color - grayscale);\\n}\\n\\nfn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32\\n{\\n  let uVignetting = oldFilmUniforms.uVignetting;\\n  let uDimensions = oldFilmUniforms.uDimensions;\\n  \\n  let outter: f32 = SQRT_2 - uVignetting[0] * SQRT_2;\\n  var dir: vec2<f32> = vec2<f32>(vec2<f32>(0.5) - coord);\\n  dir.y *= uDimensions.y / uDimensions.x;\\n  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignetting[2] * SQRT_2), 0.0, 1.0);\\n  return darker + (1.0 - darker) * (1.0 - uVignetting[1]);\\n}\\n\\nfn scratch(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>\\n{\\n  var color = co;\\n  let uScratch = oldFilmUniforms.uScratch;\\n  let uSeed = oldFilmUniforms.uSeed;\\n  let uDimensions = oldFilmUniforms.uDimensions;\\n\\n  let phase: f32 = uSeed * 256.0;\\n  let s: f32 = modulo(floor(phase), 2.0);\\n  let dist: f32 = 1.0 / uScratch[1];\\n  let d: f32 = distance(coord, vec2<f32>(uSeed * dist, abs(s - uSeed * dist)));\\n\\n  if (d < uSeed * 0.6 + 0.4)\\n  {\\n    let period: f32 = uScratch[1] * 10.0;\\n\\n    let xx: f32 = coord.x * period + phase;\\n    let aa: f32 = abs(modulo(xx, 0.5) * 4.0);\\n    let bb: f32 = modulo(floor(xx / 0.5), 2.0);\\n    let yy: f32 = (1.0 - bb) * aa + bb * (2.0 - aa);\\n\\n    let kk: f32 = 2.0 * period;\\n    let dw: f32 = uScratch[2] / uDimensions.x * (0.75 + uSeed);\\n    let dh: f32 = dw * kk;\\n\\n    var tine: f32 = (yy - (2.0 - dh));\\n\\n    if (tine > 0.0) {\\n        let _sign: f32 = sign(uScratch[0]);\\n\\n        tine = s * tine / period + uScratch[0] + 0.1;\\n        tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\\n\\n        color *= tine;\\n    }\\n  }\\n\\n  return color;\\n}\\n\\nfn noise(coord: vec2<f32>) -> f32\\n{\\n  let uNoise = oldFilmUniforms.uNoise;\\n  let uSeed = oldFilmUniforms.uSeed;\\n\\n  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;\\n  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\\n  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\\n  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=old-film2.mjs.map\n", "import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './old-film.frag';\nimport source from './old-film.wgsl';\n\nimport type { FilterSystem, RenderSurface, Texture } from 'pixi.js';\n\n/** Options for the OldFilmFilter constructor. */\nexport interface OldFilmFilterOptions\n{\n    /**\n     * The amount of saturation of sepia effect,\n     * a value of `1` is more saturation and closer to `0` is less, and a value of `0` produces no sepia effect\n     * @default 0.3\n     */\n    sepia?: number;\n    /**\n     * Opacity/intensity of the noise effect between `0` and `1`\n     * @default 0.3\n     */\n    noise?: number;\n    /**\n     * The size of the noise particles\n     * @default 1\n     */\n    noiseSize?: number;\n    /**\n     * How often scratches appear\n     * @default 0.5\n     */\n    scratch?: number;\n    /**\n     * The density of the number of scratches\n     * @default 0.3\n     */\n    scratchDensity?: number;\n    /**\n     * The width of the scratches\n     * @default 1\n     */\n    scratchWidth?: number;\n    /**\n     * The radius of the vignette effect, smaller values produces a smaller vignette\n     * @default 0.3\n     */\n    vignetting?: number;\n    /**\n     * Amount of opacity on the vignette\n     * @default 1\n     */\n    vignettingAlpha?: number;\n    /**\n     * Blur intensity of the vignette\n     * @default 1\n     */\n    vignettingBlur?: number;\n    /**\n     * A seed value to apply to the random noise generation\n     * @default 0\n     */\n    seed?: number;\n}\n\n/**\n * The OldFilmFilter applies a Old film effect to an object.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/old-film.gif)\n *\n * @class\n * @extends Filter\n */\nexport class OldFilmFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: OldFilmFilterOptions = {\n        sepia: 0.3,\n        noise: 0.3,\n        noiseSize: 1,\n        scratch: 0.5,\n        scratchDensity: 0.3,\n        scratchWidth: 1,\n        vignetting: 0.3,\n        vignettingAlpha: 1,\n        vignettingBlur: 0.3,\n        seed: 0\n    };\n\n    public uniforms: {\n        uSepia: number;\n        uNoise: Float32Array;\n        uScratch: Float32Array;\n        uVignetting: Float32Array;\n        uSeed: number;\n        uDimensions: Float32Array;\n    };\n\n    /**\n     * A seed value to apply to the random noise generation\n     * @default 0\n     */\n    public seed!: number;\n\n    /**\n     * @param options - Options for the OldFilmFilter constructor.\n     */\n    constructor(options?: OldFilmFilterOptions)\n    {\n        options = { ...OldFilmFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'old-film-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                oldFilmUniforms: {\n                    uSepia: { value: options.sepia, type: 'f32' },\n                    uNoise: { value: new Float32Array(2), type: 'vec2<f32>' },\n                    uScratch: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uVignetting: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uSeed: { value: options.seed, type: 'f32' },\n                    uDimensions: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.oldFilmUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        this.uniforms.uDimensions[0] = input.frame.width;\n        this.uniforms.uDimensions[1] = input.frame.height;\n        this.uniforms.uSeed = this.seed;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * The amount of saturation of sepia effect,\n     * a value of `1` is more saturation and closer to `0` is less, and a value of `0` produces no sepia effect\n     * @default 0.3\n     */\n    get sepia(): number { return this.uniforms.uSepia; }\n    set sepia(value: number) { this.uniforms.uSepia = value; }\n\n    /**\n     * Opacity/intensity of the noise effect between `0` and `1`\n     * @default 0.3\n     */\n    get noise(): number { return this.uniforms.uNoise[0]; }\n    set noise(value: number) { this.uniforms.uNoise[0] = value; }\n\n    /**\n     * The size of the noise particles\n     * @default 1\n     */\n    get noiseSize(): number { return this.uniforms.uNoise[1]; }\n    set noiseSize(value: number) { this.uniforms.uNoise[1] = value; }\n\n    /**\n     * How often scratches appear\n     * @default 0.5\n     */\n    get scratch(): number { return this.uniforms.uScratch[0]; }\n    set scratch(value: number) { this.uniforms.uScratch[0] = value; }\n\n    /**\n     * The density of the number of scratches\n     * @default 0.3\n     */\n    get scratchDensity(): number { return this.uniforms.uScratch[1]; }\n    set scratchDensity(value: number) { this.uniforms.uScratch[1] = value; }\n\n    /**\n     * The width of the scratches\n     * @default 1\n     */\n    get scratchWidth(): number { return this.uniforms.uScratch[2]; }\n    set scratchWidth(value: number) { this.uniforms.uScratch[2] = value; }\n\n    /**\n     * The radius of the vignette effect, smaller values produces a smaller vignette\n     * @default 0.3\n     */\n    get vignetting(): number { return this.uniforms.uVignetting[0]; }\n    set vignetting(value: number) { this.uniforms.uVignetting[0] = value; }\n\n    /**\n     * Amount of opacity on the vignette\n     * @default 1\n     */\n    get vignettingAlpha(): number { return this.uniforms.uVignetting[1]; }\n    set vignettingAlpha(value: number) { this.uniforms.uVignetting[1] = value; }\n\n    /**\n     * Blur intensity of the vignette\n     * @default 1\n     */\n    get vignettingBlur(): number { return this.uniforms.uVignetting[2]; }\n    set vignettingBlur(value: number) { this.uniforms.uVignetting[2] = value; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uThickness;\\nuniform vec3 uColor;\\nuniform float uAlpha;\\nuniform float uKnockout;\\n\\nuniform vec4 uInputClamp;\\n\\nconst float DOUBLE_PI = 2. * 3.14159265358979323846264;\\nconst float ANGLE_STEP = ${ANGLE_STEP};\\n\\nfloat outlineMaxAlphaAtPos(vec2 pos) {\\n    if (uThickness.x == 0. || uThickness.y == 0.) {\\n        return 0.;\\n    }\\n\\n    vec4 displacedColor;\\n    vec2 displacedPos;\\n    float maxAlpha = 0.;\\n\\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ANGLE_STEP) {\\n        displacedPos.x = vTextureCoord.x + uThickness.x * cos(angle);\\n        displacedPos.y = vTextureCoord.y + uThickness.y * sin(angle);\\n        displacedColor = texture(uTexture, clamp(displacedPos, uInputClamp.xy, uInputClamp.zw));\\n        maxAlpha = max(maxAlpha, displacedColor.a);\\n    }\\n\\n    return maxAlpha;\\n}\\n\\nvoid main(void) {\\n    vec4 sourceColor = texture(uTexture, vTextureCoord);\\n    vec4 contentColor = sourceColor * float(uKnockout < 0.5);\\n    float outlineAlpha = uAlpha * outlineMaxAlphaAtPos(vTextureCoord.xy) * (1.-sourceColor.a);\\n    vec4 outlineColor = vec4(vec3(uColor) * outlineAlpha, outlineAlpha);\\n    finalColor = contentColor + outlineColor;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=outline.mjs.map\n", "var source = \"struct OutlineUniforms {\\n  uThickness:vec2<f32>,\\n  uColor:vec3<f32>,\\n  uAlpha:f32,\\n  uAngleStep:f32,\\n  uKnockout:f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> outlineUniforms : OutlineUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let sourceColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let contentColor: vec4<f32> = sourceColor * (1. - outlineUniforms.uKnockout);\\n  \\n  let outlineAlpha: f32 = outlineUniforms.uAlpha * outlineMaxAlphaAtPos(uv) * (1. - sourceColor.a);\\n  let outlineColor: vec4<f32> = vec4<f32>(vec3<f32>(outlineUniforms.uColor) * outlineAlpha, outlineAlpha);\\n  \\n  return contentColor + outlineColor;\\n}\\n\\nfn outlineMaxAlphaAtPos(uv: vec2<f32>) -> f32 {\\n  let thickness = outlineUniforms.uThickness;\\n\\n  if (thickness.x == 0. || thickness.y == 0.) {\\n    return 0.;\\n  }\\n  \\n  let angleStep = outlineUniforms.uAngleStep;\\n\\n  var displacedColor: vec4<f32>;\\n  var displacedPos: vec2<f32>;\\n\\n  var maxAlpha: f32 = 0.;\\n  var displaced: vec2<f32>;\\n  var curColor: vec4<f32>;\\n\\n  for (var angle = 0.; angle <= DOUBLE_PI; angle += angleStep)\\n  {\\n    displaced.x = uv.x + thickness.x * cos(angle);\\n    displaced.y = uv.y + thickness.y * sin(angle);\\n    curColor = textureSample(uTexture, uSampler, clamp(displaced, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n    maxAlpha = max(maxAlpha, curColor.a);\\n  }\\n\\n  return maxAlpha;\\n}\\n\\nconst DOUBLE_PI: f32 = 3.14159265358979323846264 * 2.;\";\n\nexport { source as default };\n//# sourceMappingURL=outline2.mjs.map\n", "import { Color, deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './outline.frag';\nimport source from './outline.wgsl';\n\nimport type { ColorSource, FilterSystem, RenderSurface, Texture } from 'pixi.js';\n\n/** Options for the OutlineFilter constructor. */\nexport interface OutlineFilterOptions\n{\n    /**\n     * The thickness of the outline\n     * @default 1\n     */\n    thickness?: number;\n    /**\n     * The color of the outline\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0x000000\n     */\n    color?: ColorSource;\n    /**\n     * The alpha of the outline\n     * @default 1\n     */\n    alpha?: number;\n    /**\n     * The quality of the outline from `0` to `1`.\n     * Using a higher quality setting will result in more accuracy but slower performance\n     * @default 0.1\n     */\n    quality?: number;\n    /**\n     * Whether to only render outline, not the contents.\n     * @default false\n     */\n    knockout?: boolean;\n}\n\n/**\n * OutlineFilter, originally by mishaa\n * http://www.html5gamedevs.com/topic/10640-outline-a-sprite-change-certain-colors/?p=69966\n * http://codepen.io/mishaa/pen/emGNRB<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/outline.png)\n *\n * @class\n * @extends Filter *\n * @example\n *  someSprite.filters = [new OutlineFilter(2, 0x99ff99)];\n */\nexport class OutlineFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: OutlineFilterOptions = {\n        thickness: 1,\n        color: 0x000000,\n        alpha: 1,\n        quality: 0.1,\n        knockout: false,\n    };\n\n    /** The minimum number of samples for rendering outline. */\n    public static MIN_SAMPLES = 1;\n\n    /** The maximum number of samples for rendering outline. */\n    public static MAX_SAMPLES = 100;\n\n    public uniforms: {\n        uThickness: Float32Array,\n        uColor: Float32Array,\n        uAlpha: number;\n        uAngleStep: number,\n        uKnockout: number,\n    };\n\n    private _thickness!: number;\n    private _quality!: number;\n    private _color!: Color;\n\n    /**\n     * @param options - Options for the OutlineFilter constructor.\n     */\n    constructor(options?: OutlineFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number} [thickness=1] - The tickness of the outline. Make it 2 times more for resolution 2\n     * @param {number} [color=0x000000] - The color of the outline.\n     * @param {number} [quality=0.1] - The quality of the outline from `0` to `1`, using a higher quality\n     *        setting will result in slower performance and more accuracy.\n     * @param {number} [alpha=1.0] - The alpha of the outline.\n     * @param {boolean} [knockout=false] - Only render outline, not the contents.\n     */\n    constructor(thickness?: number, color?: number, quality?: number, alpha?: number, knockout?: boolean);\n    /** @ignore */\n    constructor(...args: [OutlineFilterOptions?] | [number?, number?, number?, number?, boolean?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'OutlineFilter constructor params are now options object. See params: { thickness, color, quality, alpha, knockout }');\n\n            options = { thickness: options };\n\n            if (args[1] !== undefined) options.color = args[1];\n            if (args[2] !== undefined) options.quality = args[2];\n            if (args[3] !== undefined) options.alpha = args[3];\n            if (args[4] !== undefined) options.knockout = args[4];\n        }\n\n        options = { ...OutlineFilter.DEFAULT_OPTIONS, ...options };\n\n        const quality = options.quality ?? 0.1;\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment: fragment.replace(/\\$\\{ANGLE_STEP\\}/, OutlineFilter.getAngleStep(quality).toFixed(7)),\n            name: 'outline-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                outlineUniforms: {\n                    uThickness: { value: new Float32Array(2), type: 'vec2<f32>' },\n                    uColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uAlpha: { value: options.alpha, type: 'f32' },\n                    uAngleStep: { value: 0, type: 'f32' },\n                    uKnockout: { value: options.knockout ? 1 : 0, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.outlineUniforms.uniforms;\n        this.uniforms.uAngleStep = OutlineFilter.getAngleStep(quality);\n        this._color = new Color();\n        this.color = options.color ?? 0x000000;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        this.uniforms.uThickness[0] = this.thickness / input.source.width;\n        this.uniforms.uThickness[1] = this.thickness / input.source.height;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Get the angleStep by quality\n     * @param quality\n     */\n    private static getAngleStep(quality: number): number\n    {\n        return parseFloat(((Math.PI * 2) / Math.max(\n            quality * OutlineFilter.MAX_SAMPLES,\n            OutlineFilter.MIN_SAMPLES,\n        )).toFixed(7));\n    }\n\n    /**\n     * The thickness of the outline\n     * @default 1\n     */\n    get thickness(): number { return this._thickness; }\n    set thickness(value: number) { this._thickness = this.padding = value; }\n\n    /**\n     * The color value of the ambient color\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0x000000\n     */\n    get color(): ColorSource { return this._color.value as ColorSource; }\n    set color(value: ColorSource)\n    {\n        this._color.setValue(value);\n        const [r, g, b] = this._color.toArray();\n\n        this.uniforms.uColor[0] = r;\n        this.uniforms.uColor[1] = g;\n        this.uniforms.uColor[2] = b;\n    }\n\n    /**\n     * Coefficient for alpha multiplication\n     * @default 1\n     */\n    get alpha(): number { return this.uniforms.uAlpha; }\n    set alpha(value: number) { this.uniforms.uAlpha = value; }\n\n    /**\n     * The quality of the outline from `0` to `1`.\n     * Using a higher quality setting will result in more accuracy but slower performance\n     * @default 0.1\n     */\n    get quality(): number { return this._quality; }\n    set quality(value: number)\n    {\n        this._quality = value;\n        this.uniforms.uAngleStep = OutlineFilter.getAngleStep(value);\n    }\n\n    /**\n     * Whether to only render outline, not the contents.\n     * @default false\n     */\n    get knockout(): boolean { return this.uniforms.uKnockout === 1; }\n    set knockout(value: boolean) { this.uniforms.uKnockout = value ? 1 : 0; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform vec2 uSize;\\nuniform sampler2D uTexture;\\nuniform vec4 uInputSize;\\n\\nvec2 mapCoord( vec2 coord )\\n{\\n    coord *= uInputSize.xy;\\n    coord += uInputSize.zw;\\n\\n    return coord;\\n}\\n\\nvec2 unmapCoord( vec2 coord )\\n{\\n    coord -= uInputSize.zw;\\n    coord /= uInputSize.xy;\\n\\n    return coord;\\n}\\n\\nvec2 pixelate(vec2 coord, vec2 uSize)\\n{\\n\\treturn floor( coord / uSize ) * uSize;\\n}\\n\\nvoid main(void)\\n{\\n    vec2 coord = mapCoord(vTextureCoord);\\n    coord = pixelate(coord, uSize);\\n    coord = unmapCoord(coord);\\n    finalColor = texture(uTexture, coord);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=pixelate2.mjs.map\n", "var source = \"struct PixelateUniforms {\\n  uSize:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> pixelateUniforms : PixelateUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  let pixelSize: vec2<f32> = pixelateUniforms.uSize;\\n  let coord: vec2<f32> = mapCoord(uv);\\n\\n  var pixCoord: vec2<f32> = pixelate(coord, pixelSize);\\n  pixCoord = unmapCoord(pixCoord);\\n\\n  return textureSample(uTexture, uSampler, pixCoord);\\n}\\n\\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n  var mappedCoord: vec2<f32> = coord;\\n  mappedCoord *= gfu.uInputSize.xy;\\n  mappedCoord += gfu.uOutputFrame.xy;\\n  return mappedCoord;\\n}\\n\\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n  var mappedCoord: vec2<f32> = coord;\\n  mappedCoord -= gfu.uOutputFrame.xy;\\n  mappedCoord /= gfu.uInputSize.xy;\\n  return mappedCoord;\\n}\\n\\nfn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\\n{\\n  return floor( coord / size ) * size;\\n}\\n\\n\";\n\nexport { source as default };\n//# sourceMappingURL=pixelate.mjs.map\n", "import { Filter, GlProgram, GpuProgram, Point } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './pixelate.frag';\nimport source from './pixelate.wgsl';\n\ntype Size = number | number[] | Point;\n\n/**\n * This filter applies a pixelate effect making display objects appear 'blocky'.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/pixelate.png)\n *\n * @class\n * @extends Filter\n */\nexport class PixelateFilter extends Filter\n{\n    /**\n     * @param {Point|Array<number>|number} [size=10] - Either the width/height of the size of the pixels, or square size\n     */\n    constructor(size: Size = 10)\n    {\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'pixelate-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                pixelateUniforms: {\n                    uSize: { value: new Float32Array(2), type: 'vec2<f32>' },\n                },\n            },\n        });\n\n        this.size = size;\n    }\n\n    /**\n     * The size of the pixels\n     * @default [10,10]\n     */\n    get size(): Size { return this.resources.pixelateUniforms.uniforms.uSize; }\n    set size(value: Size)\n    {\n        if (value instanceof Point)\n        {\n            this.sizeX = value.x;\n            this.sizeY = value.y;\n        }\n        else if (Array.isArray(value))\n        {\n            this.resources.pixelateUniforms.uniforms.uSize = value;\n        }\n        else\n        {\n            this.sizeX = this.sizeY = value;\n        }\n    }\n\n    /**\n    * The size of the pixels on the `x` axis\n    * @default 10\n    */\n    get sizeX(): number { return this.resources.pixelateUniforms.uniforms.uSize[0]; }\n    set sizeX(value: number) { this.resources.pixelateUniforms.uniforms.uSize[0] = value; }\n\n    /**\n    * The size of the pixels on the `y` axis\n    * @default 10\n    */\n    get sizeY(): number { return this.resources.pixelateUniforms.uniforms.uSize[1]; }\n    set sizeY(value: number) { this.resources.pixelateUniforms.uniforms.uSize[1] = value; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uRadian;\\nuniform vec2 uCenter;\\nuniform float uRadius;\\nuniform int uKernelSize;\\n\\nuniform vec4 uInputSize;\\n\\nconst int MAX_KERNEL_SIZE = 2048;\\n\\nvoid main(void)\\n{\\n    vec4 color = texture(uTexture, vTextureCoord);\\n\\n    if (uKernelSize == 0)\\n    {\\n        finalColor = color;\\n        return;\\n    }\\n\\n    float aspect = uInputSize.y / uInputSize.x;\\n    vec2 center = uCenter.xy / uInputSize.xy;\\n    float gradient = uRadius / uInputSize.x * 0.3;\\n    float radius = uRadius / uInputSize.x - gradient * 0.5;\\n    int k = uKernelSize - 1;\\n\\n    vec2 coord = vTextureCoord;\\n    vec2 dir = vec2(center - coord);\\n    float dist = length(vec2(dir.x, dir.y * aspect));\\n\\n    float radianStep = uRadian;\\n    if (radius >= 0.0 && dist > radius) {\\n        float delta = dist - radius;\\n        float gap = gradient;\\n        float scale = 1.0 - abs(delta / gap);\\n        if (scale <= 0.0) {\\n            finalColor = color;\\n            return;\\n        }\\n        radianStep *= scale;\\n    }\\n    radianStep /= float(k);\\n\\n    float s = sin(radianStep);\\n    float c = cos(radianStep);\\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\\n\\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\\n        if (i == k) {\\n            break;\\n        }\\n\\n        coord -= center;\\n        coord.y *= aspect;\\n        coord = rotationMatrix * coord;\\n        coord.y /= aspect;\\n        coord += center;\\n\\n        vec4 sample = texture(uTexture, coord);\\n\\n        // switch to pre-multiplied alpha to correctly blur transparent images\\n        // sample.rgb *= sample.a;\\n\\n        color += sample;\\n    }\\n\\n    finalColor = color / float(uKernelSize);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=radial-blur.mjs.map\n", "var source = \"struct RadialBlurUniforms {\\n  uRadian: f32,\\n  uCenter: vec2<f32>,\\n  uKernelSize: f32,\\n  uRadius: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> radialBlurUniforms : RadialBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uRadian = radialBlurUniforms.uRadian;\\n  let uCenter = radialBlurUniforms.uCenter;\\n  let uKernelSize = radialBlurUniforms.uKernelSize;\\n  let uRadius = radialBlurUniforms.uRadius;\\n  \\n  var returnColorOnly = false;\\n\\n  if (uKernelSize == 0)\\n  {\\n    returnColorOnly = true;\\n  }\\n\\n  let aspect: f32 = gfu.uInputSize.y / gfu.uInputSize.x;\\n  let center: vec2<f32> = uCenter.xy / gfu.uInputSize.xy;\\n  let gradient: f32 = uRadius / gfu.uInputSize.x * 0.3;\\n  let radius: f32 = uRadius / gfu.uInputSize.x - gradient * 0.5;\\n  let k: i32 = i32(uKernelSize - 1);\\n\\n  var coord: vec2<f32> = uv;\\n  let dir: vec2<f32> = vec2<f32>(center - coord);\\n  let dist: f32 = length(vec2<f32>(dir.x, dir.y * aspect));\\n\\n  var radianStep: f32 = uRadian;\\n  \\n  if (radius >= 0.0 && dist > radius)\\n  {\\n    let delta: f32 = dist - radius;\\n    let gap: f32 = gradient;\\n    let scale: f32 = 1.0 - abs(delta / gap);\\n    if (scale <= 0.0) {\\n      returnColorOnly = true;\\n    }\\n    radianStep *= scale;\\n  }\\n\\n  radianStep /= f32(k);\\n\\n  let s: f32 = sin(radianStep);\\n  let c: f32 = cos(radianStep);\\n  let rotationMatrix: mat2x2<f32> = mat2x2<f32>(vec2<f32>(c, -s), vec2<f32>(s, c));\\n  \\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let baseColor = vec4<f32>(color);\\n\\n  let minK: i32 = min(i32(uKernelSize) - 1, MAX_KERNEL_SIZE - 1);\\n\\n  for(var i: i32 = 0; i < minK; i += 1) \\n  {\\n    coord -= center;\\n    coord.y *= aspect;\\n    coord = rotationMatrix * coord;\\n    coord.y /= aspect;\\n    coord += center;\\n    let sample: vec4<f32> = textureSample(uTexture, uSampler, coord);\\n    // switch to pre-multiplied alpha to correctly blur transparent images\\n    // sample.rgb *= sample.a;\\n    color += sample;\\n  }\\n\\n  return select(color / f32(uKernelSize), baseColor, returnColorOnly);\\n}\\n\\nconst MAX_KERNEL_SIZE: i32 = 2048;\";\n\nexport { source as default };\n//# sourceMappingURL=radial-blur2.mjs.map\n", "import { deprecation, Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './radial-blur.frag';\nimport source from './radial-blur.wgsl';\n\nimport type { PointData } from 'pixi.js';\n\n/** Options for the RadialBlurFilter constructor. */\nexport interface RadialBlurFilterOptions\n{\n    /**\n     * Sets the angle of the motion for blur effect\n     * @default 0\n     */\n    angle?: number;\n    /**\n     * The `x` and `y` offset coordinates to change the position of the center of the circle of effect.\n     * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n     * once defined in the constructor\n     * @default {x:0,y:0}\n     */\n    center?: PointData | number[];\n    /**\n     * The kernelSize of the blur filter. Must be odd number >= 3\n     * @default 5\n     */\n    kernelSize?: number;\n    /**\n     * The maximum size of the blur radius, less than `0` equates to infinity\n     * @default -1\n     */\n    radius?: number\n}\n\n/**\n * The RadialBlurFilter applies a Motion blur to an object.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/radial-blur.png)\n *\n * @class\n * @extends Filter\n */\nexport class RadialBlurFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: RadialBlurFilterOptions = {\n        angle: 0,\n        center: { x: 0, y: 0 },\n        kernelSize: 5,\n        radius: -1,\n    };\n\n    public uniforms: {\n        uRadian: number;\n        uCenter: PointData;\n        uKernelSize: number;\n        uRadius: number;\n    };\n\n    private _angle!: number;\n    private _kernelSize!: number;\n\n    /**\n     * @param options - Options for the RadialBlurFilter constructor.\n     */\n    constructor(options?: RadialBlurFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number} [angle=0] - Sets the angle of the motion for blur effect.\n     * @param {PIXI.Point|number[]} [center=[0,0]] - The center of the radial.\n     * @param {number} [kernelSize=5] - The kernelSize of the blur filter. Must be odd number >= 3\n     * @param {number} [radius=-1] - The maximum size of the blur radius, `-1` is infinite\n     */\n    constructor(angle?: number, center?: PointData | number[], kernelSize?: number, radius?: number);\n    /** @ignore */\n    constructor(...args: [RadialBlurFilterOptions?] | [number?, (PointData | number[])?, number?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'RadialBlurFilter constructor params are now options object. See params: { angle, center, kernelSize, radius }');\n\n            options = { angle: options };\n\n            if (args[1])\n            {\n                const x = 'x' in args[1] ? args[1].x : args[1][0];\n                const y = 'y' in args[1] ? args[1].y : args[1][1];\n\n                options.center = { x, y };\n            }\n            if (args[2]) options.kernelSize = args[2];\n            if (args[3]) options.radius = args[3];\n        }\n\n        options = { ...RadialBlurFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'radial-blur-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                radialBlurUniforms: {\n                    uRadian: { value: 0, type: 'f32' },\n                    uCenter: { value: options.center, type: 'vec2<f32>' },\n                    uKernelSize: { value: options.kernelSize, type: 'i32' },\n                    uRadius: { value: options.radius, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.radialBlurUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    private _updateKernelSize()\n    {\n        this.uniforms.uKernelSize = this._angle !== 0 ? this.kernelSize : 0;\n    }\n\n    /**\n     * Sets the angle in degrees of the motion for blur effect.\n     * @default 0\n     */\n    get angle(): number { return this._angle; }\n    set angle(value: number)\n    {\n        this._angle = value;\n        this.uniforms.uRadian = value * Math.PI / 180;\n        this._updateKernelSize();\n    }\n\n    /**\n     * The `x` and `y` offset coordinates to change the position of the center of the circle of effect.\n     * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n     * once defined in the constructor\n     * @default {x:0,y:0}\n     */\n    get center(): PointData { return this.uniforms.uCenter; }\n    set center(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uCenter = value;\n    }\n\n    /**\n     * Sets the velocity of the motion for blur effect on the `x` axis\n     * @default 0\n     */\n    get centerX(): number { return this.center.x; }\n    set centerX(value: number) { this.center.x = value; }\n\n    /**\n     * Sets the velocity of the motion for blur effect on the `x` axis\n     * @default 0\n     */\n    get centerY(): number { return this.center.y; }\n    set centerY(value: number) { this.center.y = value; }\n\n    /**\n     * The kernelSize of the blur filter. Must be odd number >= 3\n     * @default 5\n     */\n    get kernelSize(): number { return this._kernelSize; }\n    set kernelSize(value: number)\n    {\n        this._kernelSize = value;\n        this._updateKernelSize();\n    }\n\n    /**\n     * The maximum size of the blur radius, less than `0` equates to infinity\n     * @default -1\n     */\n    get radius(): number { return this.uniforms.uRadius; }\n    set radius(value: number) { this.uniforms.uRadius = value < 0 || value === Infinity ? -1 : value; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uMirror;\\nuniform float uBoundary;\\nuniform vec2 uAmplitude;\\nuniform vec2 uWavelength;\\nuniform vec2 uAlpha;\\nuniform float uTime;\\nuniform vec2 uDimensions;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nfloat rand(vec2 co) {\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvoid main(void)\\n{\\n    vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;\\n    vec2 coord = pixelCoord / uDimensions;\\n\\n    if (coord.y < uBoundary) {\\n        finalColor = texture(uTexture, vTextureCoord);\\n        return;\\n    }\\n\\n    float k = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);\\n    float areaY = uBoundary * uDimensions.y / uInputSize.y;\\n    float v = areaY + areaY - vTextureCoord.y;\\n    float y = uMirror > 0.5 ? v : vTextureCoord.y;\\n\\n    float _amplitude = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / uInputSize.x;\\n    float _waveLength = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / uInputSize.y;\\n    float _alpha = (uAlpha.y - uAlpha.x) * k + uAlpha.x;\\n\\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - uTime) * _amplitude;\\n    x = clamp(x, uInputClamp.x, uInputClamp.z);\\n\\n    vec4 color = texture(uTexture, vec2(x, y));\\n\\n    finalColor = color * _alpha;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=reflection.mjs.map\n", "var source = \"struct ReflectionUniforms {\\n  uMirror: f32,\\n  uBoundary: f32,\\n  uAmplitude: vec2<f32>,\\n  uWavelength: vec2<f32>,\\n  uAlpha: vec2<f32>,\\n  uTime: f32,\\n  uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> reflectionUniforms : ReflectionUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uDimensions: vec2<f32> = reflectionUniforms.uDimensions;\\n  let uBoundary: f32 = reflectionUniforms.uBoundary;\\n  let uMirror: bool = reflectionUniforms.uMirror > 0.5;\\n  let uAmplitude: vec2<f32> = reflectionUniforms.uAmplitude;\\n  let uWavelength: vec2<f32> = reflectionUniforms.uWavelength;\\n  let uAlpha: vec2<f32> = reflectionUniforms.uAlpha;\\n  let uTime: f32 = reflectionUniforms.uTime;\\n\\n  let pixelCoord: vec2<f32> = uv * gfu.uInputSize.xy;\\n  let coord: vec2<f32> = pixelCoord /uDimensions;\\n  var returnColorOnly: bool = false;\\n\\n  if (coord.y < uBoundary) {\\n    returnColorOnly = true;\\n  }\\n\\n  let k: f32 = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);\\n  let areaY: f32 = uBoundary * uDimensions.y / gfu.uInputSize.y;\\n  let v: f32 = areaY + areaY - uv.y;\\n  let y: f32 = select(uv.y, v, uMirror);\\n\\n  let amplitude: f32 = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / gfu.uInputSize.x;\\n  let waveLength: f32 = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / gfu.uInputSize.y;\\n  let alpha: f32 = select((uAlpha.y - uAlpha.x) * k + uAlpha.x, 1., returnColorOnly);\\n\\n  var x: f32 = uv.x + cos(v * 6.28 / waveLength - uTime) * amplitude;\\n  x = clamp(x, gfu.uInputClamp.x, gfu.uInputClamp.z);\\n  \\n  return textureSample(uTexture, uSampler, select(vec2<f32>(x, y), uv, returnColorOnly)) * alpha;\\n}\\n\\nfn rand(co: vec2<f32>) -> f32 \\n{\\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=reflection2.mjs.map\n", "import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './reflection.frag';\nimport source from './reflection.wgsl';\n\nimport type { FilterSystem, RenderSurface, Texture } from 'pixi.js';\n\n/** [MIN, MAX] */\ntype Range = [number, number] | Float32Array;\n\n/** Options for the ReflectionFilter constructor. */\nexport interface ReflectionFilterOptions\n{\n    /**\n     * `true` to reflect the image, `false` for waves-only\n     * @default true\n     */\n    mirror?: boolean;\n    /**\n     * Vertical position of the reflection point, `0.5` equates to the middle\n     * smaller numbers produce a larger reflection, larger numbers produce a smaller reflection\n     * @default 0.5\n     */\n    boundary?: number;\n    /**\n     * Starting and ending amplitude of waves\n     * @default [0,20]\n     */\n    amplitude?: Range;\n    /**\n     * Starting and ending length of waves\n     * @default [30,100]\n     */\n    waveLength?: Range;\n    /**\n     * Starting and ending alpha values\n     * @default [1,1]\n     */\n    alpha?: Range;\n    /**\n     * Time for animating position of waves\n     * @default 0\n     */\n    time?: number;\n}\n\n/**\n * Applies a reflection effect to simulate the reflection on water with waves.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/reflection.png)\n *\n * @class\n * @extends Filter\n */\nexport class ReflectionFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: ReflectionFilterOptions = {\n        mirror: true,\n        boundary: 0.5,\n        amplitude: [0, 20],\n        waveLength: [30, 100],\n        alpha: [1, 1],\n        time: 0,\n    };\n\n    public uniforms: {\n        uMirror: number;\n        uBoundary: number;\n        uAmplitude: Float32Array;\n        uWavelength: Float32Array;\n        uAlpha: Float32Array;\n        uTime: number;\n        uDimensions: Float32Array;\n    };\n\n    /**\n     * Time for animating position of waves\n     * @default 0\n     */\n    public time = 0;\n\n    /**\n     * @param options - Options for the ReflectionFilter constructor.\n     */\n    constructor(options?: ReflectionFilterOptions)\n    {\n        options = { ...ReflectionFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'reflection-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                reflectionUniforms: {\n                    uMirror: { value: options.mirror ? 1 : 0, type: 'f32' },\n                    uBoundary: { value: options.boundary, type: 'f32' },\n                    uAmplitude: { value: options.amplitude, type: 'vec2<f32>' },\n                    uWavelength: { value: options.waveLength, type: 'vec2<f32>' },\n                    uAlpha: { value: options.alpha, type: 'vec2<f32>' },\n                    uTime: { value: options.time, type: 'f32' },\n                    uDimensions: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.reflectionUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        this.uniforms.uDimensions[0] = input.frame.width;\n        this.uniforms.uDimensions[1] = input.frame.height;\n\n        this.uniforms.uTime = this.time;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * `true` to reflect the image, `false` for waves-only\n     * @default true\n     */\n    get mirror(): boolean { return this.uniforms.uMirror > 0.5; }\n    set mirror(value: boolean) { this.uniforms.uMirror = value ? 1 : 0; }\n\n    /**\n     * Vertical position of the reflection point, default is 50% (middle)\n     * smaller numbers produce a larger reflection, larger numbers produce a smaller reflection.\n     * @default 0.5\n     */\n    get boundary(): number { return this.uniforms.uBoundary; }\n    set boundary(value: number) { this.uniforms.uBoundary = value; }\n\n    /**\n     * Starting and ending amplitude of waves\n     * @default [0,20]\n     */\n    get amplitude(): Range { return Array.from(this.uniforms.uAmplitude) as Range; }\n    set amplitude(value: Range)\n    {\n        this.uniforms.uAmplitude[0] = value[0];\n        this.uniforms.uAmplitude[1] = value[1];\n    }\n\n    /**\n     * Starting amplitude of waves\n     * @default 0\n     */\n    get amplitudeStart(): number { return this.uniforms.uAmplitude[0]; }\n    set amplitudeStart(value: number) { this.uniforms.uAmplitude[0] = value; }\n\n    /**\n     * Starting amplitude of waves\n     * @default 20\n     */\n    get amplitudeEnd(): number { return this.uniforms.uAmplitude[1]; }\n    set amplitudeEnd(value: number) { this.uniforms.uAmplitude[1] = value; }\n\n    /**\n     * Starting and ending length of waves\n     * @default [30,100]\n     */\n    get waveLength(): Range { return Array.from(this.uniforms.uWavelength) as Range; }\n    set waveLength(value: Range)\n    {\n        this.uniforms.uWavelength[0] = value[0];\n        this.uniforms.uWavelength[1] = value[1];\n    }\n\n    /**\n     * Starting wavelength of waves\n     * @default 30\n     */\n    get wavelengthStart(): number { return this.uniforms.uWavelength[0]; }\n    set wavelengthStart(value: number) { this.uniforms.uWavelength[0] = value; }\n\n    /**\n     * Starting wavelength of waves\n     * @default 100\n     */\n    get wavelengthEnd(): number { return this.uniforms.uWavelength[1]; }\n    set wavelengthEnd(value: number) { this.uniforms.uWavelength[1] = value; }\n\n    /**\n     * Starting and ending alpha values\n     * @default [1,1]\n     */\n    get alpha(): Range { return Array.from(this.uniforms.uAlpha) as Range; }\n    set alpha(value: Range)\n    {\n        this.uniforms.uAlpha[0] = value[0];\n        this.uniforms.uAlpha[1] = value[1];\n    }\n\n    /**\n     * Starting wavelength of waves\n     * @default 1\n     */\n    get alphaStart(): number { return this.uniforms.uAlpha[0]; }\n    set alphaStart(value: number) { this.uniforms.uAlpha[0] = value; }\n\n    /**\n     * Starting wavelength of waves\n     * @default 1\n     */\n    get alphaEnd(): number { return this.uniforms.uAlpha[1]; }\n    set alphaEnd(value: number) { this.uniforms.uAlpha[1] = value; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec4 uInputSize;\\nuniform vec2 uRed;\\nuniform vec2 uGreen;\\nuniform vec2 uBlue;\\n\\nvoid main(void)\\n{\\n   float r = texture(uTexture, vTextureCoord + uRed/uInputSize.xy).r;\\n   float g = texture(uTexture, vTextureCoord + uGreen/uInputSize.xy).g;\\n   float b = texture(uTexture, vTextureCoord + uBlue/uInputSize.xy).b;\\n   float a = texture(uTexture, vTextureCoord).a;\\n   finalColor = vec4(r, g, b, a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=rgb-split2.mjs.map\n", "var source = \"struct RgbSplitUniforms {\\n    uRed: vec2<f32>,\\n    uGreen: vec2<f32>,\\n    uBlue: vec3<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n    uInputSize:vec4<f32>,\\n    uInputPixel:vec4<f32>,\\n    uInputClamp:vec4<f32>,\\n    uOutputFrame:vec4<f32>,\\n    uGlobalFrame:vec4<f32>,\\n    uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> rgbSplitUniforms : RgbSplitUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n    let r = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uRed.x / gfu.uInputSize.x, rgbSplitUniforms.uRed.y / gfu.uInputSize.y)).r;\\n    let g = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uGreen.x / gfu.uInputSize.x, rgbSplitUniforms.uGreen.y / gfu.uInputSize.y)).g;\\n    let b = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uBlue.x / gfu.uInputSize.x, rgbSplitUniforms.uBlue.y / gfu.uInputSize.y)).b;\\n    let a = textureSample(uTexture, uSampler, uv).a;\\n    return vec4<f32>(r, g, b, a);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=rgb-split.mjs.map\n", "import { deprecation, Filter, GlProgram, GpuProgram, PointData } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './rgb-split.frag';\nimport source from './rgb-split.wgsl';\n\ntype OffsetType = PointData | [number, number];\n\n/** Options for the RGBSplitFilter constructor. */\nexport interface RGBSplitFilterOptions\n{\n    /**\n     * The amount of offset for the red channel.\n     * @default {x:-10,y:0}\n     */\n    red?: OffsetType;\n    /**\n     * The amount of offset for the green channel.\n     * @default {x:0,y:10}\n     */\n    green?: OffsetType;\n    /**\n     * The amount of offset for the blue channel.\n     * @default {x:0,y:0}\n     */\n    blue?: OffsetType;\n}\n\n/**\n * An RGB Split Filter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/rgb.png)\n *\n * @class\n * @extends Filter\n */\nexport class RGBSplitFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: RGBSplitFilterOptions = {\n        red: { x: -10, y: 0 },\n        green: { x: 0, y: 10 },\n        blue: { x: 0, y: 0 },\n    };\n\n    public uniforms: {\n        uRed: PointData;\n        uGreen: PointData;\n        uBlue: PointData;\n    };\n\n    /**\n     * @param options - Options for the RGBSplitFilter constructor.\n     */\n    constructor(options?: RGBSplitFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {PIXI.PointData | number[]} [red=[-10,0]] - Red channel offset\n     * @param {PIXI.PointData | number[]} [green=[0, 10]] - Green channel offset\n     * @param {PIXI.PointData | number[]} [blue=[0, 0]] - Blue channel offset\n     */\n    constructor(red?: OffsetType, green?: OffsetType, blue?: OffsetType);\n    /** @ignore */\n    constructor(...args: [RGBSplitFilterOptions?] | [OffsetType?, OffsetType?, OffsetType?])\n    {\n        let options = args[0] ?? {};\n\n        if (Array.isArray(options) || ('x' in options && 'y' in options))\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'RGBSplitFilter constructor params are now options object. See params: { red, green, blue }');\n\n            options = { red: options };\n\n            if (args[1] !== undefined) options.green = args[1];\n            if (args[2] !== undefined) options.blue = args[2];\n        }\n\n        options = { ...RGBSplitFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'rgb-split-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                rgbSplitUniforms: {\n                    uRed: { value: options.red, type: 'vec2<f32>' },\n                    uGreen: { value: options.green, type: 'vec2<f32>' },\n                    uBlue: { value: options.blue, type: 'vec2<f32>' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.rgbSplitUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Red channel offset.\n     * @default {x:-10,y:0}\n     */\n    get red(): PointData { return this.uniforms.uRed; }\n    set red(value: OffsetType)\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uRed = value;\n    }\n\n    /**\n     * Amount of x-axis offset for the red channel.\n     * @default -10\n     */\n    get redX(): number { return this.red.x; }\n    set redX(value: number) { this.red.x = value; }\n\n    /**\n     * Amount of y-axis offset for the red channel.\n     * @default 0\n     */\n    get redY(): number { return this.red.y; }\n    set redY(value: number) { this.red.y = value; }\n\n    /**\n     * Green channel offset.\n     * @default {x:0,y:10}\n     */\n    get green(): PointData { return this.uniforms.uGreen; }\n    set green(value: OffsetType)\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uGreen = value;\n    }\n\n    /**\n     * Amount of x-axis offset for the green channel.\n     * @default 0\n     */\n    get greenX(): number { return this.green.x; }\n    set greenX(value: number) { this.green.x = value; }\n\n    /**\n     * Amount of y-axis offset for the green channel.\n     * @default 10\n     */\n    get greenY(): number { return this.green.y; }\n    set greenY(value: number) { this.green.y = value; }\n\n    /**\n     * Blue channel offset.\n     * @default {x:0,y:0}\n     */\n    get blue(): PointData { return this.uniforms.uBlue; }\n    set blue(value: OffsetType)\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uBlue = value;\n    }\n\n    /**\n     * Amount of x-axis offset for the blue channel.\n     * @default 0\n     */\n    get blueX(): number { return this.blue.x; }\n    set blueX(value: number) { this.blue.x = value; }\n\n    /**\n     * Amount of y-axis offset for the blue channel.\n     * @default 0\n     */\n    get blueY(): number { return this.blue.y; }\n    set blueY(value: number) { this.blue.y = value; }\n}\n", "var fragment = \"\\nprecision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uCenter;\\nuniform float uTime;\\nuniform float uSpeed;\\nuniform vec4 uWave;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nconst float PI = 3.14159;\\n\\nvoid main()\\n{\\n    float uAmplitude = uWave[0];\\n    float uWavelength = uWave[1];\\n    float uBrightness = uWave[2];\\n    float uRadius = uWave[3];\\n\\n    float halfWavelength = uWavelength * 0.5 / uInputSize.x;\\n    float maxRadius = uRadius / uInputSize.x;\\n    float currentRadius = uTime * uSpeed / uInputSize.x;\\n\\n    float fade = 1.0;\\n\\n    if (maxRadius > 0.0) {\\n        if (currentRadius > maxRadius) {\\n            finalColor = texture(uTexture, vTextureCoord);\\n            return;\\n        }\\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\\n    }\\n\\n    vec2 dir = vec2(vTextureCoord - uCenter / uInputSize.xy);\\n    dir.y *= uInputSize.y / uInputSize.x;\\n    float dist = length(dir);\\n\\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\\n        finalColor = texture(uTexture, vTextureCoord);\\n        return;\\n    }\\n\\n    vec2 diffUV = normalize(dir);\\n\\n    float diff = (dist - currentRadius) / halfWavelength;\\n\\n    float p = 1.0 - pow(abs(diff), 2.0);\\n\\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\\n    float powDiff = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\\n\\n    vec2 offset = diffUV * powDiff / uInputSize.xy;\\n\\n    // Do clamp :\\n    vec2 coord = vTextureCoord + offset;\\n    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\\n    vec4 color = texture(uTexture, clampedCoord);\\n    if (coord != clampedCoord) {\\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\\n    }\\n\\n    // No clamp :\\n    // finalColor = texture(uTexture, vTextureCoord + offset);\\n\\n    color.rgb *= 1.0 + (uBrightness - 1.0) * p * fade;\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=shockwave2.mjs.map\n", "var source = \"\\nstruct ShockWaveUniforms {\\n    uTime: f32,\\n    uOffset: vec2<f32>,\\n    uSpeed: f32,\\n    uWave: vec4<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n    uInputSize:vec4<f32>,\\n    uInputPixel:vec4<f32>,\\n    uInputClamp:vec4<f32>,\\n    uOutputFrame:vec4<f32>,\\n    uGlobalFrame:vec4<f32>,\\n    uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> shockwaveUniforms : ShockWaveUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    let uTime = shockwaveUniforms.uTime;\\n    let uOffset = shockwaveUniforms.uOffset;\\n    let uSpeed = shockwaveUniforms.uSpeed;\\n    let uAmplitude = shockwaveUniforms.uWave[0];\\n    let uWavelength = shockwaveUniforms.uWave[1];\\n    let uBrightness = shockwaveUniforms.uWave[2];\\n    let uRadius = shockwaveUniforms.uWave[3];\\n    let halfWavelength: f32 = uWavelength * 0.5 / gfu.uInputSize.x;\\n    let maxRadius: f32 = uRadius / gfu.uInputSize.x;\\n    let currentRadius: f32 = uTime * uSpeed / gfu.uInputSize.x;\\n    var fade: f32 = 1.0;\\n    var returnColorOnly: bool = false;\\n    \\n    if (maxRadius > 0.0) {\\n        if (currentRadius > maxRadius) {\\n            returnColorOnly = true;\\n        }\\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\\n    }\\n    var dir: vec2<f32> = vec2<f32>(uv - uOffset / gfu.uInputSize.xy);\\n    dir.y *= gfu.uInputSize.y / gfu.uInputSize.x;\\n\\n    let dist:f32 = length(dir);\\n\\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\\n        returnColorOnly = true;\\n    }\\n\\n    let diffUV: vec2<f32> = normalize(dir);\\n    let diff: f32 = (dist - currentRadius) / halfWavelength;\\n    let p: f32 = 1.0 - pow(abs(diff), 2.0);\\n    let powDiff: f32 = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\\n    let offset: vec2<f32> = diffUV * powDiff / gfu.uInputSize.xy;\\n    // Do clamp :\\n    let coord: vec2<f32> = uv + offset;\\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);\\n\\n    var clampedColor: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);\\n    \\n    if (boolVec2(coord, clampedCoord)) \\n    {\\n        clampedColor *= max(0.0, 1.0 - length(coord - clampedCoord));\\n    }\\n    // No clamp :\\n    var finalColor = clampedColor;\\n\\n    return select(finalColor, textureSample(uTexture, uSampler, uv), returnColorOnly);\\n}\\n\\nfn boolVec2(x: vec2<f32>, y: vec2<f32>) -> bool\\n{\\n    if (x.x == y.x && x.y == y.y)\\n    {\\n        return true;\\n    }\\n    \\n    return false;\\n}\\n\\nconst PI: f32 = 3.14159265358979323846264;\\n\";\n\nexport { source as default };\n//# sourceMappingURL=shockwave.mjs.map\n", "import {\n    deprecation,\n    Filter,\n    FilterSystem,\n    GlProgram,\n    GpuProgram,\n    PointData,\n    RenderSurface,\n    Texture,\n} from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './shockwave.frag';\nimport source from './shockwave.wgsl';\n\n/** Options for the ShockwaveFilter constructor. */\nexport interface ShockwaveFilterOptions\n{\n    /**\n     * The `x` and `y` center coordinates to change the position of the center of the circle of effect.\n     * @default {x:0,y:0}\n     */\n    center?: PointData;\n    /**\n     * The speed about the shockwave ripples out. The unit is `pixel-per-second`\n     * @default 500\n     */\n    speed?: number;\n    /**\n     * The amplitude of the shockwave\n     * @default 30\n     */\n    amplitude?: number;\n    /**\n     * The wavelength of the shockwave\n     * @default 160\n     */\n    wavelength?: number;\n    /**\n     * The brightness of the shockwave\n     * @default 1\n     */\n    brightness?: number;\n    /**\n     * The maximum radius of shockwave. less than `0` means the max is an infinite distance\n     * @default -1\n     */\n    radius?: number;\n    /**\n     * Sets the elapsed time of the shockwave.\n     * @default 0\n     */\n    time?: number;\n}\n\n/**\n * Create a visual wrinkle effect by like a pond or blast wave.<br />\n * ![original](../screenshots/original.png)![filter](../screenshots/shockwave.gif)\n *\n * {@link https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js original filter}\n * @author Vico @vicocotea\n */\nexport class ShockwaveFilter extends Filter\n{\n    /** Default shockwave filter options */\n    public static readonly DEFAULT_OPTIONS: ShockwaveFilterOptions = {\n        /** The `x` and `y` center coordinates to change the position of the center of the circle of effect. */\n        center: { x: 0, y: 0 },\n        /** The speed about the shockwave ripples out. The unit is `pixel-per-second` */\n        speed: 500,\n        /** The amplitude of the shockwave */\n        amplitude: 30,\n        /** The wavelength of the shockwave */\n        wavelength: 160,\n        /** The brightness of the shockwave */\n        brightness: 1,\n        /** The maximum radius of shockwave. less than `0` means the max is an infinite distance */\n        radius: -1,\n    };\n\n    public uniforms: {\n        uTime: number;\n        uCenter: PointData;\n        uSpeed: number;\n        uWave: Float32Array;\n    };\n\n    /** Sets the elapsed time of the shockwave. It could control the current size of shockwave. */\n    public time: number;\n\n    /**\n     * @param options - Options for the ShockwaveFilter constructor.\n     */\n    constructor(options?: ShockwaveFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {PIXI.PointData|number[]} [center=[0.5, 0.5]] - See `center` property.\n     * @param {object} [options] - The optional parameters of shockwave filter.\n     * @param {number} [options.amplitude=0.5] - See `amplitude`` property.\n     * @param {number} [options.wavelength=1.0] - See `wavelength` property.\n     * @param {number} [options.speed=500.0] - See `speed` property.\n     * @param {number} [options.brightness=8] - See `brightness` property.\n     * @param {number} [options.radius=4] - See `radius` property.\n     * @param {number} [time=0] - See `time` property.\n     */\n    constructor(center?: PointData | number[], options?: Omit<ShockwaveFilterOptions, 'time' | 'center'>, time?: number);\n    /** @ignore */\n    // eslint-disable-next-line max-len\n    constructor(...args: [ShockwaveFilterOptions?] | [(PointData | number[])?, Omit<ShockwaveFilterOptions, 'time' | 'center'>?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (Array.isArray(options) || ('x' in options && 'y' in options))\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'ShockwaveFilter constructor params are now options object. See params: { center, speed, amplitude, wavelength, brightness, radius, time }');\n\n            options = { center: options, ...args[1] } as ShockwaveFilterOptions;\n\n            if (args[2] !== undefined) options.time = args[2];\n        }\n\n        options = { ...ShockwaveFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'shockwave-filter'\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                shockwaveUniforms: {\n                    uTime: { value: options.time, type: 'f32' },\n                    uCenter: { value: options.center, type: 'vec2<f32>' },\n                    uSpeed: { value: options.speed, type: 'f32' },\n                    uWave: { value: new Float32Array(4), type: 'vec4<f32>' },\n                },\n            },\n        });\n\n        this.time = 0;\n\n        this.uniforms = this.resources.shockwaveUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        // There is no set/get of `time`, for performance.\n        // Because in the most real cases, `time` will be changed in ever game tick.\n        // Use set/get will take more function-call.\n        this.uniforms.uTime = this.time;\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * The `x` and `y` center coordinates to change the position of the center of the circle of effect.\n     * @default [0,0]\n     */\n    get center(): PointData { return this.uniforms.uCenter; }\n    set center(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uCenter = value;\n    }\n\n    /**\n     * Sets the center of the effect in normalized screen coords on the `x` axis\n     * @default 0\n     */\n    get centerX(): number { return this.uniforms.uCenter.x; }\n    set centerX(value: number) { this.uniforms.uCenter.x = value; }\n\n    /**\n     * Sets the center of the effect in normalized screen coords on the `y` axis\n     * @default 0\n     */\n    get centerY(): number { return this.uniforms.uCenter.y; }\n    set centerY(value: number) { this.uniforms.uCenter.y = value; }\n\n    /**\n     * The speed about the shockwave ripples out. The unit is `pixel-per-second`\n     * @default 500\n     */\n    get speed(): number { return this.uniforms.uSpeed; }\n    set speed(value: number) { this.uniforms.uSpeed = value; }\n\n    /**\n     * The amplitude of the shockwave\n     * @default 30\n     */\n    get amplitude(): number { return this.uniforms.uWave[0]; }\n    set amplitude(value: number) { this.uniforms.uWave[0] = value; }\n\n    /**\n     * The wavelength of the shockwave\n     * @default 160\n     */\n    get wavelength(): number { return this.uniforms.uWave[1]; }\n    set wavelength(value: number) { this.uniforms.uWave[1] = value; }\n\n    /**\n     * The brightness of the shockwave\n     * @default 1\n     */\n    get brightness(): number { return this.uniforms.uWave[2]; }\n    set brightness(value: number) { this.uniforms.uWave[2] = value; }\n\n    /**\n     * The maximum radius of shockwave. less than `0` means the max is an infinite distance\n     * @default -1\n     */\n    get radius(): number { return this.uniforms.uWave[3]; }\n    set radius(value: number) { this.uniforms.uWave[3] = value; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\nuniform vec3 uColor;\\nuniform float uAlpha;\\nuniform vec2 uDimensions;\\n\\nuniform vec4 uInputSize;\\n\\nvoid main() {\\n    vec4 diffuseColor = texture(uTexture, vTextureCoord);\\n    vec2 lightCoord = (vTextureCoord * uInputSize.xy) / uDimensions;\\n    vec4 light = texture(uMapTexture, lightCoord);\\n    vec3 ambient = uColor.rgb * uAlpha;\\n    vec3 intensity = ambient + light.rgb;\\n    vec3 color = diffuseColor.rgb * intensity;\\n    finalColor = vec4(color, diffuseColor.a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=simple-lightmap.mjs.map\n", "var source = \"struct SimpleLightmapUniforms {\\n  uColor: vec3<f32>,\\n  uAlpha: f32,\\n  uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> simpleLightmapUniforms : SimpleLightmapUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n@group(1) @binding(2) var uMapSampler: sampler;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>,\\n) -> @location(0) vec4<f32> {\\n  let uColor = simpleLightmapUniforms.uColor;\\n  let uAlpha = simpleLightmapUniforms.uAlpha;\\n  let uDimensions = simpleLightmapUniforms.uDimensions;\\n\\n  let diffuseColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let lightCoord: vec2<f32> = (uv * gfu.uInputSize.xy) / simpleLightmapUniforms.uDimensions;\\n  let light: vec4<f32> = textureSample(uMapTexture, uMapSampler, lightCoord);\\n  let ambient: vec3<f32> = uColor * uAlpha;\\n  let intensity: vec3<f32> = ambient + light.rgb;\\n  let finalColor: vec3<f32> = diffuseColor.rgb * intensity;\\n  return vec4<f32>(finalColor, diffuseColor.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=simple-lightmap2.mjs.map\n", "import {\n    Color,\n    ColorSource,\n    deprecation,\n    Filter,\n    FilterSystem,\n    GlProgram,\n    GpuProgram,\n    RenderSurface,\n    Texture,\n} from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './simple-lightmap.frag';\nimport source from './simple-lightmap.wgsl';\n\ntype DeprecatedColor = number | number[];\n\n/** Options for the SimpleLightmapFilter constructor. */\nexport interface SimpleLightmapFilterOptions\n{\n    /** A texture where your lightmap is rendered */\n    lightMap: Texture;\n    /**\n     * The color value of the ambient color\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0x000000\n     */\n    color?: ColorSource;\n    /**\n     * Coefficient for alpha multiplication\n     * @default 1\n     */\n    alpha?: number;\n}\n\n/**\n* SimpleLightmap, originally by Oza94\n* {@link http://www.html5gamedevs.com/topic/20027-pixijs-simple-lightmapping/}\n* {@link http://codepen.io/Oza94/pen/EPoRxj}\n*\n* You have to specify filterArea, or suffer consequences.\n* You may have to use it with `filter.dontFit = true`,\n*  until we rewrite this using same approach as for DisplacementFilter.\n*\n* ![original](../screenshots/original.png)![filter](../screenshots/simple-lightmap.png)\n* @class\n* @extends Filter\n* @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}\n*\n* @example\n*  displayObject.filters = [new SimpleLightmapFilter(texture, 0x666666)];\n*/\nexport class SimpleLightmapFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: SimpleLightmapFilterOptions = {\n        lightMap: Texture.WHITE,\n        color: 0x000000,\n        alpha: 1\n    };\n\n    public uniforms: {\n        uColor: Float32Array;\n        uAlpha: number;\n        uDimensions: Float32Array;\n    };\n\n    private _color!: Color;\n    private _lightMap!: Texture;\n\n    /**\n     * @param options - Options for the SimpleLightmapFilter constructor.\n     */\n    constructor(options: SimpleLightmapFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {PIXI.Texture} texture - a texture where your lightmap is rendered\n     * @param {Array<number>|number} [color=0x000000] - An RGBA array of the ambient color\n     * @param {number} [alpha=1] - Default alpha set independent of color (if it's a number, not array).\n     */\n    constructor(texture: Texture, color?: DeprecatedColor, alpha?: number);\n    /** @ignore */\n    constructor(...args: [SimpleLightmapFilterOptions] | [Texture, DeprecatedColor?, number?])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Texture)\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'SimpleLightmapFilter constructor params are now options object. See params: { lightMap, color, alpha }');\n\n            options = { lightMap: options };\n\n            if (args[1] !== undefined) options.color = args[1];\n            if (args[2] !== undefined) options.alpha = args[2];\n        }\n\n        options = { ...SimpleLightmapFilter.DEFAULT_OPTIONS, ...options };\n\n        if (!options.lightMap) throw Error('No light map texture source was provided to SimpleLightmapFilter');\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'simple-lightmap-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                simpleLightmapUniforms: {\n                    uColor: { value: new Float32Array(3), type: 'vec3<f32>' },\n                    uAlpha: { value: options.alpha, type: 'f32' },\n                    uDimensions: { value: new Float32Array(2), type: 'vec2<f32>' },\n                },\n                uMapTexture: options.lightMap.source,\n                uMapSampler: options.lightMap.source.style,\n            },\n        });\n\n        this.uniforms = this.resources.simpleLightmapUniforms.uniforms;\n        this._color = new Color();\n        this.color = options.color ?? 0x000000;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean,\n    ): void\n    {\n        this.uniforms.uDimensions[0] = input.frame.width;\n        this.uniforms.uDimensions[1] = input.frame.height;\n\n        // draw the filter...\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /** A sprite where your lightmap is rendered */\n    get lightMap(): Texture { return this._lightMap; }\n    set lightMap(value: Texture)\n    {\n        this._lightMap = value;\n        this.resources.uMapTexture = value.source;\n        this.resources.uMapSampler = value.source.style;\n    }\n\n    /**\n     * The color value of the ambient color\n     * @example [1.0, 1.0, 1.0] = 0xffffff\n     * @default 0x000000\n     */\n    get color(): ColorSource { return this._color.value as ColorSource; }\n    set color(value: ColorSource)\n    {\n        this._color.setValue(value);\n        const [r, g, b] = this._color.toArray();\n\n        this.uniforms.uColor[0] = r;\n        this.uniforms.uColor[1] = g;\n        this.uniforms.uColor[2] = b;\n    }\n\n    /**\n     * Coefficient for alpha multiplication\n     * @default 1\n     */\n    get alpha(): number { return this.uniforms.uAlpha; }\n    set alpha(value: number) { this.uniforms.uAlpha = value; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uStrength;\\nuniform float uNoiseScale;\\nuniform float uOffsetX;\\nuniform float uOffsetY;\\nuniform float uOffsetZ;\\nuniform float uStep;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\n//Noise from: https://www.shadertoy.com/view/4sc3z2\\nconst vec3 MOD3 = vec3(.1031,.11369,.13787);\\nvec3 hash33(vec3 p3)\\n{\\n\\tp3 = fract(p3 * MOD3);\\n    p3 += dot(p3, p3.yxz+19.19);\\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\\n}\\n\\nfloat simplex_noise(vec3 p)\\n{\\n    const float K1 = 0.333333333;\\n    const float K2 = 0.166666667;\\n    \\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\\n    \\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\\n\\tvec3 i1 = e * (1.0 - e.zxy);\\n\\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\\n    \\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\\n    \\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\\n    \\n    return dot(vec4(31.316), n);\\n}\\n\\nvoid main(void)\\n{\\n    float noise = simplex_noise(\\n                    vec3(vTextureCoord*uNoiseScale+vec2(uOffsetX, uOffsetY), uOffsetZ)\\n                ) * 0.5 + 0.5;\\n\\n    noise += 2.0 * uStrength - 1.0;\\n    noise = clamp(noise, 0.0, 1.0);\\n\\n    if (uStep > 0.0) {  //step > 0.5\\n        noise = 1.0 - step(noise, uStep);\\n    }\\n\\n    finalColor = texture(uTexture, vTextureCoord) * noise;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=simplex.mjs.map\n", "var source = \"struct SimplexUniforms {\\n  uStrength:f32,\\n  uNoiseScale:f32,\\n  uOffsetX:f32,\\n  uOffsetY:f32,\\n  uOffsetZ:f32,\\n  uStep:f32\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> simplexUniforms : SimplexUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  var noise: f32 = simplex_noise(vec3<f32>(uv * simplexUniforms.uNoiseScale + vec2<f32>(simplexUniforms.uOffsetX, simplexUniforms.uOffsetY), simplexUniforms.uOffsetZ)) * 0.5 + 0.5;\\n\\tnoise = noise + (2. * simplexUniforms.uStrength - 1.);\\n\\tnoise = clamp(noise, 0.0, 1.0);\\n\\tif (simplexUniforms.uStep > 0.0) {\\n\\t\\tnoise = 1. - step(noise, simplexUniforms.uStep);\\n\\t}\\n\\treturn textureSample(uTexture, uSampler, uv) * noise;\\n}\\n\\nconst MOD3: vec3<f32> = vec3<f32>(0.1031, 0.11369, 0.13787);\\nfn hash33(p3: vec3<f32>) -> vec3<f32> {\\n\\tvar p3_var = p3;\\n\\tp3_var = fract(p3_var * MOD3);\\n\\tp3_var = p3_var + (dot(p3_var, p3_var.yxz + 19.19));\\n\\treturn -1. + 2. * fract(vec3<f32>((p3_var.x + p3_var.y) * p3_var.z, (p3_var.x + p3_var.z) * p3_var.y, (p3_var.y + p3_var.z) * p3_var.x));\\n} \\n\\nfn simplex_noise(p: vec3<f32>) -> f32 {\\n\\tlet K1: f32 = 0.33333334;\\n\\tlet K2: f32 = 0.16666667;\\n\\tlet i: vec3<f32> = floor(p + (p.x + p.y + p.z) * K1);\\n\\tlet d0: vec3<f32> = p - (i - (i.x + i.y + i.z) * K2);\\n\\tlet e: vec3<f32> = step(vec3<f32>(0.), d0 - d0.yzx);\\n\\tlet i1: vec3<f32> = e * (1. - e.zxy);\\n\\tlet i2: vec3<f32> = 1. - e.zxy * (1. - e);\\n\\tlet d1: vec3<f32> = d0 - (i1 - 1. * K2);\\n\\tlet d2: vec3<f32> = d0 - (i2 - 2. * K2);\\n\\tlet d3: vec3<f32> = d0 - (1. - 3. * K2);\\n\\tlet h: vec4<f32> = max(vec4<f32>(0.6) - vec4<f32>(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), vec4<f32>(0.0));\\n\\tlet n: vec4<f32> = h * h * h * h * vec4<f32>(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.)));\\n\\treturn dot(vec4<f32>(31.316), n);\\n} \";\n\nexport { source as default };\n//# sourceMappingURL=simplex2.mjs.map\n", "import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './simplex.frag';\nimport source from './simplex.wgsl';\n\n/** Options for the SimplexNoiseFilter constructor. */\nexport interface SimplexNoiseFilterOptions\n{\n    /**\n     * Noise map strength.\n     * @default 0.5\n     */\n    strength?: number;\n    /**\n     * Noise map scale.\n     * @default 10.0\n     */\n    noiseScale?: number;\n    /**\n     * Horizontal offset for the noise map.\n     * @default 0\n     */\n    offsetX?: number;\n    /**\n     * Vertical offset for the noise map.\n     * @default 0\n     */\n    offsetY?: number;\n    /**\n     * Depth offset for the noise map.\n     * @default 0\n     */\n    offsetZ?: number;\n    /**\n     * The threshold used with the step function to create a blocky effect in the noise pattern.\n     * When this is greater than 0, the step function is used to compare the noise value to this threshold.\n     * @default -1\n     */\n    step?: number;\n}\n\n/**\n * The SimplexNoiseFilter multiplies simplex noise with the current texture data. <br>\n * ![original](../screenshots/original.png)![filter](../screenshots/simplex-noise.png)\n * @class\n * @extends Filter\n * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}\n */\nexport class SimplexNoiseFilter extends Filter\n{\n    /** Default constructor options. */\n    public static readonly defaults: SimplexNoiseFilterOptions = {\n        strength: 0.5,\n        noiseScale: 10.0,\n        offsetX: 0,\n        offsetY: 0,\n        offsetZ: 0,\n        step: -1,\n    };\n\n    /**\n     * @param options - Options for the SimplexNoise constructor.\n     */\n    constructor(options?: SimplexNoiseFilterOptions)\n    {\n        options = { ...SimplexNoiseFilter.defaults, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'simplex-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                simplexUniforms: {\n                    uStrength: { value: options?.strength ?? 0, type: 'f32' },\n                    uNoiseScale: { value: options?.noiseScale ?? 0, type: 'f32' },\n                    uOffsetX: { value: options?.offsetX ?? 0, type: 'f32' },\n                    uOffsetY: { value: options?.offsetY ?? 0, type: 'f32' },\n                    uOffsetZ: { value: options?.offsetZ ?? 0, type: 'f32' },\n                    uStep: { value: options?.step ?? 0, type: 'f32' },\n                }\n            }\n        });\n    }\n\n    /**\n     * Strength of the noise (color = (noiseMap + strength) * texture)\n     * @default 0.5\n     */\n    get strength(): number { return this.resources.simplexUniforms.uniforms.uStrength; }\n    set strength(value: number) { this.resources.simplexUniforms.uniforms.uStrength = value; }\n\n    /**\n     * Noise map scale.\n     * @default 10\n     */\n    get noiseScale(): number { return this.resources.simplexUniforms.uniforms.uNoiseScale; }\n    set noiseScale(value: number) { this.resources.simplexUniforms.uniforms.uNoiseScale = value; }\n\n    /**\n     * Horizontal offset for the noise map.\n     * @default 0\n     */\n    get offsetX(): number { return this.resources.simplexUniforms.uniforms.uOffsetX; }\n    set offsetX(value: number) { this.resources.simplexUniforms.uniforms.uOffsetX = value; }\n\n    /**\n     * Vertical offset for the noise map.\n     * @default 0\n     */\n    get offsetY(): number { return this.resources.simplexUniforms.uniforms.uOffsetY; }\n    set offsetY(value: number) { this.resources.simplexUniforms.uniforms.uOffsetY = value; }\n\n    /**\n     * Depth offset for the noise map.\n     * @default 0\n     */\n    get offsetZ(): number { return this.resources.simplexUniforms.uniforms.uOffsetZ; }\n    set offsetZ(value: number) { this.resources.simplexUniforms.uniforms.uOffsetZ = value; }\n\n    /**\n     * The threshold used with the step function to create a blocky effect in the noise pattern.\n     * When this is greater than 0, the step function is used to compare the noise value to this threshold.\n     * @default -1\n     */\n    get step(): number { return this.resources.simplexUniforms.uniforms.uStep; }\n    set step(value: number) { this.resources.simplexUniforms.uniforms.uStep = value; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uBlur;\\nuniform vec2 uStart;\\nuniform vec2 uEnd;\\nuniform vec2 uDelta;\\nuniform vec4 uInputSize;\\n\\nfloat random(vec3 scale, float seed)\\n{\\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\\n}\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n    float total = 0.0;\\n\\n    float blur = uBlur[0];\\n    float gradientBlur = uBlur[1];\\n\\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\\n    vec2 normal = normalize(vec2(uStart.y - uEnd.y, uEnd.x - uStart.x));\\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * uInputSize.xy - uStart, normal)) / gradientBlur) * blur;\\n\\n    for (float t = -30.0; t <= 30.0; t++)\\n    {\\n        float percent = (t + offset - 0.5) / 30.0;\\n        float weight = 1.0 - abs(percent);\\n        vec4 sample = texture(uTexture, vTextureCoord + uDelta / uInputSize.xy * percent * radius);\\n        sample.rgb *= sample.a;\\n        color += sample * weight;\\n        total += weight;\\n    }\\n\\n    color /= total;\\n    color.rgb /= color.a + 0.00001;\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=tilt-shift.mjs.map\n", "var source = \"struct TiltShiftUniforms {\\n  uBlur: vec2<f32>,\\n  uStart: vec2<f32>,\\n  uEnd: vec2<f32>,\\n  uDelta: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> tiltShiftUniforms : TiltShiftUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uBlur = tiltShiftUniforms.uBlur[0];\\n  let uBlurGradient = tiltShiftUniforms.uBlur[1];\\n  let uStart = tiltShiftUniforms.uStart;\\n  let uEnd = tiltShiftUniforms.uEnd;\\n  let uDelta = tiltShiftUniforms.uDelta;\\n\\n  var color: vec4<f32> = vec4<f32>(0.0);\\n  var total: f32 = 0.0;\\n\\n  let offset: f32 = random(position, vec3<f32>(12.9898, 78.233, 151.7182), 0.0);\\n  let normal: vec2<f32> = normalize(vec2<f32>(uStart.y - uEnd.y, uEnd.x - uStart.x));\\n  let radius: f32 = smoothstep(0.0, 1.0, abs(dot(uv * gfu.uInputSize.xy - uStart, normal)) / uBlurGradient) * uBlur;\\n\\n  for (var t: f32 = -30.0; t <= 30.0; t += 1.0)\\n  {\\n    var percent: f32 = (t + offset - 0.5) / 30.0;\\n    var weight: f32 = 1.0 - abs(percent);\\n    var sample: vec4<f32> = textureSample(uTexture, uSampler, uv + uDelta / gfu.uInputSize.xy * percent * radius);\\n    sample = vec4<f32>(sample.xyz * sample.a, sample.a); // multiply sample.rgb with sample.a\\n    color += sample * weight;\\n    total += weight;\\n  }\\n\\n  color /= total;\\n  color = vec4<f32>(color.xyz / (color.a + 0.00001), color.a); // divide color.rgb by color.a + 0.00001\\n\\n  return color;\\n}\\n\\n\\nfn random(position: vec4<f32>, scale: vec3<f32>, seed: f32) -> f32\\n{\\n  return fract(sin(dot(position.xyz + seed, scale)) * 43758.5453 + seed);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=tilt-shift2.mjs.map\n", "import { Filter, GlProgram, GpuProgram, PointData, ViewSystem } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './tilt-shift.frag';\nimport source from './tilt-shift.wgsl';\n\n// @author Vico @vicocotea\n// original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n// by Evan Wallace : http://madebyevan.com/\n\n/**\n * Options for creating filter.\n */\ninterface TiltShiftAxisFilterOptions\n{\n    /** The strength of the blur. */\n    blur?: number;\n    /** The strength of the blur gradient */\n    gradientBlur?: number;\n    /** The position to start the effect at. */\n    start?: PointData;\n    /** The position to end the effect at. */\n    end?: PointData;\n    /** The axis that the filter is calculating for. */\n    axis?: 'vertical' | 'horizontal';\n}\n\n/**\n * A TiltShiftAxisFilter.\n *\n * @class\n * @extends Filter\n * @private\n */\nexport class TiltShiftAxisFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: TiltShiftAxisFilterOptions = {\n        /** The strength of the blur. */\n        blur: 100,\n        /** The strength of the blur gradient */\n        gradientBlur: 600,\n    };\n\n    public uniforms: {\n        uBlur: Float32Array;\n        uStart: PointData\n        uEnd: PointData;\n        uDelta: Float32Array;\n    };\n\n    private _tiltAxis: TiltShiftAxisFilterOptions['axis'];\n\n    constructor(options?: TiltShiftAxisFilterOptions)\n    {\n        const { width, height } = ViewSystem.defaultOptions as { width: number, height: number };\n\n        options = {\n            ...TiltShiftAxisFilter.DEFAULT_OPTIONS,\n            /** The position to start the effect at. */\n            start: { x: 0, y: height / 2 },\n            /** The position to end the effect at. */\n            end: { x: width, y: height / 2 },\n            ...options,\n        } as TiltShiftAxisFilterOptions;\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'tilt-shift-axis-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                tiltShiftUniforms: {\n                    uBlur: {\n                        value: new Float32Array([\n                            options.blur as number,\n                            options.gradientBlur as number,\n                        ]), type: 'vec2<f32>'\n                    },\n                    uStart: { value: options.start, type: 'vec2<f32>' },\n                    uEnd: { value: options.end, type: 'vec2<f32>' },\n                    uDelta: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n                },\n            },\n        });\n\n        this.uniforms = this.resources.tiltShiftUniforms.uniforms;\n        this._tiltAxis = options.axis;\n    }\n\n    /**\n     * Updates the filter delta values.\n     * @ignore\n     */\n    public updateDelta(): void\n    {\n        this.uniforms.uDelta[0] = 0;\n        this.uniforms.uDelta[1] = 0;\n\n        if (this._tiltAxis === undefined) return;\n\n        const end = this.uniforms.uEnd;\n        const start = this.uniforms.uStart;\n\n        const dx = end.x - start.x;\n        const dy = end.y - start.y;\n        const d = Math.sqrt((dx * dx) + (dy * dy));\n\n        const isVert = this._tiltAxis === 'vertical';\n\n        this.uniforms.uDelta[0] = !isVert ? dx / d : -dy / d;\n        this.uniforms.uDelta[1] = !isVert ? dy / d : dx / d;\n    }\n}\n", "import { FilterSystem, TexturePool } from 'pixi.js';\nimport { TiltShiftAxisFilter } from './TiltShiftAxisFilter';\n\nimport type { PointData, RenderSurface, Texture } from 'pixi.js';\n\n/** Options for the TiltShiftFilter constructor. */\nexport interface TiltShiftFilterOptions\n{\n    /** The strength of the blur. */\n    blur?: number;\n    /** The strength of the blur gradient */\n    gradientBlur?: number;\n    /** The position to start the effect at. */\n    start?: PointData;\n    /** The position to end the effect at. */\n    end?: PointData;\n}\n\n/**\n * A TiltShift Filter. Manages the pass of both a TiltShiftXFilter and TiltShiftYFilter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/tilt-shift.png)\n *\n * author Vico @vicocotea\n * {@link https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js original filter }\n * by {@link http://madebyevan.com/ Evan Wallace }\n *\n * @class\n * @extends Filter\n */\nexport class TiltShiftFilter extends TiltShiftAxisFilter\n{\n    private _tiltShiftYFilter: TiltShiftAxisFilter;\n\n    /**\n     * @param options - Options for the TiltShiftFilter constructor.\n     */\n    constructor(options?: TiltShiftFilterOptions)\n    {\n        options = { ...TiltShiftAxisFilter.DEFAULT_OPTIONS, ...options };\n\n        super({ ...options, axis: 'horizontal' });\n        this._tiltShiftYFilter = new TiltShiftAxisFilter({ ...options, axis: 'vertical' });\n\n        this.updateDelta();\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean,\n    ): void\n    {\n        const renderTarget = TexturePool.getSameSizeTexture(input);\n\n        filterManager.applyFilter(this, input, renderTarget, true);\n        filterManager.applyFilter(this._tiltShiftYFilter, renderTarget, output, clearMode);\n\n        TexturePool.returnTexture(renderTarget);\n    }\n\n    /** @ignore */\n    public override updateDelta(): void\n    {\n        super.updateDelta();\n        this._tiltShiftYFilter.updateDelta();\n    }\n\n    /** The strength of the blur. */\n    get blur(): number { return this.uniforms.uBlur[0]; }\n    set blur(value: number) { this.uniforms.uBlur[0] = this._tiltShiftYFilter.uniforms.uBlur[0] = value; }\n\n    /** The strength of the gradient blur. */\n    get gradientBlur(): number { return this.uniforms.uBlur[1]; }\n    set gradientBlur(value: number) { this.uniforms.uBlur[1] = this._tiltShiftYFilter.uniforms.uBlur[1] = value; }\n\n    /** The position to start the effect at. */\n    get start(): PointData { return this.uniforms.uStart; }\n    set start(value: PointData)\n    {\n        this.uniforms.uStart = this._tiltShiftYFilter.uniforms.uStart = value;\n        this.updateDelta();\n    }\n\n    /** The position to start the effect at on the `x` axis. */\n    get startX(): number { return this.start.x; }\n    set startX(value: number)\n    {\n        this.start.x = value;\n        this.updateDelta();\n    }\n\n    /** The position to start the effect at on the `x` axis. */\n    get startY(): number { return this.start.y; }\n    set startY(value: number)\n    {\n        this.start.y = value;\n        this.updateDelta();\n    }\n\n    /** The position to end the effect at. */\n    get end(): PointData { return this.uniforms.uEnd; }\n    set end(value: PointData)\n    {\n        this.uniforms.uEnd = this._tiltShiftYFilter.uniforms.uEnd = value;\n        this.updateDelta();\n    }\n\n    /** The position to end the effect at on the `x` axis. */\n    get endX(): number { return this.end.x; }\n    set endX(value: number)\n    {\n        this.end.x = value;\n        this.updateDelta();\n    }\n\n    /** The position to end the effect at on the `y` axis. */\n    get endY(): number { return this.end.y; }\n    set endY(value: number)\n    {\n        this.end.y = value;\n        this.updateDelta();\n    }\n}\n\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uTwist;\\nuniform vec2 uOffset;\\nuniform vec4 uInputSize;\\n\\nvec2 mapCoord( vec2 coord )\\n{\\n    coord *= uInputSize.xy;\\n    coord += uInputSize.zw;\\n\\n    return coord;\\n}\\n\\nvec2 unmapCoord( vec2 coord )\\n{\\n    coord -= uInputSize.zw;\\n    coord /= uInputSize.xy;\\n\\n    return coord;\\n}\\n\\nvec2 twist(vec2 coord)\\n{\\n    coord -= uOffset;\\n\\n    float dist = length(coord);\\n    float uRadius = uTwist[0];\\n    float uAngle = uTwist[1];\\n\\n    if (dist < uRadius)\\n    {\\n        float ratioDist = (uRadius - dist) / uRadius;\\n        float angleMod = ratioDist * ratioDist * uAngle;\\n        float s = sin(angleMod);\\n        float c = cos(angleMod);\\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\\n    }\\n\\n    coord += uOffset;\\n\\n    return coord;\\n}\\n\\nvoid main(void)\\n{\\n    vec2 coord = mapCoord(vTextureCoord);\\n    coord = twist(coord);\\n    coord = unmapCoord(coord);\\n    finalColor = texture(uTexture, coord);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=twist2.mjs.map\n", "var source = \"struct TwistUniforms {\\n  uTwist:vec2<f32>,\\n  uOffset:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> twistUniforms : TwistUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  return textureSample(uTexture, uSampler, unmapCoord(twist(mapCoord(uv))));\\n}\\n\\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n  var mappedCoord: vec2<f32> = coord;\\n  mappedCoord *= gfu.uInputSize.xy;\\n  mappedCoord += gfu.uOutputFrame.xy;\\n  return mappedCoord;\\n}\\n\\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n  var mappedCoord: vec2<f32> = coord;\\n  mappedCoord -= gfu.uOutputFrame.xy;\\n  mappedCoord /= gfu.uInputSize.xy;\\n  return mappedCoord;\\n}\\n\\nfn twist(coord: vec2<f32>) -> vec2<f32>\\n{\\n  var twistedCoord: vec2<f32> = coord;\\n  let uRadius = twistUniforms.uTwist[0];\\n  let uAngle = twistUniforms.uTwist[1];\\n  let uOffset = twistUniforms.uOffset;\\n\\n  twistedCoord -= uOffset;\\n  \\n  let dist = length(twistedCoord);\\n\\n  if (dist < uRadius)\\n  {\\n    let ratioDist: f32 = (uRadius - dist) / uRadius;\\n    let angleMod: f32 = ratioDist * ratioDist * uAngle;\\n    let s: f32 = sin(angleMod);\\n    let c: f32 = cos(angleMod);\\n    twistedCoord = vec2<f32>(twistedCoord.x * c - twistedCoord.y * s, twistedCoord.x * s + twistedCoord.y * c);\\n  }\\n\\n  twistedCoord += uOffset;\\n  return twistedCoord;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=twist.mjs.map\n", "import { Filter, GlProgram, GpuProgram, PointData } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './twist.frag';\nimport source from './twist.wgsl';\n\n/** Options for the TwistFilter constructor. */\nexport interface TwistFilterOptions\n{\n    /**\n     * Padding for the filter area\n     * @default 20\n     */\n    padding?: number;\n    /**\n     * The radius of the twist\n     * @default 200\n     */\n    radius?: number;\n    /**\n     * The angle of the twist\n     * @default 4\n     */\n    angle?: number;\n    /**\n     * The `x` and `y` offset coordinates to change the position of the center of the circle of effect.\n     * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n     * once defined in the constructor\n     * @default {x:0,y:0}\n     */\n    offset?: PointData;\n}\n\n/**\n * This filter applies a twist effect making display objects appear twisted in the given direction.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/twist.png)\n *\n * @class\n * @extends Filter\n */\nexport class TwistFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: TwistFilterOptions = {\n        padding: 20,\n        radius: 200,\n        angle: 4,\n        offset: { x: 0, y: 0 },\n    };\n\n    public uniforms: {\n        uTwist: Float32Array;\n        uOffset: PointData;\n    };\n\n    /**\n     * @param options - Options for the TwistFilter constructor.\n     */\n    constructor(options?: Partial<TwistFilterOptions>)\n    {\n        options = { ...TwistFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'twist-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                twistUniforms: {\n                    uTwist: {\n                        value: [options.radius ?? 0, options.angle ?? 0],\n                        type: 'vec2<f32>'\n                    },\n                    uOffset: {\n                        value: options.offset,\n                        type: 'vec2<f32>'\n                    },\n                }\n            },\n            ...options,\n        });\n\n        this.uniforms = this.resources.twistUniforms.uniforms;\n    }\n\n    /**\n     * The radius of the twist\n     * @default 200\n     */\n    get radius(): number { return this.uniforms.uTwist[0]; }\n    set radius(value: number) { this.uniforms.uTwist[0] = value; }\n\n    /**\n     * The angle of the twist\n     * @default 4\n     */\n    get angle(): number { return this.uniforms.uTwist[1]; }\n    set angle(value: number) { this.uniforms.uTwist[1] = value; }\n\n    /**\n     * The `x` offset coordinate to change the position of the center of the circle of effect\n     * @default 0\n     */\n    get offset(): PointData { return this.uniforms.uOffset; }\n    set offset(value: PointData) { this.uniforms.uOffset = value; }\n\n    /**\n     * The `x` offset coordinate to change the position of the center of the circle of effect\n     * @default 0\n     */\n    get offsetX(): number { return this.offset.x; }\n    set offsetX(value: number) { this.offset.x = value; }\n\n    /**\n     * The `y` offset coordinate to change the position of the center of the circle of effect\n     * @default 0\n     */\n    get offsetY(): number { return this.offset.y; }\n    set offsetY(value: number) { this.offset.y = value; }\n}\n", "var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uStrength;\\nuniform vec2 uCenter;\\nuniform vec2 uRadii;\\n\\nuniform vec4 uInputSize;\\n\\nconst float MAX_KERNEL_SIZE = ${MAX_KERNEL_SIZE};\\n\\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\\nhighp float rand(vec2 co, float seed) {\\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\\n    return fract(sin(sn) * c + seed);\\n}\\n\\nvoid main() {\\n    float minGradient = uRadii[0] * 0.3;\\n    float innerRadius = (uRadii[0] + minGradient * 0.5) / uInputSize.x;\\n\\n    float gradient = uRadii[1] * 0.3;\\n    float radius = (uRadii[1] - gradient * 0.5) / uInputSize.x;\\n\\n    float countLimit = MAX_KERNEL_SIZE;\\n\\n    vec2 dir = vec2(uCenter.xy / uInputSize.xy - vTextureCoord);\\n    float dist = length(vec2(dir.x, dir.y * uInputSize.y / uInputSize.x));\\n\\n    float strength = uStrength;\\n\\n    float delta = 0.0;\\n    float gap;\\n    if (dist < innerRadius) {\\n        delta = innerRadius - dist;\\n        gap = minGradient;\\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\\n        delta = dist - radius;\\n        gap = gradient;\\n    }\\n\\n    if (delta > 0.0) {\\n        float normalCount = gap / uInputSize.x;\\n        delta = (normalCount - delta) / normalCount;\\n        countLimit *= delta;\\n        strength *= delta;\\n        if (countLimit < 1.0)\\n        {\\n            gl_FragColor = texture(uTexture, vTextureCoord);\\n            return;\\n        }\\n    }\\n\\n    // randomize the lookup values to hide the fixed number of samples\\n    float offset = rand(vTextureCoord, 0.0);\\n\\n    float total = 0.0;\\n    vec4 color = vec4(0.0);\\n\\n    dir *= strength;\\n\\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\\n        float weight = 4.0 * (percent - percent * percent);\\n        vec2 p = vTextureCoord + dir * percent;\\n        vec4 sample = texture(uTexture, p);\\n\\n        // switch to pre-multiplied alpha to correctly blur transparent images\\n        // sample.rgb *= sample.a;\\n\\n        color += sample * weight;\\n        total += weight;\\n\\n        if (t > countLimit){\\n            break;\\n        }\\n    }\\n\\n    color /= total;\\n    // switch back from pre-multiplied alpha\\n    // color.rgb /= color.a + 0.00001;\\n\\n    gl_FragColor = color;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=zoom-blur2.mjs.map\n", "var source = \"struct ZoomBlurUniforms {\\n    uStrength:f32,\\n    uCenter:vec2<f32>,\\n    uRadii:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> zoomBlurUniforms : ZoomBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uStrength = zoomBlurUniforms.uStrength;\\n  let uCenter = zoomBlurUniforms.uCenter;\\n  let uRadii = zoomBlurUniforms.uRadii;\\n\\n  let minGradient: f32 = uRadii[0] * 0.3;\\n  let innerRadius: f32 = (uRadii[0] + minGradient * 0.5) / gfu.uInputSize.x;\\n\\n  let gradient: f32 = uRadii[1] * 0.3;\\n  let radius: f32 = (uRadii[1] - gradient * 0.5) / gfu.uInputSize.x;\\n\\n  let MAX_KERNEL_SIZE: f32 = ${MAX_KERNEL_SIZE};\\n\\n  var countLimit: f32 = MAX_KERNEL_SIZE;\\n\\n  var dir: vec2<f32> = vec2<f32>(uCenter / gfu.uInputSize.xy - uv);\\n  let dist: f32 = length(vec2<f32>(dir.x, dir.y * gfu.uInputSize.y / gfu.uInputSize.x));\\n\\n  var strength: f32 = uStrength;\\n\\n  var delta: f32 = 0.0;\\n  var gap: f32;\\n\\n  if (dist < innerRadius) {\\n      delta = innerRadius - dist;\\n      gap = minGradient;\\n  } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\\n      delta = dist - radius;\\n      gap = gradient;\\n  }\\n\\n  var returnColorOnly: bool = false;\\n\\n  if (delta > 0.0) {\\n    let normalCount: f32 = gap / gfu.uInputSize.x;\\n    delta = (normalCount - delta) / normalCount;\\n    countLimit *= delta;\\n    strength *= delta;\\n    \\n    if (countLimit < 1.0)\\n    {\\n      returnColorOnly = true;;\\n    }\\n  }\\n\\n  // randomize the lookup values to hide the fixed number of samples\\n  let offset: f32 = rand(uv, 0.0);\\n\\n  var total: f32 = 0.0;\\n  var color: vec4<f32> = vec4<f32>(0.);\\n\\n  dir *= strength;\\n\\n  for (var t = 0.0; t < MAX_KERNEL_SIZE; t += 1.0) {\\n    let percent: f32 = (t + offset) / MAX_KERNEL_SIZE;\\n    let weight: f32 = 4.0 * (percent - percent * percent);\\n    let p: vec2<f32> = uv + dir * percent;\\n    let sample: vec4<f32> = textureSample(uTexture, uSampler, p);\\n    \\n    if (t < countLimit)\\n    {\\n      color += sample * weight;\\n      total += weight;\\n    }\\n  }\\n\\n  color /= total;\\n\\n  return select(color, textureSample(uTexture, uSampler, uv), returnColorOnly);\\n}\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\\n\\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\\nfn rand(co: vec2<f32>, seed: f32) -> f32\\n{\\n  let a: f32 = 12.9898;\\n  let b: f32 = 78.233;\\n  let c: f32 = 43758.5453;\\n  let dt: f32 = dot(co + seed, vec2<f32>(a, b));\\n  let sn: f32 = modulo(dt, 3.14159);\\n  return fract(sin(sn) * c + seed);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=zoom-blur.mjs.map\n", "import { Filter, GlProgram, GpuProgram, PointData } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './zoom-blur.frag';\nimport source from './zoom-blur.wgsl';\n\n/** Options for the ZoomBlurFilter constructor. */\nexport interface ZoomBlurFilterOptions\n{\n    /**\n     * Sets the strength of the zoom blur effect\n     * @default 0.1\n     */\n    strength?: number;\n    /**\n     * The `x` and `y` offset coordinates to change the position of the center of the circle of effect.\n     * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n     * once defined in the constructor\n     * @default {x:0,y:0}\n     */\n    center?: PointData | number[];\n    /**\n     * The inner radius of zoom. The part in inner circle won't apply zoom blur effect\n     * @default 0\n     */\n    innerRadius?: number;\n    /**\n     * Outer radius of the effect. less than `0` equates to infinity\n     * @default -1\n     */\n    radius?: number;\n    /**\n     * On older iOS devices, it's better to not go above `13.0`.\n     * Decreasing this value will produce a lower-quality blur effect with more dithering\n     * @default 32\n     */\n    maxKernelSize?: number;\n}\n\n/**\n * The ZoomFilter applies a Zoom blur to an object.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/zoom-blur.png)\n *\n * @class\n * @extends Filter\n */\nexport class ZoomBlurFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: ZoomBlurFilterOptions = {\n        strength: 0.1,\n        center: { x: 0, y: 0 },\n        innerRadius: 0,\n        radius: -1,\n        maxKernelSize: 32,\n    };\n\n    public uniforms: {\n        uStrength: number;\n        uCenter: PointData;\n        uRadii: Float32Array\n    };\n\n    /**\n     * @param options - Options for the ZoomBlurFilter constructor.\n     */\n    constructor(options?: ZoomBlurFilterOptions)\n    {\n        options = { ...ZoomBlurFilter.DEFAULT_OPTIONS, ...options };\n\n        const kernelSize = options.maxKernelSize ?? 32;\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source: source.replace('${MAX_KERNEL_SIZE}', kernelSize.toFixed(1)),\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment: fragment.replace('${MAX_KERNEL_SIZE}', kernelSize.toFixed(1)),\n            name: 'zoom-blur-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                zoomBlurUniforms: {\n                    uStrength: { value: options.strength, type: 'f32' },\n                    uCenter: { value: options.center, type: 'vec2<f32>' },\n                    uRadii: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.zoomBlurUniforms.uniforms;\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Sets the strength of the zoom blur effect\n     * @default 0.1\n     */\n    get strength(): number { return this.uniforms.uStrength; }\n    set strength(value: number) { this.uniforms.uStrength = value; }\n\n    /**\n     * The center of the zoom\n     * @default [0,0]\n     */\n    get center(): PointData { return this.uniforms.uCenter; }\n    set center(value: PointData | number[])\n    {\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this.uniforms.uCenter = value;\n    }\n\n    /**\n     * Sets the center of the effect in normalized screen coords on the `x` axis\n     * @default 0\n     */\n    get centerX(): number { return this.uniforms.uCenter.x; }\n    set centerX(value: number) { this.uniforms.uCenter.x = value; }\n\n    /**\n     * Sets the center of the effect in normalized screen coords on the `y` axis\n     * @default 0\n     */\n    get centerY(): number { return this.uniforms.uCenter.y; }\n    set centerY(value: number) { this.uniforms.uCenter.y = value; }\n\n    /**\n     * The inner radius of zoom. The part in inner circle won't apply zoom blur effect\n     * @default 0\n     */\n    get innerRadius(): number { return this.uniforms.uRadii[0]; }\n    set innerRadius(value: number) { this.uniforms.uRadii[0] = value; }\n\n    /**\n     * Outer radius of the effect. less than `0` equates to infinity\n     * @default -1\n     */\n    get radius(): number { return this.uniforms.uRadii[1]; }\n    set radius(value: number) { this.uniforms.uRadii[1] = (value < 0 || value === Infinity) ? -1 : value; }\n}\n"],
  "mappings": "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",
  "names": ["_AdjustmentFilter", "fragment", "source", "_KawaseBlurFilter", "source", "fragment", "__publicField", "fragment", "source", "fragment", "source", "_ExtractBrightnessFilter", "source", "fragment", "__publicField", "_AdvancedBloomFilter", "source", "fragment", "__publicField", "fragment", "source", "_AsciiFilter", "source", "fragment", "__publicField", "fragment", "__publicField", "fragment", "fragment", "source", "_BevelFilter", "source", "fragment", "__publicField", "_BloomFilter", "__publicField", "fragment", "source", "_BulgePinchFilter", "source", "fragment", "__publicField", "fragment", "vertex", "source", "_ColorGradientFilter", "source", "vertex", "fragment", "__publicField", "fragment", "source", "_ColorMapFilter", "source", "fragment", "__publicField", "fragment", "source", "_ColorOverlayFilter", "source", "fragment", "__publicField", "fragment", "source", "_ColorReplaceFilter", "source", "fragment", "__publicField", "fragment", "source", "_ConvolutionFilter", "source", "fragment", "__publicField", "fragment", "source", "source", "fragment", "fragment", "source", "_CRTFilter", "source", "fragment", "__publicField", "fragment", "source", "_DotFilter", "source", "fragment", "__publicField", "fragment", "source", "_DropShadowFilter", "source", "fragment", "__publicField", "fragment", "source", "source", "fragment", "__publicField", "fragment", "source", "_GlitchFilter", "source", "fragment", "__publicField", "fragment", "source", "_GlowFilter", "source", "fragment", "__publicField", "fragment", "source", "_GodrayFilter", "source", "fragment", "__publicField", "fragment", "source", "source", "fragment", "fragment", "source", "_HslAdjustmentFilter", "source", "fragment", "__publicField", "fragment", "source", "_MotionBlurFilter", "source", "fragment", "__publicField", "fragment", "source", "_MultiColorReplaceFilter", "source", "fragment", "__publicField", "fragment", "source", "_OldFilmFilter", "source", "fragment", "__publicField", "fragment", "source", "_OutlineFilter", "source", "fragment", "__publicField", "fragment", "source", "source", "fragment", "fragment", "source", "_RadialBlurFilter", "source", "fragment", "__publicField", "fragment", "source", "_ReflectionFilter", "source", "fragment", "__publicField", "fragment", "source", "_RGBSplitFilter", "source", "fragment", "__publicField", "fragment", "source", "_ShockwaveFilter", "source", "fragment", "__publicField", "fragment", "source", "_SimpleLightmapFilter", "source", "fragment", "__publicField", "fragment", "source", "_SimplexNoiseFilter", "source", "fragment", "__publicField", "fragment", "source", "_TiltShiftAxisFilter", "source", "fragment", "__publicField", "__publicField", "fragment", "source", "_TwistFilter", "source", "fragment", "__publicField", "fragment", "source", "_ZoomBlurFilter", "source", "fragment", "__publicField"]
}
